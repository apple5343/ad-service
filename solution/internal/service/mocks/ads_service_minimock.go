// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i server/internal/service.AdsService -o ads_service_minimock.go -n AdsServiceMock -p mocks

import (
	"context"
	"server/internal/model"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// AdsServiceMock implements mm_service.AdsService
type AdsServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcClick          func(ctx context.Context, campaignID string, clientID string) (err error)
	funcClickOrigin    string
	inspectFuncClick   func(ctx context.Context, campaignID string, clientID string)
	afterClickCounter  uint64
	beforeClickCounter uint64
	ClickMock          mAdsServiceMockClick

	funcGet          func(ctx context.Context, clientID string) (cp1 *model.Campaign, err error)
	funcGetOrigin    string
	inspectFuncGet   func(ctx context.Context, clientID string)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mAdsServiceMockGet
}

// NewAdsServiceMock returns a mock for mm_service.AdsService
func NewAdsServiceMock(t minimock.Tester) *AdsServiceMock {
	m := &AdsServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ClickMock = mAdsServiceMockClick{mock: m}
	m.ClickMock.callArgs = []*AdsServiceMockClickParams{}

	m.GetMock = mAdsServiceMockGet{mock: m}
	m.GetMock.callArgs = []*AdsServiceMockGetParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mAdsServiceMockClick struct {
	optional           bool
	mock               *AdsServiceMock
	defaultExpectation *AdsServiceMockClickExpectation
	expectations       []*AdsServiceMockClickExpectation

	callArgs []*AdsServiceMockClickParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AdsServiceMockClickExpectation specifies expectation struct of the AdsService.Click
type AdsServiceMockClickExpectation struct {
	mock               *AdsServiceMock
	params             *AdsServiceMockClickParams
	paramPtrs          *AdsServiceMockClickParamPtrs
	expectationOrigins AdsServiceMockClickExpectationOrigins
	results            *AdsServiceMockClickResults
	returnOrigin       string
	Counter            uint64
}

// AdsServiceMockClickParams contains parameters of the AdsService.Click
type AdsServiceMockClickParams struct {
	ctx        context.Context
	campaignID string
	clientID   string
}

// AdsServiceMockClickParamPtrs contains pointers to parameters of the AdsService.Click
type AdsServiceMockClickParamPtrs struct {
	ctx        *context.Context
	campaignID *string
	clientID   *string
}

// AdsServiceMockClickResults contains results of the AdsService.Click
type AdsServiceMockClickResults struct {
	err error
}

// AdsServiceMockClickOrigins contains origins of expectations of the AdsService.Click
type AdsServiceMockClickExpectationOrigins struct {
	origin           string
	originCtx        string
	originCampaignID string
	originClientID   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmClick *mAdsServiceMockClick) Optional() *mAdsServiceMockClick {
	mmClick.optional = true
	return mmClick
}

// Expect sets up expected params for AdsService.Click
func (mmClick *mAdsServiceMockClick) Expect(ctx context.Context, campaignID string, clientID string) *mAdsServiceMockClick {
	if mmClick.mock.funcClick != nil {
		mmClick.mock.t.Fatalf("AdsServiceMock.Click mock is already set by Set")
	}

	if mmClick.defaultExpectation == nil {
		mmClick.defaultExpectation = &AdsServiceMockClickExpectation{}
	}

	if mmClick.defaultExpectation.paramPtrs != nil {
		mmClick.mock.t.Fatalf("AdsServiceMock.Click mock is already set by ExpectParams functions")
	}

	mmClick.defaultExpectation.params = &AdsServiceMockClickParams{ctx, campaignID, clientID}
	mmClick.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmClick.expectations {
		if minimock.Equal(e.params, mmClick.defaultExpectation.params) {
			mmClick.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmClick.defaultExpectation.params)
		}
	}

	return mmClick
}

// ExpectCtxParam1 sets up expected param ctx for AdsService.Click
func (mmClick *mAdsServiceMockClick) ExpectCtxParam1(ctx context.Context) *mAdsServiceMockClick {
	if mmClick.mock.funcClick != nil {
		mmClick.mock.t.Fatalf("AdsServiceMock.Click mock is already set by Set")
	}

	if mmClick.defaultExpectation == nil {
		mmClick.defaultExpectation = &AdsServiceMockClickExpectation{}
	}

	if mmClick.defaultExpectation.params != nil {
		mmClick.mock.t.Fatalf("AdsServiceMock.Click mock is already set by Expect")
	}

	if mmClick.defaultExpectation.paramPtrs == nil {
		mmClick.defaultExpectation.paramPtrs = &AdsServiceMockClickParamPtrs{}
	}
	mmClick.defaultExpectation.paramPtrs.ctx = &ctx
	mmClick.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmClick
}

// ExpectCampaignIDParam2 sets up expected param campaignID for AdsService.Click
func (mmClick *mAdsServiceMockClick) ExpectCampaignIDParam2(campaignID string) *mAdsServiceMockClick {
	if mmClick.mock.funcClick != nil {
		mmClick.mock.t.Fatalf("AdsServiceMock.Click mock is already set by Set")
	}

	if mmClick.defaultExpectation == nil {
		mmClick.defaultExpectation = &AdsServiceMockClickExpectation{}
	}

	if mmClick.defaultExpectation.params != nil {
		mmClick.mock.t.Fatalf("AdsServiceMock.Click mock is already set by Expect")
	}

	if mmClick.defaultExpectation.paramPtrs == nil {
		mmClick.defaultExpectation.paramPtrs = &AdsServiceMockClickParamPtrs{}
	}
	mmClick.defaultExpectation.paramPtrs.campaignID = &campaignID
	mmClick.defaultExpectation.expectationOrigins.originCampaignID = minimock.CallerInfo(1)

	return mmClick
}

// ExpectClientIDParam3 sets up expected param clientID for AdsService.Click
func (mmClick *mAdsServiceMockClick) ExpectClientIDParam3(clientID string) *mAdsServiceMockClick {
	if mmClick.mock.funcClick != nil {
		mmClick.mock.t.Fatalf("AdsServiceMock.Click mock is already set by Set")
	}

	if mmClick.defaultExpectation == nil {
		mmClick.defaultExpectation = &AdsServiceMockClickExpectation{}
	}

	if mmClick.defaultExpectation.params != nil {
		mmClick.mock.t.Fatalf("AdsServiceMock.Click mock is already set by Expect")
	}

	if mmClick.defaultExpectation.paramPtrs == nil {
		mmClick.defaultExpectation.paramPtrs = &AdsServiceMockClickParamPtrs{}
	}
	mmClick.defaultExpectation.paramPtrs.clientID = &clientID
	mmClick.defaultExpectation.expectationOrigins.originClientID = minimock.CallerInfo(1)

	return mmClick
}

// Inspect accepts an inspector function that has same arguments as the AdsService.Click
func (mmClick *mAdsServiceMockClick) Inspect(f func(ctx context.Context, campaignID string, clientID string)) *mAdsServiceMockClick {
	if mmClick.mock.inspectFuncClick != nil {
		mmClick.mock.t.Fatalf("Inspect function is already set for AdsServiceMock.Click")
	}

	mmClick.mock.inspectFuncClick = f

	return mmClick
}

// Return sets up results that will be returned by AdsService.Click
func (mmClick *mAdsServiceMockClick) Return(err error) *AdsServiceMock {
	if mmClick.mock.funcClick != nil {
		mmClick.mock.t.Fatalf("AdsServiceMock.Click mock is already set by Set")
	}

	if mmClick.defaultExpectation == nil {
		mmClick.defaultExpectation = &AdsServiceMockClickExpectation{mock: mmClick.mock}
	}
	mmClick.defaultExpectation.results = &AdsServiceMockClickResults{err}
	mmClick.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmClick.mock
}

// Set uses given function f to mock the AdsService.Click method
func (mmClick *mAdsServiceMockClick) Set(f func(ctx context.Context, campaignID string, clientID string) (err error)) *AdsServiceMock {
	if mmClick.defaultExpectation != nil {
		mmClick.mock.t.Fatalf("Default expectation is already set for the AdsService.Click method")
	}

	if len(mmClick.expectations) > 0 {
		mmClick.mock.t.Fatalf("Some expectations are already set for the AdsService.Click method")
	}

	mmClick.mock.funcClick = f
	mmClick.mock.funcClickOrigin = minimock.CallerInfo(1)
	return mmClick.mock
}

// When sets expectation for the AdsService.Click which will trigger the result defined by the following
// Then helper
func (mmClick *mAdsServiceMockClick) When(ctx context.Context, campaignID string, clientID string) *AdsServiceMockClickExpectation {
	if mmClick.mock.funcClick != nil {
		mmClick.mock.t.Fatalf("AdsServiceMock.Click mock is already set by Set")
	}

	expectation := &AdsServiceMockClickExpectation{
		mock:               mmClick.mock,
		params:             &AdsServiceMockClickParams{ctx, campaignID, clientID},
		expectationOrigins: AdsServiceMockClickExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmClick.expectations = append(mmClick.expectations, expectation)
	return expectation
}

// Then sets up AdsService.Click return parameters for the expectation previously defined by the When method
func (e *AdsServiceMockClickExpectation) Then(err error) *AdsServiceMock {
	e.results = &AdsServiceMockClickResults{err}
	return e.mock
}

// Times sets number of times AdsService.Click should be invoked
func (mmClick *mAdsServiceMockClick) Times(n uint64) *mAdsServiceMockClick {
	if n == 0 {
		mmClick.mock.t.Fatalf("Times of AdsServiceMock.Click mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmClick.expectedInvocations, n)
	mmClick.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmClick
}

func (mmClick *mAdsServiceMockClick) invocationsDone() bool {
	if len(mmClick.expectations) == 0 && mmClick.defaultExpectation == nil && mmClick.mock.funcClick == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmClick.mock.afterClickCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmClick.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Click implements mm_service.AdsService
func (mmClick *AdsServiceMock) Click(ctx context.Context, campaignID string, clientID string) (err error) {
	mm_atomic.AddUint64(&mmClick.beforeClickCounter, 1)
	defer mm_atomic.AddUint64(&mmClick.afterClickCounter, 1)

	mmClick.t.Helper()

	if mmClick.inspectFuncClick != nil {
		mmClick.inspectFuncClick(ctx, campaignID, clientID)
	}

	mm_params := AdsServiceMockClickParams{ctx, campaignID, clientID}

	// Record call args
	mmClick.ClickMock.mutex.Lock()
	mmClick.ClickMock.callArgs = append(mmClick.ClickMock.callArgs, &mm_params)
	mmClick.ClickMock.mutex.Unlock()

	for _, e := range mmClick.ClickMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmClick.ClickMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClick.ClickMock.defaultExpectation.Counter, 1)
		mm_want := mmClick.ClickMock.defaultExpectation.params
		mm_want_ptrs := mmClick.ClickMock.defaultExpectation.paramPtrs

		mm_got := AdsServiceMockClickParams{ctx, campaignID, clientID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmClick.t.Errorf("AdsServiceMock.Click got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmClick.ClickMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.campaignID != nil && !minimock.Equal(*mm_want_ptrs.campaignID, mm_got.campaignID) {
				mmClick.t.Errorf("AdsServiceMock.Click got unexpected parameter campaignID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmClick.ClickMock.defaultExpectation.expectationOrigins.originCampaignID, *mm_want_ptrs.campaignID, mm_got.campaignID, minimock.Diff(*mm_want_ptrs.campaignID, mm_got.campaignID))
			}

			if mm_want_ptrs.clientID != nil && !minimock.Equal(*mm_want_ptrs.clientID, mm_got.clientID) {
				mmClick.t.Errorf("AdsServiceMock.Click got unexpected parameter clientID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmClick.ClickMock.defaultExpectation.expectationOrigins.originClientID, *mm_want_ptrs.clientID, mm_got.clientID, minimock.Diff(*mm_want_ptrs.clientID, mm_got.clientID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmClick.t.Errorf("AdsServiceMock.Click got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmClick.ClickMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmClick.ClickMock.defaultExpectation.results
		if mm_results == nil {
			mmClick.t.Fatal("No results are set for the AdsServiceMock.Click")
		}
		return (*mm_results).err
	}
	if mmClick.funcClick != nil {
		return mmClick.funcClick(ctx, campaignID, clientID)
	}
	mmClick.t.Fatalf("Unexpected call to AdsServiceMock.Click. %v %v %v", ctx, campaignID, clientID)
	return
}

// ClickAfterCounter returns a count of finished AdsServiceMock.Click invocations
func (mmClick *AdsServiceMock) ClickAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClick.afterClickCounter)
}

// ClickBeforeCounter returns a count of AdsServiceMock.Click invocations
func (mmClick *AdsServiceMock) ClickBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClick.beforeClickCounter)
}

// Calls returns a list of arguments used in each call to AdsServiceMock.Click.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmClick *mAdsServiceMockClick) Calls() []*AdsServiceMockClickParams {
	mmClick.mutex.RLock()

	argCopy := make([]*AdsServiceMockClickParams, len(mmClick.callArgs))
	copy(argCopy, mmClick.callArgs)

	mmClick.mutex.RUnlock()

	return argCopy
}

// MinimockClickDone returns true if the count of the Click invocations corresponds
// the number of defined expectations
func (m *AdsServiceMock) MinimockClickDone() bool {
	if m.ClickMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ClickMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ClickMock.invocationsDone()
}

// MinimockClickInspect logs each unmet expectation
func (m *AdsServiceMock) MinimockClickInspect() {
	for _, e := range m.ClickMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AdsServiceMock.Click at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterClickCounter := mm_atomic.LoadUint64(&m.afterClickCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ClickMock.defaultExpectation != nil && afterClickCounter < 1 {
		if m.ClickMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AdsServiceMock.Click at\n%s", m.ClickMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AdsServiceMock.Click at\n%s with params: %#v", m.ClickMock.defaultExpectation.expectationOrigins.origin, *m.ClickMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClick != nil && afterClickCounter < 1 {
		m.t.Errorf("Expected call to AdsServiceMock.Click at\n%s", m.funcClickOrigin)
	}

	if !m.ClickMock.invocationsDone() && afterClickCounter > 0 {
		m.t.Errorf("Expected %d calls to AdsServiceMock.Click at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ClickMock.expectedInvocations), m.ClickMock.expectedInvocationsOrigin, afterClickCounter)
	}
}

type mAdsServiceMockGet struct {
	optional           bool
	mock               *AdsServiceMock
	defaultExpectation *AdsServiceMockGetExpectation
	expectations       []*AdsServiceMockGetExpectation

	callArgs []*AdsServiceMockGetParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AdsServiceMockGetExpectation specifies expectation struct of the AdsService.Get
type AdsServiceMockGetExpectation struct {
	mock               *AdsServiceMock
	params             *AdsServiceMockGetParams
	paramPtrs          *AdsServiceMockGetParamPtrs
	expectationOrigins AdsServiceMockGetExpectationOrigins
	results            *AdsServiceMockGetResults
	returnOrigin       string
	Counter            uint64
}

// AdsServiceMockGetParams contains parameters of the AdsService.Get
type AdsServiceMockGetParams struct {
	ctx      context.Context
	clientID string
}

// AdsServiceMockGetParamPtrs contains pointers to parameters of the AdsService.Get
type AdsServiceMockGetParamPtrs struct {
	ctx      *context.Context
	clientID *string
}

// AdsServiceMockGetResults contains results of the AdsService.Get
type AdsServiceMockGetResults struct {
	cp1 *model.Campaign
	err error
}

// AdsServiceMockGetOrigins contains origins of expectations of the AdsService.Get
type AdsServiceMockGetExpectationOrigins struct {
	origin         string
	originCtx      string
	originClientID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGet *mAdsServiceMockGet) Optional() *mAdsServiceMockGet {
	mmGet.optional = true
	return mmGet
}

// Expect sets up expected params for AdsService.Get
func (mmGet *mAdsServiceMockGet) Expect(ctx context.Context, clientID string) *mAdsServiceMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("AdsServiceMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &AdsServiceMockGetExpectation{}
	}

	if mmGet.defaultExpectation.paramPtrs != nil {
		mmGet.mock.t.Fatalf("AdsServiceMock.Get mock is already set by ExpectParams functions")
	}

	mmGet.defaultExpectation.params = &AdsServiceMockGetParams{ctx, clientID}
	mmGet.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// ExpectCtxParam1 sets up expected param ctx for AdsService.Get
func (mmGet *mAdsServiceMockGet) ExpectCtxParam1(ctx context.Context) *mAdsServiceMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("AdsServiceMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &AdsServiceMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("AdsServiceMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &AdsServiceMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.ctx = &ctx
	mmGet.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGet
}

// ExpectClientIDParam2 sets up expected param clientID for AdsService.Get
func (mmGet *mAdsServiceMockGet) ExpectClientIDParam2(clientID string) *mAdsServiceMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("AdsServiceMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &AdsServiceMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("AdsServiceMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &AdsServiceMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.clientID = &clientID
	mmGet.defaultExpectation.expectationOrigins.originClientID = minimock.CallerInfo(1)

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the AdsService.Get
func (mmGet *mAdsServiceMockGet) Inspect(f func(ctx context.Context, clientID string)) *mAdsServiceMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for AdsServiceMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by AdsService.Get
func (mmGet *mAdsServiceMockGet) Return(cp1 *model.Campaign, err error) *AdsServiceMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("AdsServiceMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &AdsServiceMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &AdsServiceMockGetResults{cp1, err}
	mmGet.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// Set uses given function f to mock the AdsService.Get method
func (mmGet *mAdsServiceMockGet) Set(f func(ctx context.Context, clientID string) (cp1 *model.Campaign, err error)) *AdsServiceMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the AdsService.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the AdsService.Get method")
	}

	mmGet.mock.funcGet = f
	mmGet.mock.funcGetOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// When sets expectation for the AdsService.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mAdsServiceMockGet) When(ctx context.Context, clientID string) *AdsServiceMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("AdsServiceMock.Get mock is already set by Set")
	}

	expectation := &AdsServiceMockGetExpectation{
		mock:               mmGet.mock,
		params:             &AdsServiceMockGetParams{ctx, clientID},
		expectationOrigins: AdsServiceMockGetExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up AdsService.Get return parameters for the expectation previously defined by the When method
func (e *AdsServiceMockGetExpectation) Then(cp1 *model.Campaign, err error) *AdsServiceMock {
	e.results = &AdsServiceMockGetResults{cp1, err}
	return e.mock
}

// Times sets number of times AdsService.Get should be invoked
func (mmGet *mAdsServiceMockGet) Times(n uint64) *mAdsServiceMockGet {
	if n == 0 {
		mmGet.mock.t.Fatalf("Times of AdsServiceMock.Get mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGet.expectedInvocations, n)
	mmGet.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGet
}

func (mmGet *mAdsServiceMockGet) invocationsDone() bool {
	if len(mmGet.expectations) == 0 && mmGet.defaultExpectation == nil && mmGet.mock.funcGet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGet.mock.afterGetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Get implements mm_service.AdsService
func (mmGet *AdsServiceMock) Get(ctx context.Context, clientID string) (cp1 *model.Campaign, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	mmGet.t.Helper()

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(ctx, clientID)
	}

	mm_params := AdsServiceMockGetParams{ctx, clientID}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, &mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_want_ptrs := mmGet.GetMock.defaultExpectation.paramPtrs

		mm_got := AdsServiceMockGetParams{ctx, clientID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGet.t.Errorf("AdsServiceMock.Get got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.clientID != nil && !minimock.Equal(*mm_want_ptrs.clientID, mm_got.clientID) {
				mmGet.t.Errorf("AdsServiceMock.Get got unexpected parameter clientID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originClientID, *mm_want_ptrs.clientID, mm_got.clientID, minimock.Diff(*mm_want_ptrs.clientID, mm_got.clientID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("AdsServiceMock.Get got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGet.GetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the AdsServiceMock.Get")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(ctx, clientID)
	}
	mmGet.t.Fatalf("Unexpected call to AdsServiceMock.Get. %v %v", ctx, clientID)
	return
}

// GetAfterCounter returns a count of finished AdsServiceMock.Get invocations
func (mmGet *AdsServiceMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of AdsServiceMock.Get invocations
func (mmGet *AdsServiceMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to AdsServiceMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mAdsServiceMockGet) Calls() []*AdsServiceMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*AdsServiceMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *AdsServiceMock) MinimockGetDone() bool {
	if m.GetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetMock.invocationsDone()
}

// MinimockGetInspect logs each unmet expectation
func (m *AdsServiceMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AdsServiceMock.Get at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCounter := mm_atomic.LoadUint64(&m.afterGetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && afterGetCounter < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AdsServiceMock.Get at\n%s", m.GetMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AdsServiceMock.Get at\n%s with params: %#v", m.GetMock.defaultExpectation.expectationOrigins.origin, *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && afterGetCounter < 1 {
		m.t.Errorf("Expected call to AdsServiceMock.Get at\n%s", m.funcGetOrigin)
	}

	if !m.GetMock.invocationsDone() && afterGetCounter > 0 {
		m.t.Errorf("Expected %d calls to AdsServiceMock.Get at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetMock.expectedInvocations), m.GetMock.expectedInvocationsOrigin, afterGetCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *AdsServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockClickInspect()

			m.MinimockGetInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *AdsServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *AdsServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockClickDone() &&
		m.MinimockGetDone()
}
