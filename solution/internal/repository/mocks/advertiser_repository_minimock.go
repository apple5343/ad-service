// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i server/internal/repository.AdvertiserRepository -o advertiser_repository_minimock.go -n AdvertiserRepositoryMock -p mocks

import (
	"context"
	"server/internal/model"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// AdvertiserRepositoryMock implements mm_repository.AdvertiserRepository
type AdvertiserRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddScore          func(ctx context.Context, score *model.Score) (err error)
	funcAddScoreOrigin    string
	inspectFuncAddScore   func(ctx context.Context, score *model.Score)
	afterAddScoreCounter  uint64
	beforeAddScoreCounter uint64
	AddScoreMock          mAdvertiserRepositoryMockAddScore

	funcGet          func(ctx context.Context, id string) (ap1 *model.Advertiser, err error)
	funcGetOrigin    string
	inspectFuncGet   func(ctx context.Context, id string)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mAdvertiserRepositoryMockGet

	funcSave          func(ctx context.Context, advertisers []*model.Advertiser) (err error)
	funcSaveOrigin    string
	inspectFuncSave   func(ctx context.Context, advertisers []*model.Advertiser)
	afterSaveCounter  uint64
	beforeSaveCounter uint64
	SaveMock          mAdvertiserRepositoryMockSave
}

// NewAdvertiserRepositoryMock returns a mock for mm_repository.AdvertiserRepository
func NewAdvertiserRepositoryMock(t minimock.Tester) *AdvertiserRepositoryMock {
	m := &AdvertiserRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddScoreMock = mAdvertiserRepositoryMockAddScore{mock: m}
	m.AddScoreMock.callArgs = []*AdvertiserRepositoryMockAddScoreParams{}

	m.GetMock = mAdvertiserRepositoryMockGet{mock: m}
	m.GetMock.callArgs = []*AdvertiserRepositoryMockGetParams{}

	m.SaveMock = mAdvertiserRepositoryMockSave{mock: m}
	m.SaveMock.callArgs = []*AdvertiserRepositoryMockSaveParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mAdvertiserRepositoryMockAddScore struct {
	optional           bool
	mock               *AdvertiserRepositoryMock
	defaultExpectation *AdvertiserRepositoryMockAddScoreExpectation
	expectations       []*AdvertiserRepositoryMockAddScoreExpectation

	callArgs []*AdvertiserRepositoryMockAddScoreParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AdvertiserRepositoryMockAddScoreExpectation specifies expectation struct of the AdvertiserRepository.AddScore
type AdvertiserRepositoryMockAddScoreExpectation struct {
	mock               *AdvertiserRepositoryMock
	params             *AdvertiserRepositoryMockAddScoreParams
	paramPtrs          *AdvertiserRepositoryMockAddScoreParamPtrs
	expectationOrigins AdvertiserRepositoryMockAddScoreExpectationOrigins
	results            *AdvertiserRepositoryMockAddScoreResults
	returnOrigin       string
	Counter            uint64
}

// AdvertiserRepositoryMockAddScoreParams contains parameters of the AdvertiserRepository.AddScore
type AdvertiserRepositoryMockAddScoreParams struct {
	ctx   context.Context
	score *model.Score
}

// AdvertiserRepositoryMockAddScoreParamPtrs contains pointers to parameters of the AdvertiserRepository.AddScore
type AdvertiserRepositoryMockAddScoreParamPtrs struct {
	ctx   *context.Context
	score **model.Score
}

// AdvertiserRepositoryMockAddScoreResults contains results of the AdvertiserRepository.AddScore
type AdvertiserRepositoryMockAddScoreResults struct {
	err error
}

// AdvertiserRepositoryMockAddScoreOrigins contains origins of expectations of the AdvertiserRepository.AddScore
type AdvertiserRepositoryMockAddScoreExpectationOrigins struct {
	origin      string
	originCtx   string
	originScore string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddScore *mAdvertiserRepositoryMockAddScore) Optional() *mAdvertiserRepositoryMockAddScore {
	mmAddScore.optional = true
	return mmAddScore
}

// Expect sets up expected params for AdvertiserRepository.AddScore
func (mmAddScore *mAdvertiserRepositoryMockAddScore) Expect(ctx context.Context, score *model.Score) *mAdvertiserRepositoryMockAddScore {
	if mmAddScore.mock.funcAddScore != nil {
		mmAddScore.mock.t.Fatalf("AdvertiserRepositoryMock.AddScore mock is already set by Set")
	}

	if mmAddScore.defaultExpectation == nil {
		mmAddScore.defaultExpectation = &AdvertiserRepositoryMockAddScoreExpectation{}
	}

	if mmAddScore.defaultExpectation.paramPtrs != nil {
		mmAddScore.mock.t.Fatalf("AdvertiserRepositoryMock.AddScore mock is already set by ExpectParams functions")
	}

	mmAddScore.defaultExpectation.params = &AdvertiserRepositoryMockAddScoreParams{ctx, score}
	mmAddScore.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddScore.expectations {
		if minimock.Equal(e.params, mmAddScore.defaultExpectation.params) {
			mmAddScore.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddScore.defaultExpectation.params)
		}
	}

	return mmAddScore
}

// ExpectCtxParam1 sets up expected param ctx for AdvertiserRepository.AddScore
func (mmAddScore *mAdvertiserRepositoryMockAddScore) ExpectCtxParam1(ctx context.Context) *mAdvertiserRepositoryMockAddScore {
	if mmAddScore.mock.funcAddScore != nil {
		mmAddScore.mock.t.Fatalf("AdvertiserRepositoryMock.AddScore mock is already set by Set")
	}

	if mmAddScore.defaultExpectation == nil {
		mmAddScore.defaultExpectation = &AdvertiserRepositoryMockAddScoreExpectation{}
	}

	if mmAddScore.defaultExpectation.params != nil {
		mmAddScore.mock.t.Fatalf("AdvertiserRepositoryMock.AddScore mock is already set by Expect")
	}

	if mmAddScore.defaultExpectation.paramPtrs == nil {
		mmAddScore.defaultExpectation.paramPtrs = &AdvertiserRepositoryMockAddScoreParamPtrs{}
	}
	mmAddScore.defaultExpectation.paramPtrs.ctx = &ctx
	mmAddScore.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAddScore
}

// ExpectScoreParam2 sets up expected param score for AdvertiserRepository.AddScore
func (mmAddScore *mAdvertiserRepositoryMockAddScore) ExpectScoreParam2(score *model.Score) *mAdvertiserRepositoryMockAddScore {
	if mmAddScore.mock.funcAddScore != nil {
		mmAddScore.mock.t.Fatalf("AdvertiserRepositoryMock.AddScore mock is already set by Set")
	}

	if mmAddScore.defaultExpectation == nil {
		mmAddScore.defaultExpectation = &AdvertiserRepositoryMockAddScoreExpectation{}
	}

	if mmAddScore.defaultExpectation.params != nil {
		mmAddScore.mock.t.Fatalf("AdvertiserRepositoryMock.AddScore mock is already set by Expect")
	}

	if mmAddScore.defaultExpectation.paramPtrs == nil {
		mmAddScore.defaultExpectation.paramPtrs = &AdvertiserRepositoryMockAddScoreParamPtrs{}
	}
	mmAddScore.defaultExpectation.paramPtrs.score = &score
	mmAddScore.defaultExpectation.expectationOrigins.originScore = minimock.CallerInfo(1)

	return mmAddScore
}

// Inspect accepts an inspector function that has same arguments as the AdvertiserRepository.AddScore
func (mmAddScore *mAdvertiserRepositoryMockAddScore) Inspect(f func(ctx context.Context, score *model.Score)) *mAdvertiserRepositoryMockAddScore {
	if mmAddScore.mock.inspectFuncAddScore != nil {
		mmAddScore.mock.t.Fatalf("Inspect function is already set for AdvertiserRepositoryMock.AddScore")
	}

	mmAddScore.mock.inspectFuncAddScore = f

	return mmAddScore
}

// Return sets up results that will be returned by AdvertiserRepository.AddScore
func (mmAddScore *mAdvertiserRepositoryMockAddScore) Return(err error) *AdvertiserRepositoryMock {
	if mmAddScore.mock.funcAddScore != nil {
		mmAddScore.mock.t.Fatalf("AdvertiserRepositoryMock.AddScore mock is already set by Set")
	}

	if mmAddScore.defaultExpectation == nil {
		mmAddScore.defaultExpectation = &AdvertiserRepositoryMockAddScoreExpectation{mock: mmAddScore.mock}
	}
	mmAddScore.defaultExpectation.results = &AdvertiserRepositoryMockAddScoreResults{err}
	mmAddScore.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddScore.mock
}

// Set uses given function f to mock the AdvertiserRepository.AddScore method
func (mmAddScore *mAdvertiserRepositoryMockAddScore) Set(f func(ctx context.Context, score *model.Score) (err error)) *AdvertiserRepositoryMock {
	if mmAddScore.defaultExpectation != nil {
		mmAddScore.mock.t.Fatalf("Default expectation is already set for the AdvertiserRepository.AddScore method")
	}

	if len(mmAddScore.expectations) > 0 {
		mmAddScore.mock.t.Fatalf("Some expectations are already set for the AdvertiserRepository.AddScore method")
	}

	mmAddScore.mock.funcAddScore = f
	mmAddScore.mock.funcAddScoreOrigin = minimock.CallerInfo(1)
	return mmAddScore.mock
}

// When sets expectation for the AdvertiserRepository.AddScore which will trigger the result defined by the following
// Then helper
func (mmAddScore *mAdvertiserRepositoryMockAddScore) When(ctx context.Context, score *model.Score) *AdvertiserRepositoryMockAddScoreExpectation {
	if mmAddScore.mock.funcAddScore != nil {
		mmAddScore.mock.t.Fatalf("AdvertiserRepositoryMock.AddScore mock is already set by Set")
	}

	expectation := &AdvertiserRepositoryMockAddScoreExpectation{
		mock:               mmAddScore.mock,
		params:             &AdvertiserRepositoryMockAddScoreParams{ctx, score},
		expectationOrigins: AdvertiserRepositoryMockAddScoreExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddScore.expectations = append(mmAddScore.expectations, expectation)
	return expectation
}

// Then sets up AdvertiserRepository.AddScore return parameters for the expectation previously defined by the When method
func (e *AdvertiserRepositoryMockAddScoreExpectation) Then(err error) *AdvertiserRepositoryMock {
	e.results = &AdvertiserRepositoryMockAddScoreResults{err}
	return e.mock
}

// Times sets number of times AdvertiserRepository.AddScore should be invoked
func (mmAddScore *mAdvertiserRepositoryMockAddScore) Times(n uint64) *mAdvertiserRepositoryMockAddScore {
	if n == 0 {
		mmAddScore.mock.t.Fatalf("Times of AdvertiserRepositoryMock.AddScore mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddScore.expectedInvocations, n)
	mmAddScore.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddScore
}

func (mmAddScore *mAdvertiserRepositoryMockAddScore) invocationsDone() bool {
	if len(mmAddScore.expectations) == 0 && mmAddScore.defaultExpectation == nil && mmAddScore.mock.funcAddScore == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddScore.mock.afterAddScoreCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddScore.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddScore implements mm_repository.AdvertiserRepository
func (mmAddScore *AdvertiserRepositoryMock) AddScore(ctx context.Context, score *model.Score) (err error) {
	mm_atomic.AddUint64(&mmAddScore.beforeAddScoreCounter, 1)
	defer mm_atomic.AddUint64(&mmAddScore.afterAddScoreCounter, 1)

	mmAddScore.t.Helper()

	if mmAddScore.inspectFuncAddScore != nil {
		mmAddScore.inspectFuncAddScore(ctx, score)
	}

	mm_params := AdvertiserRepositoryMockAddScoreParams{ctx, score}

	// Record call args
	mmAddScore.AddScoreMock.mutex.Lock()
	mmAddScore.AddScoreMock.callArgs = append(mmAddScore.AddScoreMock.callArgs, &mm_params)
	mmAddScore.AddScoreMock.mutex.Unlock()

	for _, e := range mmAddScore.AddScoreMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmAddScore.AddScoreMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddScore.AddScoreMock.defaultExpectation.Counter, 1)
		mm_want := mmAddScore.AddScoreMock.defaultExpectation.params
		mm_want_ptrs := mmAddScore.AddScoreMock.defaultExpectation.paramPtrs

		mm_got := AdvertiserRepositoryMockAddScoreParams{ctx, score}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAddScore.t.Errorf("AdvertiserRepositoryMock.AddScore got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddScore.AddScoreMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.score != nil && !minimock.Equal(*mm_want_ptrs.score, mm_got.score) {
				mmAddScore.t.Errorf("AdvertiserRepositoryMock.AddScore got unexpected parameter score, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddScore.AddScoreMock.defaultExpectation.expectationOrigins.originScore, *mm_want_ptrs.score, mm_got.score, minimock.Diff(*mm_want_ptrs.score, mm_got.score))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddScore.t.Errorf("AdvertiserRepositoryMock.AddScore got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddScore.AddScoreMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddScore.AddScoreMock.defaultExpectation.results
		if mm_results == nil {
			mmAddScore.t.Fatal("No results are set for the AdvertiserRepositoryMock.AddScore")
		}
		return (*mm_results).err
	}
	if mmAddScore.funcAddScore != nil {
		return mmAddScore.funcAddScore(ctx, score)
	}
	mmAddScore.t.Fatalf("Unexpected call to AdvertiserRepositoryMock.AddScore. %v %v", ctx, score)
	return
}

// AddScoreAfterCounter returns a count of finished AdvertiserRepositoryMock.AddScore invocations
func (mmAddScore *AdvertiserRepositoryMock) AddScoreAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddScore.afterAddScoreCounter)
}

// AddScoreBeforeCounter returns a count of AdvertiserRepositoryMock.AddScore invocations
func (mmAddScore *AdvertiserRepositoryMock) AddScoreBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddScore.beforeAddScoreCounter)
}

// Calls returns a list of arguments used in each call to AdvertiserRepositoryMock.AddScore.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddScore *mAdvertiserRepositoryMockAddScore) Calls() []*AdvertiserRepositoryMockAddScoreParams {
	mmAddScore.mutex.RLock()

	argCopy := make([]*AdvertiserRepositoryMockAddScoreParams, len(mmAddScore.callArgs))
	copy(argCopy, mmAddScore.callArgs)

	mmAddScore.mutex.RUnlock()

	return argCopy
}

// MinimockAddScoreDone returns true if the count of the AddScore invocations corresponds
// the number of defined expectations
func (m *AdvertiserRepositoryMock) MinimockAddScoreDone() bool {
	if m.AddScoreMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddScoreMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddScoreMock.invocationsDone()
}

// MinimockAddScoreInspect logs each unmet expectation
func (m *AdvertiserRepositoryMock) MinimockAddScoreInspect() {
	for _, e := range m.AddScoreMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AdvertiserRepositoryMock.AddScore at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddScoreCounter := mm_atomic.LoadUint64(&m.afterAddScoreCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddScoreMock.defaultExpectation != nil && afterAddScoreCounter < 1 {
		if m.AddScoreMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AdvertiserRepositoryMock.AddScore at\n%s", m.AddScoreMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AdvertiserRepositoryMock.AddScore at\n%s with params: %#v", m.AddScoreMock.defaultExpectation.expectationOrigins.origin, *m.AddScoreMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddScore != nil && afterAddScoreCounter < 1 {
		m.t.Errorf("Expected call to AdvertiserRepositoryMock.AddScore at\n%s", m.funcAddScoreOrigin)
	}

	if !m.AddScoreMock.invocationsDone() && afterAddScoreCounter > 0 {
		m.t.Errorf("Expected %d calls to AdvertiserRepositoryMock.AddScore at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddScoreMock.expectedInvocations), m.AddScoreMock.expectedInvocationsOrigin, afterAddScoreCounter)
	}
}

type mAdvertiserRepositoryMockGet struct {
	optional           bool
	mock               *AdvertiserRepositoryMock
	defaultExpectation *AdvertiserRepositoryMockGetExpectation
	expectations       []*AdvertiserRepositoryMockGetExpectation

	callArgs []*AdvertiserRepositoryMockGetParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AdvertiserRepositoryMockGetExpectation specifies expectation struct of the AdvertiserRepository.Get
type AdvertiserRepositoryMockGetExpectation struct {
	mock               *AdvertiserRepositoryMock
	params             *AdvertiserRepositoryMockGetParams
	paramPtrs          *AdvertiserRepositoryMockGetParamPtrs
	expectationOrigins AdvertiserRepositoryMockGetExpectationOrigins
	results            *AdvertiserRepositoryMockGetResults
	returnOrigin       string
	Counter            uint64
}

// AdvertiserRepositoryMockGetParams contains parameters of the AdvertiserRepository.Get
type AdvertiserRepositoryMockGetParams struct {
	ctx context.Context
	id  string
}

// AdvertiserRepositoryMockGetParamPtrs contains pointers to parameters of the AdvertiserRepository.Get
type AdvertiserRepositoryMockGetParamPtrs struct {
	ctx *context.Context
	id  *string
}

// AdvertiserRepositoryMockGetResults contains results of the AdvertiserRepository.Get
type AdvertiserRepositoryMockGetResults struct {
	ap1 *model.Advertiser
	err error
}

// AdvertiserRepositoryMockGetOrigins contains origins of expectations of the AdvertiserRepository.Get
type AdvertiserRepositoryMockGetExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGet *mAdvertiserRepositoryMockGet) Optional() *mAdvertiserRepositoryMockGet {
	mmGet.optional = true
	return mmGet
}

// Expect sets up expected params for AdvertiserRepository.Get
func (mmGet *mAdvertiserRepositoryMockGet) Expect(ctx context.Context, id string) *mAdvertiserRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("AdvertiserRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &AdvertiserRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.paramPtrs != nil {
		mmGet.mock.t.Fatalf("AdvertiserRepositoryMock.Get mock is already set by ExpectParams functions")
	}

	mmGet.defaultExpectation.params = &AdvertiserRepositoryMockGetParams{ctx, id}
	mmGet.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// ExpectCtxParam1 sets up expected param ctx for AdvertiserRepository.Get
func (mmGet *mAdvertiserRepositoryMockGet) ExpectCtxParam1(ctx context.Context) *mAdvertiserRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("AdvertiserRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &AdvertiserRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("AdvertiserRepositoryMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &AdvertiserRepositoryMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.ctx = &ctx
	mmGet.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGet
}

// ExpectIdParam2 sets up expected param id for AdvertiserRepository.Get
func (mmGet *mAdvertiserRepositoryMockGet) ExpectIdParam2(id string) *mAdvertiserRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("AdvertiserRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &AdvertiserRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("AdvertiserRepositoryMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &AdvertiserRepositoryMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.id = &id
	mmGet.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the AdvertiserRepository.Get
func (mmGet *mAdvertiserRepositoryMockGet) Inspect(f func(ctx context.Context, id string)) *mAdvertiserRepositoryMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for AdvertiserRepositoryMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by AdvertiserRepository.Get
func (mmGet *mAdvertiserRepositoryMockGet) Return(ap1 *model.Advertiser, err error) *AdvertiserRepositoryMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("AdvertiserRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &AdvertiserRepositoryMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &AdvertiserRepositoryMockGetResults{ap1, err}
	mmGet.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// Set uses given function f to mock the AdvertiserRepository.Get method
func (mmGet *mAdvertiserRepositoryMockGet) Set(f func(ctx context.Context, id string) (ap1 *model.Advertiser, err error)) *AdvertiserRepositoryMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the AdvertiserRepository.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the AdvertiserRepository.Get method")
	}

	mmGet.mock.funcGet = f
	mmGet.mock.funcGetOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// When sets expectation for the AdvertiserRepository.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mAdvertiserRepositoryMockGet) When(ctx context.Context, id string) *AdvertiserRepositoryMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("AdvertiserRepositoryMock.Get mock is already set by Set")
	}

	expectation := &AdvertiserRepositoryMockGetExpectation{
		mock:               mmGet.mock,
		params:             &AdvertiserRepositoryMockGetParams{ctx, id},
		expectationOrigins: AdvertiserRepositoryMockGetExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up AdvertiserRepository.Get return parameters for the expectation previously defined by the When method
func (e *AdvertiserRepositoryMockGetExpectation) Then(ap1 *model.Advertiser, err error) *AdvertiserRepositoryMock {
	e.results = &AdvertiserRepositoryMockGetResults{ap1, err}
	return e.mock
}

// Times sets number of times AdvertiserRepository.Get should be invoked
func (mmGet *mAdvertiserRepositoryMockGet) Times(n uint64) *mAdvertiserRepositoryMockGet {
	if n == 0 {
		mmGet.mock.t.Fatalf("Times of AdvertiserRepositoryMock.Get mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGet.expectedInvocations, n)
	mmGet.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGet
}

func (mmGet *mAdvertiserRepositoryMockGet) invocationsDone() bool {
	if len(mmGet.expectations) == 0 && mmGet.defaultExpectation == nil && mmGet.mock.funcGet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGet.mock.afterGetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Get implements mm_repository.AdvertiserRepository
func (mmGet *AdvertiserRepositoryMock) Get(ctx context.Context, id string) (ap1 *model.Advertiser, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	mmGet.t.Helper()

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(ctx, id)
	}

	mm_params := AdvertiserRepositoryMockGetParams{ctx, id}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, &mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ap1, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_want_ptrs := mmGet.GetMock.defaultExpectation.paramPtrs

		mm_got := AdvertiserRepositoryMockGetParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGet.t.Errorf("AdvertiserRepositoryMock.Get got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGet.t.Errorf("AdvertiserRepositoryMock.Get got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("AdvertiserRepositoryMock.Get got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGet.GetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the AdvertiserRepositoryMock.Get")
		}
		return (*mm_results).ap1, (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(ctx, id)
	}
	mmGet.t.Fatalf("Unexpected call to AdvertiserRepositoryMock.Get. %v %v", ctx, id)
	return
}

// GetAfterCounter returns a count of finished AdvertiserRepositoryMock.Get invocations
func (mmGet *AdvertiserRepositoryMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of AdvertiserRepositoryMock.Get invocations
func (mmGet *AdvertiserRepositoryMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to AdvertiserRepositoryMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mAdvertiserRepositoryMockGet) Calls() []*AdvertiserRepositoryMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*AdvertiserRepositoryMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *AdvertiserRepositoryMock) MinimockGetDone() bool {
	if m.GetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetMock.invocationsDone()
}

// MinimockGetInspect logs each unmet expectation
func (m *AdvertiserRepositoryMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AdvertiserRepositoryMock.Get at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCounter := mm_atomic.LoadUint64(&m.afterGetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && afterGetCounter < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AdvertiserRepositoryMock.Get at\n%s", m.GetMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AdvertiserRepositoryMock.Get at\n%s with params: %#v", m.GetMock.defaultExpectation.expectationOrigins.origin, *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && afterGetCounter < 1 {
		m.t.Errorf("Expected call to AdvertiserRepositoryMock.Get at\n%s", m.funcGetOrigin)
	}

	if !m.GetMock.invocationsDone() && afterGetCounter > 0 {
		m.t.Errorf("Expected %d calls to AdvertiserRepositoryMock.Get at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetMock.expectedInvocations), m.GetMock.expectedInvocationsOrigin, afterGetCounter)
	}
}

type mAdvertiserRepositoryMockSave struct {
	optional           bool
	mock               *AdvertiserRepositoryMock
	defaultExpectation *AdvertiserRepositoryMockSaveExpectation
	expectations       []*AdvertiserRepositoryMockSaveExpectation

	callArgs []*AdvertiserRepositoryMockSaveParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AdvertiserRepositoryMockSaveExpectation specifies expectation struct of the AdvertiserRepository.Save
type AdvertiserRepositoryMockSaveExpectation struct {
	mock               *AdvertiserRepositoryMock
	params             *AdvertiserRepositoryMockSaveParams
	paramPtrs          *AdvertiserRepositoryMockSaveParamPtrs
	expectationOrigins AdvertiserRepositoryMockSaveExpectationOrigins
	results            *AdvertiserRepositoryMockSaveResults
	returnOrigin       string
	Counter            uint64
}

// AdvertiserRepositoryMockSaveParams contains parameters of the AdvertiserRepository.Save
type AdvertiserRepositoryMockSaveParams struct {
	ctx         context.Context
	advertisers []*model.Advertiser
}

// AdvertiserRepositoryMockSaveParamPtrs contains pointers to parameters of the AdvertiserRepository.Save
type AdvertiserRepositoryMockSaveParamPtrs struct {
	ctx         *context.Context
	advertisers *[]*model.Advertiser
}

// AdvertiserRepositoryMockSaveResults contains results of the AdvertiserRepository.Save
type AdvertiserRepositoryMockSaveResults struct {
	err error
}

// AdvertiserRepositoryMockSaveOrigins contains origins of expectations of the AdvertiserRepository.Save
type AdvertiserRepositoryMockSaveExpectationOrigins struct {
	origin            string
	originCtx         string
	originAdvertisers string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSave *mAdvertiserRepositoryMockSave) Optional() *mAdvertiserRepositoryMockSave {
	mmSave.optional = true
	return mmSave
}

// Expect sets up expected params for AdvertiserRepository.Save
func (mmSave *mAdvertiserRepositoryMockSave) Expect(ctx context.Context, advertisers []*model.Advertiser) *mAdvertiserRepositoryMockSave {
	if mmSave.mock.funcSave != nil {
		mmSave.mock.t.Fatalf("AdvertiserRepositoryMock.Save mock is already set by Set")
	}

	if mmSave.defaultExpectation == nil {
		mmSave.defaultExpectation = &AdvertiserRepositoryMockSaveExpectation{}
	}

	if mmSave.defaultExpectation.paramPtrs != nil {
		mmSave.mock.t.Fatalf("AdvertiserRepositoryMock.Save mock is already set by ExpectParams functions")
	}

	mmSave.defaultExpectation.params = &AdvertiserRepositoryMockSaveParams{ctx, advertisers}
	mmSave.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSave.expectations {
		if minimock.Equal(e.params, mmSave.defaultExpectation.params) {
			mmSave.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSave.defaultExpectation.params)
		}
	}

	return mmSave
}

// ExpectCtxParam1 sets up expected param ctx for AdvertiserRepository.Save
func (mmSave *mAdvertiserRepositoryMockSave) ExpectCtxParam1(ctx context.Context) *mAdvertiserRepositoryMockSave {
	if mmSave.mock.funcSave != nil {
		mmSave.mock.t.Fatalf("AdvertiserRepositoryMock.Save mock is already set by Set")
	}

	if mmSave.defaultExpectation == nil {
		mmSave.defaultExpectation = &AdvertiserRepositoryMockSaveExpectation{}
	}

	if mmSave.defaultExpectation.params != nil {
		mmSave.mock.t.Fatalf("AdvertiserRepositoryMock.Save mock is already set by Expect")
	}

	if mmSave.defaultExpectation.paramPtrs == nil {
		mmSave.defaultExpectation.paramPtrs = &AdvertiserRepositoryMockSaveParamPtrs{}
	}
	mmSave.defaultExpectation.paramPtrs.ctx = &ctx
	mmSave.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSave
}

// ExpectAdvertisersParam2 sets up expected param advertisers for AdvertiserRepository.Save
func (mmSave *mAdvertiserRepositoryMockSave) ExpectAdvertisersParam2(advertisers []*model.Advertiser) *mAdvertiserRepositoryMockSave {
	if mmSave.mock.funcSave != nil {
		mmSave.mock.t.Fatalf("AdvertiserRepositoryMock.Save mock is already set by Set")
	}

	if mmSave.defaultExpectation == nil {
		mmSave.defaultExpectation = &AdvertiserRepositoryMockSaveExpectation{}
	}

	if mmSave.defaultExpectation.params != nil {
		mmSave.mock.t.Fatalf("AdvertiserRepositoryMock.Save mock is already set by Expect")
	}

	if mmSave.defaultExpectation.paramPtrs == nil {
		mmSave.defaultExpectation.paramPtrs = &AdvertiserRepositoryMockSaveParamPtrs{}
	}
	mmSave.defaultExpectation.paramPtrs.advertisers = &advertisers
	mmSave.defaultExpectation.expectationOrigins.originAdvertisers = minimock.CallerInfo(1)

	return mmSave
}

// Inspect accepts an inspector function that has same arguments as the AdvertiserRepository.Save
func (mmSave *mAdvertiserRepositoryMockSave) Inspect(f func(ctx context.Context, advertisers []*model.Advertiser)) *mAdvertiserRepositoryMockSave {
	if mmSave.mock.inspectFuncSave != nil {
		mmSave.mock.t.Fatalf("Inspect function is already set for AdvertiserRepositoryMock.Save")
	}

	mmSave.mock.inspectFuncSave = f

	return mmSave
}

// Return sets up results that will be returned by AdvertiserRepository.Save
func (mmSave *mAdvertiserRepositoryMockSave) Return(err error) *AdvertiserRepositoryMock {
	if mmSave.mock.funcSave != nil {
		mmSave.mock.t.Fatalf("AdvertiserRepositoryMock.Save mock is already set by Set")
	}

	if mmSave.defaultExpectation == nil {
		mmSave.defaultExpectation = &AdvertiserRepositoryMockSaveExpectation{mock: mmSave.mock}
	}
	mmSave.defaultExpectation.results = &AdvertiserRepositoryMockSaveResults{err}
	mmSave.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSave.mock
}

// Set uses given function f to mock the AdvertiserRepository.Save method
func (mmSave *mAdvertiserRepositoryMockSave) Set(f func(ctx context.Context, advertisers []*model.Advertiser) (err error)) *AdvertiserRepositoryMock {
	if mmSave.defaultExpectation != nil {
		mmSave.mock.t.Fatalf("Default expectation is already set for the AdvertiserRepository.Save method")
	}

	if len(mmSave.expectations) > 0 {
		mmSave.mock.t.Fatalf("Some expectations are already set for the AdvertiserRepository.Save method")
	}

	mmSave.mock.funcSave = f
	mmSave.mock.funcSaveOrigin = minimock.CallerInfo(1)
	return mmSave.mock
}

// When sets expectation for the AdvertiserRepository.Save which will trigger the result defined by the following
// Then helper
func (mmSave *mAdvertiserRepositoryMockSave) When(ctx context.Context, advertisers []*model.Advertiser) *AdvertiserRepositoryMockSaveExpectation {
	if mmSave.mock.funcSave != nil {
		mmSave.mock.t.Fatalf("AdvertiserRepositoryMock.Save mock is already set by Set")
	}

	expectation := &AdvertiserRepositoryMockSaveExpectation{
		mock:               mmSave.mock,
		params:             &AdvertiserRepositoryMockSaveParams{ctx, advertisers},
		expectationOrigins: AdvertiserRepositoryMockSaveExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSave.expectations = append(mmSave.expectations, expectation)
	return expectation
}

// Then sets up AdvertiserRepository.Save return parameters for the expectation previously defined by the When method
func (e *AdvertiserRepositoryMockSaveExpectation) Then(err error) *AdvertiserRepositoryMock {
	e.results = &AdvertiserRepositoryMockSaveResults{err}
	return e.mock
}

// Times sets number of times AdvertiserRepository.Save should be invoked
func (mmSave *mAdvertiserRepositoryMockSave) Times(n uint64) *mAdvertiserRepositoryMockSave {
	if n == 0 {
		mmSave.mock.t.Fatalf("Times of AdvertiserRepositoryMock.Save mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSave.expectedInvocations, n)
	mmSave.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSave
}

func (mmSave *mAdvertiserRepositoryMockSave) invocationsDone() bool {
	if len(mmSave.expectations) == 0 && mmSave.defaultExpectation == nil && mmSave.mock.funcSave == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSave.mock.afterSaveCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSave.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Save implements mm_repository.AdvertiserRepository
func (mmSave *AdvertiserRepositoryMock) Save(ctx context.Context, advertisers []*model.Advertiser) (err error) {
	mm_atomic.AddUint64(&mmSave.beforeSaveCounter, 1)
	defer mm_atomic.AddUint64(&mmSave.afterSaveCounter, 1)

	mmSave.t.Helper()

	if mmSave.inspectFuncSave != nil {
		mmSave.inspectFuncSave(ctx, advertisers)
	}

	mm_params := AdvertiserRepositoryMockSaveParams{ctx, advertisers}

	// Record call args
	mmSave.SaveMock.mutex.Lock()
	mmSave.SaveMock.callArgs = append(mmSave.SaveMock.callArgs, &mm_params)
	mmSave.SaveMock.mutex.Unlock()

	for _, e := range mmSave.SaveMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSave.SaveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSave.SaveMock.defaultExpectation.Counter, 1)
		mm_want := mmSave.SaveMock.defaultExpectation.params
		mm_want_ptrs := mmSave.SaveMock.defaultExpectation.paramPtrs

		mm_got := AdvertiserRepositoryMockSaveParams{ctx, advertisers}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSave.t.Errorf("AdvertiserRepositoryMock.Save got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSave.SaveMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.advertisers != nil && !minimock.Equal(*mm_want_ptrs.advertisers, mm_got.advertisers) {
				mmSave.t.Errorf("AdvertiserRepositoryMock.Save got unexpected parameter advertisers, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSave.SaveMock.defaultExpectation.expectationOrigins.originAdvertisers, *mm_want_ptrs.advertisers, mm_got.advertisers, minimock.Diff(*mm_want_ptrs.advertisers, mm_got.advertisers))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSave.t.Errorf("AdvertiserRepositoryMock.Save got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSave.SaveMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSave.SaveMock.defaultExpectation.results
		if mm_results == nil {
			mmSave.t.Fatal("No results are set for the AdvertiserRepositoryMock.Save")
		}
		return (*mm_results).err
	}
	if mmSave.funcSave != nil {
		return mmSave.funcSave(ctx, advertisers)
	}
	mmSave.t.Fatalf("Unexpected call to AdvertiserRepositoryMock.Save. %v %v", ctx, advertisers)
	return
}

// SaveAfterCounter returns a count of finished AdvertiserRepositoryMock.Save invocations
func (mmSave *AdvertiserRepositoryMock) SaveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSave.afterSaveCounter)
}

// SaveBeforeCounter returns a count of AdvertiserRepositoryMock.Save invocations
func (mmSave *AdvertiserRepositoryMock) SaveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSave.beforeSaveCounter)
}

// Calls returns a list of arguments used in each call to AdvertiserRepositoryMock.Save.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSave *mAdvertiserRepositoryMockSave) Calls() []*AdvertiserRepositoryMockSaveParams {
	mmSave.mutex.RLock()

	argCopy := make([]*AdvertiserRepositoryMockSaveParams, len(mmSave.callArgs))
	copy(argCopy, mmSave.callArgs)

	mmSave.mutex.RUnlock()

	return argCopy
}

// MinimockSaveDone returns true if the count of the Save invocations corresponds
// the number of defined expectations
func (m *AdvertiserRepositoryMock) MinimockSaveDone() bool {
	if m.SaveMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SaveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SaveMock.invocationsDone()
}

// MinimockSaveInspect logs each unmet expectation
func (m *AdvertiserRepositoryMock) MinimockSaveInspect() {
	for _, e := range m.SaveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AdvertiserRepositoryMock.Save at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSaveCounter := mm_atomic.LoadUint64(&m.afterSaveCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SaveMock.defaultExpectation != nil && afterSaveCounter < 1 {
		if m.SaveMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AdvertiserRepositoryMock.Save at\n%s", m.SaveMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AdvertiserRepositoryMock.Save at\n%s with params: %#v", m.SaveMock.defaultExpectation.expectationOrigins.origin, *m.SaveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSave != nil && afterSaveCounter < 1 {
		m.t.Errorf("Expected call to AdvertiserRepositoryMock.Save at\n%s", m.funcSaveOrigin)
	}

	if !m.SaveMock.invocationsDone() && afterSaveCounter > 0 {
		m.t.Errorf("Expected %d calls to AdvertiserRepositoryMock.Save at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SaveMock.expectedInvocations), m.SaveMock.expectedInvocationsOrigin, afterSaveCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *AdvertiserRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddScoreInspect()

			m.MinimockGetInspect()

			m.MinimockSaveInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *AdvertiserRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *AdvertiserRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddScoreDone() &&
		m.MinimockGetDone() &&
		m.MinimockSaveDone()
}
