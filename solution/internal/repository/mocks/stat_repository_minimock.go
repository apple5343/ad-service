// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i server/internal/repository.StatRepository -o stat_repository_minimock.go -n StatRepositoryMock -p mocks

import (
	"context"
	"server/internal/model"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// StatRepositoryMock implements mm_repository.StatRepository
type StatRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetByAdvertiser          func(ctx context.Context, advertiserID string) (sp1 *model.Stat, err error)
	funcGetByAdvertiserOrigin    string
	inspectFuncGetByAdvertiser   func(ctx context.Context, advertiserID string)
	afterGetByAdvertiserCounter  uint64
	beforeGetByAdvertiserCounter uint64
	GetByAdvertiserMock          mStatRepositoryMockGetByAdvertiser

	funcGetByAdvertiserDaily          func(ctx context.Context, advertiserID string) (sp1 *model.Stat, err error)
	funcGetByAdvertiserDailyOrigin    string
	inspectFuncGetByAdvertiserDaily   func(ctx context.Context, advertiserID string)
	afterGetByAdvertiserDailyCounter  uint64
	beforeGetByAdvertiserDailyCounter uint64
	GetByAdvertiserDailyMock          mStatRepositoryMockGetByAdvertiserDaily

	funcGetByCampaign          func(ctx context.Context, campaignID string) (sp1 *model.Stat, err error)
	funcGetByCampaignOrigin    string
	inspectFuncGetByCampaign   func(ctx context.Context, campaignID string)
	afterGetByCampaignCounter  uint64
	beforeGetByCampaignCounter uint64
	GetByCampaignMock          mStatRepositoryMockGetByCampaign

	funcGetByCampaignDaily          func(ctx context.Context, campaignID string) (sp1 *model.Stat, err error)
	funcGetByCampaignDailyOrigin    string
	inspectFuncGetByCampaignDaily   func(ctx context.Context, campaignID string)
	afterGetByCampaignDailyCounter  uint64
	beforeGetByCampaignDailyCounter uint64
	GetByCampaignDailyMock          mStatRepositoryMockGetByCampaignDaily
}

// NewStatRepositoryMock returns a mock for mm_repository.StatRepository
func NewStatRepositoryMock(t minimock.Tester) *StatRepositoryMock {
	m := &StatRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetByAdvertiserMock = mStatRepositoryMockGetByAdvertiser{mock: m}
	m.GetByAdvertiserMock.callArgs = []*StatRepositoryMockGetByAdvertiserParams{}

	m.GetByAdvertiserDailyMock = mStatRepositoryMockGetByAdvertiserDaily{mock: m}
	m.GetByAdvertiserDailyMock.callArgs = []*StatRepositoryMockGetByAdvertiserDailyParams{}

	m.GetByCampaignMock = mStatRepositoryMockGetByCampaign{mock: m}
	m.GetByCampaignMock.callArgs = []*StatRepositoryMockGetByCampaignParams{}

	m.GetByCampaignDailyMock = mStatRepositoryMockGetByCampaignDaily{mock: m}
	m.GetByCampaignDailyMock.callArgs = []*StatRepositoryMockGetByCampaignDailyParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mStatRepositoryMockGetByAdvertiser struct {
	optional           bool
	mock               *StatRepositoryMock
	defaultExpectation *StatRepositoryMockGetByAdvertiserExpectation
	expectations       []*StatRepositoryMockGetByAdvertiserExpectation

	callArgs []*StatRepositoryMockGetByAdvertiserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StatRepositoryMockGetByAdvertiserExpectation specifies expectation struct of the StatRepository.GetByAdvertiser
type StatRepositoryMockGetByAdvertiserExpectation struct {
	mock               *StatRepositoryMock
	params             *StatRepositoryMockGetByAdvertiserParams
	paramPtrs          *StatRepositoryMockGetByAdvertiserParamPtrs
	expectationOrigins StatRepositoryMockGetByAdvertiserExpectationOrigins
	results            *StatRepositoryMockGetByAdvertiserResults
	returnOrigin       string
	Counter            uint64
}

// StatRepositoryMockGetByAdvertiserParams contains parameters of the StatRepository.GetByAdvertiser
type StatRepositoryMockGetByAdvertiserParams struct {
	ctx          context.Context
	advertiserID string
}

// StatRepositoryMockGetByAdvertiserParamPtrs contains pointers to parameters of the StatRepository.GetByAdvertiser
type StatRepositoryMockGetByAdvertiserParamPtrs struct {
	ctx          *context.Context
	advertiserID *string
}

// StatRepositoryMockGetByAdvertiserResults contains results of the StatRepository.GetByAdvertiser
type StatRepositoryMockGetByAdvertiserResults struct {
	sp1 *model.Stat
	err error
}

// StatRepositoryMockGetByAdvertiserOrigins contains origins of expectations of the StatRepository.GetByAdvertiser
type StatRepositoryMockGetByAdvertiserExpectationOrigins struct {
	origin             string
	originCtx          string
	originAdvertiserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetByAdvertiser *mStatRepositoryMockGetByAdvertiser) Optional() *mStatRepositoryMockGetByAdvertiser {
	mmGetByAdvertiser.optional = true
	return mmGetByAdvertiser
}

// Expect sets up expected params for StatRepository.GetByAdvertiser
func (mmGetByAdvertiser *mStatRepositoryMockGetByAdvertiser) Expect(ctx context.Context, advertiserID string) *mStatRepositoryMockGetByAdvertiser {
	if mmGetByAdvertiser.mock.funcGetByAdvertiser != nil {
		mmGetByAdvertiser.mock.t.Fatalf("StatRepositoryMock.GetByAdvertiser mock is already set by Set")
	}

	if mmGetByAdvertiser.defaultExpectation == nil {
		mmGetByAdvertiser.defaultExpectation = &StatRepositoryMockGetByAdvertiserExpectation{}
	}

	if mmGetByAdvertiser.defaultExpectation.paramPtrs != nil {
		mmGetByAdvertiser.mock.t.Fatalf("StatRepositoryMock.GetByAdvertiser mock is already set by ExpectParams functions")
	}

	mmGetByAdvertiser.defaultExpectation.params = &StatRepositoryMockGetByAdvertiserParams{ctx, advertiserID}
	mmGetByAdvertiser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetByAdvertiser.expectations {
		if minimock.Equal(e.params, mmGetByAdvertiser.defaultExpectation.params) {
			mmGetByAdvertiser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetByAdvertiser.defaultExpectation.params)
		}
	}

	return mmGetByAdvertiser
}

// ExpectCtxParam1 sets up expected param ctx for StatRepository.GetByAdvertiser
func (mmGetByAdvertiser *mStatRepositoryMockGetByAdvertiser) ExpectCtxParam1(ctx context.Context) *mStatRepositoryMockGetByAdvertiser {
	if mmGetByAdvertiser.mock.funcGetByAdvertiser != nil {
		mmGetByAdvertiser.mock.t.Fatalf("StatRepositoryMock.GetByAdvertiser mock is already set by Set")
	}

	if mmGetByAdvertiser.defaultExpectation == nil {
		mmGetByAdvertiser.defaultExpectation = &StatRepositoryMockGetByAdvertiserExpectation{}
	}

	if mmGetByAdvertiser.defaultExpectation.params != nil {
		mmGetByAdvertiser.mock.t.Fatalf("StatRepositoryMock.GetByAdvertiser mock is already set by Expect")
	}

	if mmGetByAdvertiser.defaultExpectation.paramPtrs == nil {
		mmGetByAdvertiser.defaultExpectation.paramPtrs = &StatRepositoryMockGetByAdvertiserParamPtrs{}
	}
	mmGetByAdvertiser.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetByAdvertiser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetByAdvertiser
}

// ExpectAdvertiserIDParam2 sets up expected param advertiserID for StatRepository.GetByAdvertiser
func (mmGetByAdvertiser *mStatRepositoryMockGetByAdvertiser) ExpectAdvertiserIDParam2(advertiserID string) *mStatRepositoryMockGetByAdvertiser {
	if mmGetByAdvertiser.mock.funcGetByAdvertiser != nil {
		mmGetByAdvertiser.mock.t.Fatalf("StatRepositoryMock.GetByAdvertiser mock is already set by Set")
	}

	if mmGetByAdvertiser.defaultExpectation == nil {
		mmGetByAdvertiser.defaultExpectation = &StatRepositoryMockGetByAdvertiserExpectation{}
	}

	if mmGetByAdvertiser.defaultExpectation.params != nil {
		mmGetByAdvertiser.mock.t.Fatalf("StatRepositoryMock.GetByAdvertiser mock is already set by Expect")
	}

	if mmGetByAdvertiser.defaultExpectation.paramPtrs == nil {
		mmGetByAdvertiser.defaultExpectation.paramPtrs = &StatRepositoryMockGetByAdvertiserParamPtrs{}
	}
	mmGetByAdvertiser.defaultExpectation.paramPtrs.advertiserID = &advertiserID
	mmGetByAdvertiser.defaultExpectation.expectationOrigins.originAdvertiserID = minimock.CallerInfo(1)

	return mmGetByAdvertiser
}

// Inspect accepts an inspector function that has same arguments as the StatRepository.GetByAdvertiser
func (mmGetByAdvertiser *mStatRepositoryMockGetByAdvertiser) Inspect(f func(ctx context.Context, advertiserID string)) *mStatRepositoryMockGetByAdvertiser {
	if mmGetByAdvertiser.mock.inspectFuncGetByAdvertiser != nil {
		mmGetByAdvertiser.mock.t.Fatalf("Inspect function is already set for StatRepositoryMock.GetByAdvertiser")
	}

	mmGetByAdvertiser.mock.inspectFuncGetByAdvertiser = f

	return mmGetByAdvertiser
}

// Return sets up results that will be returned by StatRepository.GetByAdvertiser
func (mmGetByAdvertiser *mStatRepositoryMockGetByAdvertiser) Return(sp1 *model.Stat, err error) *StatRepositoryMock {
	if mmGetByAdvertiser.mock.funcGetByAdvertiser != nil {
		mmGetByAdvertiser.mock.t.Fatalf("StatRepositoryMock.GetByAdvertiser mock is already set by Set")
	}

	if mmGetByAdvertiser.defaultExpectation == nil {
		mmGetByAdvertiser.defaultExpectation = &StatRepositoryMockGetByAdvertiserExpectation{mock: mmGetByAdvertiser.mock}
	}
	mmGetByAdvertiser.defaultExpectation.results = &StatRepositoryMockGetByAdvertiserResults{sp1, err}
	mmGetByAdvertiser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetByAdvertiser.mock
}

// Set uses given function f to mock the StatRepository.GetByAdvertiser method
func (mmGetByAdvertiser *mStatRepositoryMockGetByAdvertiser) Set(f func(ctx context.Context, advertiserID string) (sp1 *model.Stat, err error)) *StatRepositoryMock {
	if mmGetByAdvertiser.defaultExpectation != nil {
		mmGetByAdvertiser.mock.t.Fatalf("Default expectation is already set for the StatRepository.GetByAdvertiser method")
	}

	if len(mmGetByAdvertiser.expectations) > 0 {
		mmGetByAdvertiser.mock.t.Fatalf("Some expectations are already set for the StatRepository.GetByAdvertiser method")
	}

	mmGetByAdvertiser.mock.funcGetByAdvertiser = f
	mmGetByAdvertiser.mock.funcGetByAdvertiserOrigin = minimock.CallerInfo(1)
	return mmGetByAdvertiser.mock
}

// When sets expectation for the StatRepository.GetByAdvertiser which will trigger the result defined by the following
// Then helper
func (mmGetByAdvertiser *mStatRepositoryMockGetByAdvertiser) When(ctx context.Context, advertiserID string) *StatRepositoryMockGetByAdvertiserExpectation {
	if mmGetByAdvertiser.mock.funcGetByAdvertiser != nil {
		mmGetByAdvertiser.mock.t.Fatalf("StatRepositoryMock.GetByAdvertiser mock is already set by Set")
	}

	expectation := &StatRepositoryMockGetByAdvertiserExpectation{
		mock:               mmGetByAdvertiser.mock,
		params:             &StatRepositoryMockGetByAdvertiserParams{ctx, advertiserID},
		expectationOrigins: StatRepositoryMockGetByAdvertiserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetByAdvertiser.expectations = append(mmGetByAdvertiser.expectations, expectation)
	return expectation
}

// Then sets up StatRepository.GetByAdvertiser return parameters for the expectation previously defined by the When method
func (e *StatRepositoryMockGetByAdvertiserExpectation) Then(sp1 *model.Stat, err error) *StatRepositoryMock {
	e.results = &StatRepositoryMockGetByAdvertiserResults{sp1, err}
	return e.mock
}

// Times sets number of times StatRepository.GetByAdvertiser should be invoked
func (mmGetByAdvertiser *mStatRepositoryMockGetByAdvertiser) Times(n uint64) *mStatRepositoryMockGetByAdvertiser {
	if n == 0 {
		mmGetByAdvertiser.mock.t.Fatalf("Times of StatRepositoryMock.GetByAdvertiser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetByAdvertiser.expectedInvocations, n)
	mmGetByAdvertiser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetByAdvertiser
}

func (mmGetByAdvertiser *mStatRepositoryMockGetByAdvertiser) invocationsDone() bool {
	if len(mmGetByAdvertiser.expectations) == 0 && mmGetByAdvertiser.defaultExpectation == nil && mmGetByAdvertiser.mock.funcGetByAdvertiser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetByAdvertiser.mock.afterGetByAdvertiserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetByAdvertiser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetByAdvertiser implements mm_repository.StatRepository
func (mmGetByAdvertiser *StatRepositoryMock) GetByAdvertiser(ctx context.Context, advertiserID string) (sp1 *model.Stat, err error) {
	mm_atomic.AddUint64(&mmGetByAdvertiser.beforeGetByAdvertiserCounter, 1)
	defer mm_atomic.AddUint64(&mmGetByAdvertiser.afterGetByAdvertiserCounter, 1)

	mmGetByAdvertiser.t.Helper()

	if mmGetByAdvertiser.inspectFuncGetByAdvertiser != nil {
		mmGetByAdvertiser.inspectFuncGetByAdvertiser(ctx, advertiserID)
	}

	mm_params := StatRepositoryMockGetByAdvertiserParams{ctx, advertiserID}

	// Record call args
	mmGetByAdvertiser.GetByAdvertiserMock.mutex.Lock()
	mmGetByAdvertiser.GetByAdvertiserMock.callArgs = append(mmGetByAdvertiser.GetByAdvertiserMock.callArgs, &mm_params)
	mmGetByAdvertiser.GetByAdvertiserMock.mutex.Unlock()

	for _, e := range mmGetByAdvertiser.GetByAdvertiserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmGetByAdvertiser.GetByAdvertiserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetByAdvertiser.GetByAdvertiserMock.defaultExpectation.Counter, 1)
		mm_want := mmGetByAdvertiser.GetByAdvertiserMock.defaultExpectation.params
		mm_want_ptrs := mmGetByAdvertiser.GetByAdvertiserMock.defaultExpectation.paramPtrs

		mm_got := StatRepositoryMockGetByAdvertiserParams{ctx, advertiserID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetByAdvertiser.t.Errorf("StatRepositoryMock.GetByAdvertiser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetByAdvertiser.GetByAdvertiserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.advertiserID != nil && !minimock.Equal(*mm_want_ptrs.advertiserID, mm_got.advertiserID) {
				mmGetByAdvertiser.t.Errorf("StatRepositoryMock.GetByAdvertiser got unexpected parameter advertiserID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetByAdvertiser.GetByAdvertiserMock.defaultExpectation.expectationOrigins.originAdvertiserID, *mm_want_ptrs.advertiserID, mm_got.advertiserID, minimock.Diff(*mm_want_ptrs.advertiserID, mm_got.advertiserID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetByAdvertiser.t.Errorf("StatRepositoryMock.GetByAdvertiser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetByAdvertiser.GetByAdvertiserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetByAdvertiser.GetByAdvertiserMock.defaultExpectation.results
		if mm_results == nil {
			mmGetByAdvertiser.t.Fatal("No results are set for the StatRepositoryMock.GetByAdvertiser")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmGetByAdvertiser.funcGetByAdvertiser != nil {
		return mmGetByAdvertiser.funcGetByAdvertiser(ctx, advertiserID)
	}
	mmGetByAdvertiser.t.Fatalf("Unexpected call to StatRepositoryMock.GetByAdvertiser. %v %v", ctx, advertiserID)
	return
}

// GetByAdvertiserAfterCounter returns a count of finished StatRepositoryMock.GetByAdvertiser invocations
func (mmGetByAdvertiser *StatRepositoryMock) GetByAdvertiserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByAdvertiser.afterGetByAdvertiserCounter)
}

// GetByAdvertiserBeforeCounter returns a count of StatRepositoryMock.GetByAdvertiser invocations
func (mmGetByAdvertiser *StatRepositoryMock) GetByAdvertiserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByAdvertiser.beforeGetByAdvertiserCounter)
}

// Calls returns a list of arguments used in each call to StatRepositoryMock.GetByAdvertiser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetByAdvertiser *mStatRepositoryMockGetByAdvertiser) Calls() []*StatRepositoryMockGetByAdvertiserParams {
	mmGetByAdvertiser.mutex.RLock()

	argCopy := make([]*StatRepositoryMockGetByAdvertiserParams, len(mmGetByAdvertiser.callArgs))
	copy(argCopy, mmGetByAdvertiser.callArgs)

	mmGetByAdvertiser.mutex.RUnlock()

	return argCopy
}

// MinimockGetByAdvertiserDone returns true if the count of the GetByAdvertiser invocations corresponds
// the number of defined expectations
func (m *StatRepositoryMock) MinimockGetByAdvertiserDone() bool {
	if m.GetByAdvertiserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetByAdvertiserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetByAdvertiserMock.invocationsDone()
}

// MinimockGetByAdvertiserInspect logs each unmet expectation
func (m *StatRepositoryMock) MinimockGetByAdvertiserInspect() {
	for _, e := range m.GetByAdvertiserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StatRepositoryMock.GetByAdvertiser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetByAdvertiserCounter := mm_atomic.LoadUint64(&m.afterGetByAdvertiserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetByAdvertiserMock.defaultExpectation != nil && afterGetByAdvertiserCounter < 1 {
		if m.GetByAdvertiserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StatRepositoryMock.GetByAdvertiser at\n%s", m.GetByAdvertiserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StatRepositoryMock.GetByAdvertiser at\n%s with params: %#v", m.GetByAdvertiserMock.defaultExpectation.expectationOrigins.origin, *m.GetByAdvertiserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetByAdvertiser != nil && afterGetByAdvertiserCounter < 1 {
		m.t.Errorf("Expected call to StatRepositoryMock.GetByAdvertiser at\n%s", m.funcGetByAdvertiserOrigin)
	}

	if !m.GetByAdvertiserMock.invocationsDone() && afterGetByAdvertiserCounter > 0 {
		m.t.Errorf("Expected %d calls to StatRepositoryMock.GetByAdvertiser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetByAdvertiserMock.expectedInvocations), m.GetByAdvertiserMock.expectedInvocationsOrigin, afterGetByAdvertiserCounter)
	}
}

type mStatRepositoryMockGetByAdvertiserDaily struct {
	optional           bool
	mock               *StatRepositoryMock
	defaultExpectation *StatRepositoryMockGetByAdvertiserDailyExpectation
	expectations       []*StatRepositoryMockGetByAdvertiserDailyExpectation

	callArgs []*StatRepositoryMockGetByAdvertiserDailyParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StatRepositoryMockGetByAdvertiserDailyExpectation specifies expectation struct of the StatRepository.GetByAdvertiserDaily
type StatRepositoryMockGetByAdvertiserDailyExpectation struct {
	mock               *StatRepositoryMock
	params             *StatRepositoryMockGetByAdvertiserDailyParams
	paramPtrs          *StatRepositoryMockGetByAdvertiserDailyParamPtrs
	expectationOrigins StatRepositoryMockGetByAdvertiserDailyExpectationOrigins
	results            *StatRepositoryMockGetByAdvertiserDailyResults
	returnOrigin       string
	Counter            uint64
}

// StatRepositoryMockGetByAdvertiserDailyParams contains parameters of the StatRepository.GetByAdvertiserDaily
type StatRepositoryMockGetByAdvertiserDailyParams struct {
	ctx          context.Context
	advertiserID string
}

// StatRepositoryMockGetByAdvertiserDailyParamPtrs contains pointers to parameters of the StatRepository.GetByAdvertiserDaily
type StatRepositoryMockGetByAdvertiserDailyParamPtrs struct {
	ctx          *context.Context
	advertiserID *string
}

// StatRepositoryMockGetByAdvertiserDailyResults contains results of the StatRepository.GetByAdvertiserDaily
type StatRepositoryMockGetByAdvertiserDailyResults struct {
	sp1 *model.Stat
	err error
}

// StatRepositoryMockGetByAdvertiserDailyOrigins contains origins of expectations of the StatRepository.GetByAdvertiserDaily
type StatRepositoryMockGetByAdvertiserDailyExpectationOrigins struct {
	origin             string
	originCtx          string
	originAdvertiserID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetByAdvertiserDaily *mStatRepositoryMockGetByAdvertiserDaily) Optional() *mStatRepositoryMockGetByAdvertiserDaily {
	mmGetByAdvertiserDaily.optional = true
	return mmGetByAdvertiserDaily
}

// Expect sets up expected params for StatRepository.GetByAdvertiserDaily
func (mmGetByAdvertiserDaily *mStatRepositoryMockGetByAdvertiserDaily) Expect(ctx context.Context, advertiserID string) *mStatRepositoryMockGetByAdvertiserDaily {
	if mmGetByAdvertiserDaily.mock.funcGetByAdvertiserDaily != nil {
		mmGetByAdvertiserDaily.mock.t.Fatalf("StatRepositoryMock.GetByAdvertiserDaily mock is already set by Set")
	}

	if mmGetByAdvertiserDaily.defaultExpectation == nil {
		mmGetByAdvertiserDaily.defaultExpectation = &StatRepositoryMockGetByAdvertiserDailyExpectation{}
	}

	if mmGetByAdvertiserDaily.defaultExpectation.paramPtrs != nil {
		mmGetByAdvertiserDaily.mock.t.Fatalf("StatRepositoryMock.GetByAdvertiserDaily mock is already set by ExpectParams functions")
	}

	mmGetByAdvertiserDaily.defaultExpectation.params = &StatRepositoryMockGetByAdvertiserDailyParams{ctx, advertiserID}
	mmGetByAdvertiserDaily.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetByAdvertiserDaily.expectations {
		if minimock.Equal(e.params, mmGetByAdvertiserDaily.defaultExpectation.params) {
			mmGetByAdvertiserDaily.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetByAdvertiserDaily.defaultExpectation.params)
		}
	}

	return mmGetByAdvertiserDaily
}

// ExpectCtxParam1 sets up expected param ctx for StatRepository.GetByAdvertiserDaily
func (mmGetByAdvertiserDaily *mStatRepositoryMockGetByAdvertiserDaily) ExpectCtxParam1(ctx context.Context) *mStatRepositoryMockGetByAdvertiserDaily {
	if mmGetByAdvertiserDaily.mock.funcGetByAdvertiserDaily != nil {
		mmGetByAdvertiserDaily.mock.t.Fatalf("StatRepositoryMock.GetByAdvertiserDaily mock is already set by Set")
	}

	if mmGetByAdvertiserDaily.defaultExpectation == nil {
		mmGetByAdvertiserDaily.defaultExpectation = &StatRepositoryMockGetByAdvertiserDailyExpectation{}
	}

	if mmGetByAdvertiserDaily.defaultExpectation.params != nil {
		mmGetByAdvertiserDaily.mock.t.Fatalf("StatRepositoryMock.GetByAdvertiserDaily mock is already set by Expect")
	}

	if mmGetByAdvertiserDaily.defaultExpectation.paramPtrs == nil {
		mmGetByAdvertiserDaily.defaultExpectation.paramPtrs = &StatRepositoryMockGetByAdvertiserDailyParamPtrs{}
	}
	mmGetByAdvertiserDaily.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetByAdvertiserDaily.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetByAdvertiserDaily
}

// ExpectAdvertiserIDParam2 sets up expected param advertiserID for StatRepository.GetByAdvertiserDaily
func (mmGetByAdvertiserDaily *mStatRepositoryMockGetByAdvertiserDaily) ExpectAdvertiserIDParam2(advertiserID string) *mStatRepositoryMockGetByAdvertiserDaily {
	if mmGetByAdvertiserDaily.mock.funcGetByAdvertiserDaily != nil {
		mmGetByAdvertiserDaily.mock.t.Fatalf("StatRepositoryMock.GetByAdvertiserDaily mock is already set by Set")
	}

	if mmGetByAdvertiserDaily.defaultExpectation == nil {
		mmGetByAdvertiserDaily.defaultExpectation = &StatRepositoryMockGetByAdvertiserDailyExpectation{}
	}

	if mmGetByAdvertiserDaily.defaultExpectation.params != nil {
		mmGetByAdvertiserDaily.mock.t.Fatalf("StatRepositoryMock.GetByAdvertiserDaily mock is already set by Expect")
	}

	if mmGetByAdvertiserDaily.defaultExpectation.paramPtrs == nil {
		mmGetByAdvertiserDaily.defaultExpectation.paramPtrs = &StatRepositoryMockGetByAdvertiserDailyParamPtrs{}
	}
	mmGetByAdvertiserDaily.defaultExpectation.paramPtrs.advertiserID = &advertiserID
	mmGetByAdvertiserDaily.defaultExpectation.expectationOrigins.originAdvertiserID = minimock.CallerInfo(1)

	return mmGetByAdvertiserDaily
}

// Inspect accepts an inspector function that has same arguments as the StatRepository.GetByAdvertiserDaily
func (mmGetByAdvertiserDaily *mStatRepositoryMockGetByAdvertiserDaily) Inspect(f func(ctx context.Context, advertiserID string)) *mStatRepositoryMockGetByAdvertiserDaily {
	if mmGetByAdvertiserDaily.mock.inspectFuncGetByAdvertiserDaily != nil {
		mmGetByAdvertiserDaily.mock.t.Fatalf("Inspect function is already set for StatRepositoryMock.GetByAdvertiserDaily")
	}

	mmGetByAdvertiserDaily.mock.inspectFuncGetByAdvertiserDaily = f

	return mmGetByAdvertiserDaily
}

// Return sets up results that will be returned by StatRepository.GetByAdvertiserDaily
func (mmGetByAdvertiserDaily *mStatRepositoryMockGetByAdvertiserDaily) Return(sp1 *model.Stat, err error) *StatRepositoryMock {
	if mmGetByAdvertiserDaily.mock.funcGetByAdvertiserDaily != nil {
		mmGetByAdvertiserDaily.mock.t.Fatalf("StatRepositoryMock.GetByAdvertiserDaily mock is already set by Set")
	}

	if mmGetByAdvertiserDaily.defaultExpectation == nil {
		mmGetByAdvertiserDaily.defaultExpectation = &StatRepositoryMockGetByAdvertiserDailyExpectation{mock: mmGetByAdvertiserDaily.mock}
	}
	mmGetByAdvertiserDaily.defaultExpectation.results = &StatRepositoryMockGetByAdvertiserDailyResults{sp1, err}
	mmGetByAdvertiserDaily.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetByAdvertiserDaily.mock
}

// Set uses given function f to mock the StatRepository.GetByAdvertiserDaily method
func (mmGetByAdvertiserDaily *mStatRepositoryMockGetByAdvertiserDaily) Set(f func(ctx context.Context, advertiserID string) (sp1 *model.Stat, err error)) *StatRepositoryMock {
	if mmGetByAdvertiserDaily.defaultExpectation != nil {
		mmGetByAdvertiserDaily.mock.t.Fatalf("Default expectation is already set for the StatRepository.GetByAdvertiserDaily method")
	}

	if len(mmGetByAdvertiserDaily.expectations) > 0 {
		mmGetByAdvertiserDaily.mock.t.Fatalf("Some expectations are already set for the StatRepository.GetByAdvertiserDaily method")
	}

	mmGetByAdvertiserDaily.mock.funcGetByAdvertiserDaily = f
	mmGetByAdvertiserDaily.mock.funcGetByAdvertiserDailyOrigin = minimock.CallerInfo(1)
	return mmGetByAdvertiserDaily.mock
}

// When sets expectation for the StatRepository.GetByAdvertiserDaily which will trigger the result defined by the following
// Then helper
func (mmGetByAdvertiserDaily *mStatRepositoryMockGetByAdvertiserDaily) When(ctx context.Context, advertiserID string) *StatRepositoryMockGetByAdvertiserDailyExpectation {
	if mmGetByAdvertiserDaily.mock.funcGetByAdvertiserDaily != nil {
		mmGetByAdvertiserDaily.mock.t.Fatalf("StatRepositoryMock.GetByAdvertiserDaily mock is already set by Set")
	}

	expectation := &StatRepositoryMockGetByAdvertiserDailyExpectation{
		mock:               mmGetByAdvertiserDaily.mock,
		params:             &StatRepositoryMockGetByAdvertiserDailyParams{ctx, advertiserID},
		expectationOrigins: StatRepositoryMockGetByAdvertiserDailyExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetByAdvertiserDaily.expectations = append(mmGetByAdvertiserDaily.expectations, expectation)
	return expectation
}

// Then sets up StatRepository.GetByAdvertiserDaily return parameters for the expectation previously defined by the When method
func (e *StatRepositoryMockGetByAdvertiserDailyExpectation) Then(sp1 *model.Stat, err error) *StatRepositoryMock {
	e.results = &StatRepositoryMockGetByAdvertiserDailyResults{sp1, err}
	return e.mock
}

// Times sets number of times StatRepository.GetByAdvertiserDaily should be invoked
func (mmGetByAdvertiserDaily *mStatRepositoryMockGetByAdvertiserDaily) Times(n uint64) *mStatRepositoryMockGetByAdvertiserDaily {
	if n == 0 {
		mmGetByAdvertiserDaily.mock.t.Fatalf("Times of StatRepositoryMock.GetByAdvertiserDaily mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetByAdvertiserDaily.expectedInvocations, n)
	mmGetByAdvertiserDaily.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetByAdvertiserDaily
}

func (mmGetByAdvertiserDaily *mStatRepositoryMockGetByAdvertiserDaily) invocationsDone() bool {
	if len(mmGetByAdvertiserDaily.expectations) == 0 && mmGetByAdvertiserDaily.defaultExpectation == nil && mmGetByAdvertiserDaily.mock.funcGetByAdvertiserDaily == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetByAdvertiserDaily.mock.afterGetByAdvertiserDailyCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetByAdvertiserDaily.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetByAdvertiserDaily implements mm_repository.StatRepository
func (mmGetByAdvertiserDaily *StatRepositoryMock) GetByAdvertiserDaily(ctx context.Context, advertiserID string) (sp1 *model.Stat, err error) {
	mm_atomic.AddUint64(&mmGetByAdvertiserDaily.beforeGetByAdvertiserDailyCounter, 1)
	defer mm_atomic.AddUint64(&mmGetByAdvertiserDaily.afterGetByAdvertiserDailyCounter, 1)

	mmGetByAdvertiserDaily.t.Helper()

	if mmGetByAdvertiserDaily.inspectFuncGetByAdvertiserDaily != nil {
		mmGetByAdvertiserDaily.inspectFuncGetByAdvertiserDaily(ctx, advertiserID)
	}

	mm_params := StatRepositoryMockGetByAdvertiserDailyParams{ctx, advertiserID}

	// Record call args
	mmGetByAdvertiserDaily.GetByAdvertiserDailyMock.mutex.Lock()
	mmGetByAdvertiserDaily.GetByAdvertiserDailyMock.callArgs = append(mmGetByAdvertiserDaily.GetByAdvertiserDailyMock.callArgs, &mm_params)
	mmGetByAdvertiserDaily.GetByAdvertiserDailyMock.mutex.Unlock()

	for _, e := range mmGetByAdvertiserDaily.GetByAdvertiserDailyMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmGetByAdvertiserDaily.GetByAdvertiserDailyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetByAdvertiserDaily.GetByAdvertiserDailyMock.defaultExpectation.Counter, 1)
		mm_want := mmGetByAdvertiserDaily.GetByAdvertiserDailyMock.defaultExpectation.params
		mm_want_ptrs := mmGetByAdvertiserDaily.GetByAdvertiserDailyMock.defaultExpectation.paramPtrs

		mm_got := StatRepositoryMockGetByAdvertiserDailyParams{ctx, advertiserID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetByAdvertiserDaily.t.Errorf("StatRepositoryMock.GetByAdvertiserDaily got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetByAdvertiserDaily.GetByAdvertiserDailyMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.advertiserID != nil && !minimock.Equal(*mm_want_ptrs.advertiserID, mm_got.advertiserID) {
				mmGetByAdvertiserDaily.t.Errorf("StatRepositoryMock.GetByAdvertiserDaily got unexpected parameter advertiserID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetByAdvertiserDaily.GetByAdvertiserDailyMock.defaultExpectation.expectationOrigins.originAdvertiserID, *mm_want_ptrs.advertiserID, mm_got.advertiserID, minimock.Diff(*mm_want_ptrs.advertiserID, mm_got.advertiserID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetByAdvertiserDaily.t.Errorf("StatRepositoryMock.GetByAdvertiserDaily got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetByAdvertiserDaily.GetByAdvertiserDailyMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetByAdvertiserDaily.GetByAdvertiserDailyMock.defaultExpectation.results
		if mm_results == nil {
			mmGetByAdvertiserDaily.t.Fatal("No results are set for the StatRepositoryMock.GetByAdvertiserDaily")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmGetByAdvertiserDaily.funcGetByAdvertiserDaily != nil {
		return mmGetByAdvertiserDaily.funcGetByAdvertiserDaily(ctx, advertiserID)
	}
	mmGetByAdvertiserDaily.t.Fatalf("Unexpected call to StatRepositoryMock.GetByAdvertiserDaily. %v %v", ctx, advertiserID)
	return
}

// GetByAdvertiserDailyAfterCounter returns a count of finished StatRepositoryMock.GetByAdvertiserDaily invocations
func (mmGetByAdvertiserDaily *StatRepositoryMock) GetByAdvertiserDailyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByAdvertiserDaily.afterGetByAdvertiserDailyCounter)
}

// GetByAdvertiserDailyBeforeCounter returns a count of StatRepositoryMock.GetByAdvertiserDaily invocations
func (mmGetByAdvertiserDaily *StatRepositoryMock) GetByAdvertiserDailyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByAdvertiserDaily.beforeGetByAdvertiserDailyCounter)
}

// Calls returns a list of arguments used in each call to StatRepositoryMock.GetByAdvertiserDaily.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetByAdvertiserDaily *mStatRepositoryMockGetByAdvertiserDaily) Calls() []*StatRepositoryMockGetByAdvertiserDailyParams {
	mmGetByAdvertiserDaily.mutex.RLock()

	argCopy := make([]*StatRepositoryMockGetByAdvertiserDailyParams, len(mmGetByAdvertiserDaily.callArgs))
	copy(argCopy, mmGetByAdvertiserDaily.callArgs)

	mmGetByAdvertiserDaily.mutex.RUnlock()

	return argCopy
}

// MinimockGetByAdvertiserDailyDone returns true if the count of the GetByAdvertiserDaily invocations corresponds
// the number of defined expectations
func (m *StatRepositoryMock) MinimockGetByAdvertiserDailyDone() bool {
	if m.GetByAdvertiserDailyMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetByAdvertiserDailyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetByAdvertiserDailyMock.invocationsDone()
}

// MinimockGetByAdvertiserDailyInspect logs each unmet expectation
func (m *StatRepositoryMock) MinimockGetByAdvertiserDailyInspect() {
	for _, e := range m.GetByAdvertiserDailyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StatRepositoryMock.GetByAdvertiserDaily at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetByAdvertiserDailyCounter := mm_atomic.LoadUint64(&m.afterGetByAdvertiserDailyCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetByAdvertiserDailyMock.defaultExpectation != nil && afterGetByAdvertiserDailyCounter < 1 {
		if m.GetByAdvertiserDailyMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StatRepositoryMock.GetByAdvertiserDaily at\n%s", m.GetByAdvertiserDailyMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StatRepositoryMock.GetByAdvertiserDaily at\n%s with params: %#v", m.GetByAdvertiserDailyMock.defaultExpectation.expectationOrigins.origin, *m.GetByAdvertiserDailyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetByAdvertiserDaily != nil && afterGetByAdvertiserDailyCounter < 1 {
		m.t.Errorf("Expected call to StatRepositoryMock.GetByAdvertiserDaily at\n%s", m.funcGetByAdvertiserDailyOrigin)
	}

	if !m.GetByAdvertiserDailyMock.invocationsDone() && afterGetByAdvertiserDailyCounter > 0 {
		m.t.Errorf("Expected %d calls to StatRepositoryMock.GetByAdvertiserDaily at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetByAdvertiserDailyMock.expectedInvocations), m.GetByAdvertiserDailyMock.expectedInvocationsOrigin, afterGetByAdvertiserDailyCounter)
	}
}

type mStatRepositoryMockGetByCampaign struct {
	optional           bool
	mock               *StatRepositoryMock
	defaultExpectation *StatRepositoryMockGetByCampaignExpectation
	expectations       []*StatRepositoryMockGetByCampaignExpectation

	callArgs []*StatRepositoryMockGetByCampaignParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StatRepositoryMockGetByCampaignExpectation specifies expectation struct of the StatRepository.GetByCampaign
type StatRepositoryMockGetByCampaignExpectation struct {
	mock               *StatRepositoryMock
	params             *StatRepositoryMockGetByCampaignParams
	paramPtrs          *StatRepositoryMockGetByCampaignParamPtrs
	expectationOrigins StatRepositoryMockGetByCampaignExpectationOrigins
	results            *StatRepositoryMockGetByCampaignResults
	returnOrigin       string
	Counter            uint64
}

// StatRepositoryMockGetByCampaignParams contains parameters of the StatRepository.GetByCampaign
type StatRepositoryMockGetByCampaignParams struct {
	ctx        context.Context
	campaignID string
}

// StatRepositoryMockGetByCampaignParamPtrs contains pointers to parameters of the StatRepository.GetByCampaign
type StatRepositoryMockGetByCampaignParamPtrs struct {
	ctx        *context.Context
	campaignID *string
}

// StatRepositoryMockGetByCampaignResults contains results of the StatRepository.GetByCampaign
type StatRepositoryMockGetByCampaignResults struct {
	sp1 *model.Stat
	err error
}

// StatRepositoryMockGetByCampaignOrigins contains origins of expectations of the StatRepository.GetByCampaign
type StatRepositoryMockGetByCampaignExpectationOrigins struct {
	origin           string
	originCtx        string
	originCampaignID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetByCampaign *mStatRepositoryMockGetByCampaign) Optional() *mStatRepositoryMockGetByCampaign {
	mmGetByCampaign.optional = true
	return mmGetByCampaign
}

// Expect sets up expected params for StatRepository.GetByCampaign
func (mmGetByCampaign *mStatRepositoryMockGetByCampaign) Expect(ctx context.Context, campaignID string) *mStatRepositoryMockGetByCampaign {
	if mmGetByCampaign.mock.funcGetByCampaign != nil {
		mmGetByCampaign.mock.t.Fatalf("StatRepositoryMock.GetByCampaign mock is already set by Set")
	}

	if mmGetByCampaign.defaultExpectation == nil {
		mmGetByCampaign.defaultExpectation = &StatRepositoryMockGetByCampaignExpectation{}
	}

	if mmGetByCampaign.defaultExpectation.paramPtrs != nil {
		mmGetByCampaign.mock.t.Fatalf("StatRepositoryMock.GetByCampaign mock is already set by ExpectParams functions")
	}

	mmGetByCampaign.defaultExpectation.params = &StatRepositoryMockGetByCampaignParams{ctx, campaignID}
	mmGetByCampaign.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetByCampaign.expectations {
		if minimock.Equal(e.params, mmGetByCampaign.defaultExpectation.params) {
			mmGetByCampaign.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetByCampaign.defaultExpectation.params)
		}
	}

	return mmGetByCampaign
}

// ExpectCtxParam1 sets up expected param ctx for StatRepository.GetByCampaign
func (mmGetByCampaign *mStatRepositoryMockGetByCampaign) ExpectCtxParam1(ctx context.Context) *mStatRepositoryMockGetByCampaign {
	if mmGetByCampaign.mock.funcGetByCampaign != nil {
		mmGetByCampaign.mock.t.Fatalf("StatRepositoryMock.GetByCampaign mock is already set by Set")
	}

	if mmGetByCampaign.defaultExpectation == nil {
		mmGetByCampaign.defaultExpectation = &StatRepositoryMockGetByCampaignExpectation{}
	}

	if mmGetByCampaign.defaultExpectation.params != nil {
		mmGetByCampaign.mock.t.Fatalf("StatRepositoryMock.GetByCampaign mock is already set by Expect")
	}

	if mmGetByCampaign.defaultExpectation.paramPtrs == nil {
		mmGetByCampaign.defaultExpectation.paramPtrs = &StatRepositoryMockGetByCampaignParamPtrs{}
	}
	mmGetByCampaign.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetByCampaign.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetByCampaign
}

// ExpectCampaignIDParam2 sets up expected param campaignID for StatRepository.GetByCampaign
func (mmGetByCampaign *mStatRepositoryMockGetByCampaign) ExpectCampaignIDParam2(campaignID string) *mStatRepositoryMockGetByCampaign {
	if mmGetByCampaign.mock.funcGetByCampaign != nil {
		mmGetByCampaign.mock.t.Fatalf("StatRepositoryMock.GetByCampaign mock is already set by Set")
	}

	if mmGetByCampaign.defaultExpectation == nil {
		mmGetByCampaign.defaultExpectation = &StatRepositoryMockGetByCampaignExpectation{}
	}

	if mmGetByCampaign.defaultExpectation.params != nil {
		mmGetByCampaign.mock.t.Fatalf("StatRepositoryMock.GetByCampaign mock is already set by Expect")
	}

	if mmGetByCampaign.defaultExpectation.paramPtrs == nil {
		mmGetByCampaign.defaultExpectation.paramPtrs = &StatRepositoryMockGetByCampaignParamPtrs{}
	}
	mmGetByCampaign.defaultExpectation.paramPtrs.campaignID = &campaignID
	mmGetByCampaign.defaultExpectation.expectationOrigins.originCampaignID = minimock.CallerInfo(1)

	return mmGetByCampaign
}

// Inspect accepts an inspector function that has same arguments as the StatRepository.GetByCampaign
func (mmGetByCampaign *mStatRepositoryMockGetByCampaign) Inspect(f func(ctx context.Context, campaignID string)) *mStatRepositoryMockGetByCampaign {
	if mmGetByCampaign.mock.inspectFuncGetByCampaign != nil {
		mmGetByCampaign.mock.t.Fatalf("Inspect function is already set for StatRepositoryMock.GetByCampaign")
	}

	mmGetByCampaign.mock.inspectFuncGetByCampaign = f

	return mmGetByCampaign
}

// Return sets up results that will be returned by StatRepository.GetByCampaign
func (mmGetByCampaign *mStatRepositoryMockGetByCampaign) Return(sp1 *model.Stat, err error) *StatRepositoryMock {
	if mmGetByCampaign.mock.funcGetByCampaign != nil {
		mmGetByCampaign.mock.t.Fatalf("StatRepositoryMock.GetByCampaign mock is already set by Set")
	}

	if mmGetByCampaign.defaultExpectation == nil {
		mmGetByCampaign.defaultExpectation = &StatRepositoryMockGetByCampaignExpectation{mock: mmGetByCampaign.mock}
	}
	mmGetByCampaign.defaultExpectation.results = &StatRepositoryMockGetByCampaignResults{sp1, err}
	mmGetByCampaign.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetByCampaign.mock
}

// Set uses given function f to mock the StatRepository.GetByCampaign method
func (mmGetByCampaign *mStatRepositoryMockGetByCampaign) Set(f func(ctx context.Context, campaignID string) (sp1 *model.Stat, err error)) *StatRepositoryMock {
	if mmGetByCampaign.defaultExpectation != nil {
		mmGetByCampaign.mock.t.Fatalf("Default expectation is already set for the StatRepository.GetByCampaign method")
	}

	if len(mmGetByCampaign.expectations) > 0 {
		mmGetByCampaign.mock.t.Fatalf("Some expectations are already set for the StatRepository.GetByCampaign method")
	}

	mmGetByCampaign.mock.funcGetByCampaign = f
	mmGetByCampaign.mock.funcGetByCampaignOrigin = minimock.CallerInfo(1)
	return mmGetByCampaign.mock
}

// When sets expectation for the StatRepository.GetByCampaign which will trigger the result defined by the following
// Then helper
func (mmGetByCampaign *mStatRepositoryMockGetByCampaign) When(ctx context.Context, campaignID string) *StatRepositoryMockGetByCampaignExpectation {
	if mmGetByCampaign.mock.funcGetByCampaign != nil {
		mmGetByCampaign.mock.t.Fatalf("StatRepositoryMock.GetByCampaign mock is already set by Set")
	}

	expectation := &StatRepositoryMockGetByCampaignExpectation{
		mock:               mmGetByCampaign.mock,
		params:             &StatRepositoryMockGetByCampaignParams{ctx, campaignID},
		expectationOrigins: StatRepositoryMockGetByCampaignExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetByCampaign.expectations = append(mmGetByCampaign.expectations, expectation)
	return expectation
}

// Then sets up StatRepository.GetByCampaign return parameters for the expectation previously defined by the When method
func (e *StatRepositoryMockGetByCampaignExpectation) Then(sp1 *model.Stat, err error) *StatRepositoryMock {
	e.results = &StatRepositoryMockGetByCampaignResults{sp1, err}
	return e.mock
}

// Times sets number of times StatRepository.GetByCampaign should be invoked
func (mmGetByCampaign *mStatRepositoryMockGetByCampaign) Times(n uint64) *mStatRepositoryMockGetByCampaign {
	if n == 0 {
		mmGetByCampaign.mock.t.Fatalf("Times of StatRepositoryMock.GetByCampaign mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetByCampaign.expectedInvocations, n)
	mmGetByCampaign.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetByCampaign
}

func (mmGetByCampaign *mStatRepositoryMockGetByCampaign) invocationsDone() bool {
	if len(mmGetByCampaign.expectations) == 0 && mmGetByCampaign.defaultExpectation == nil && mmGetByCampaign.mock.funcGetByCampaign == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetByCampaign.mock.afterGetByCampaignCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetByCampaign.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetByCampaign implements mm_repository.StatRepository
func (mmGetByCampaign *StatRepositoryMock) GetByCampaign(ctx context.Context, campaignID string) (sp1 *model.Stat, err error) {
	mm_atomic.AddUint64(&mmGetByCampaign.beforeGetByCampaignCounter, 1)
	defer mm_atomic.AddUint64(&mmGetByCampaign.afterGetByCampaignCounter, 1)

	mmGetByCampaign.t.Helper()

	if mmGetByCampaign.inspectFuncGetByCampaign != nil {
		mmGetByCampaign.inspectFuncGetByCampaign(ctx, campaignID)
	}

	mm_params := StatRepositoryMockGetByCampaignParams{ctx, campaignID}

	// Record call args
	mmGetByCampaign.GetByCampaignMock.mutex.Lock()
	mmGetByCampaign.GetByCampaignMock.callArgs = append(mmGetByCampaign.GetByCampaignMock.callArgs, &mm_params)
	mmGetByCampaign.GetByCampaignMock.mutex.Unlock()

	for _, e := range mmGetByCampaign.GetByCampaignMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmGetByCampaign.GetByCampaignMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetByCampaign.GetByCampaignMock.defaultExpectation.Counter, 1)
		mm_want := mmGetByCampaign.GetByCampaignMock.defaultExpectation.params
		mm_want_ptrs := mmGetByCampaign.GetByCampaignMock.defaultExpectation.paramPtrs

		mm_got := StatRepositoryMockGetByCampaignParams{ctx, campaignID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetByCampaign.t.Errorf("StatRepositoryMock.GetByCampaign got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetByCampaign.GetByCampaignMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.campaignID != nil && !minimock.Equal(*mm_want_ptrs.campaignID, mm_got.campaignID) {
				mmGetByCampaign.t.Errorf("StatRepositoryMock.GetByCampaign got unexpected parameter campaignID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetByCampaign.GetByCampaignMock.defaultExpectation.expectationOrigins.originCampaignID, *mm_want_ptrs.campaignID, mm_got.campaignID, minimock.Diff(*mm_want_ptrs.campaignID, mm_got.campaignID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetByCampaign.t.Errorf("StatRepositoryMock.GetByCampaign got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetByCampaign.GetByCampaignMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetByCampaign.GetByCampaignMock.defaultExpectation.results
		if mm_results == nil {
			mmGetByCampaign.t.Fatal("No results are set for the StatRepositoryMock.GetByCampaign")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmGetByCampaign.funcGetByCampaign != nil {
		return mmGetByCampaign.funcGetByCampaign(ctx, campaignID)
	}
	mmGetByCampaign.t.Fatalf("Unexpected call to StatRepositoryMock.GetByCampaign. %v %v", ctx, campaignID)
	return
}

// GetByCampaignAfterCounter returns a count of finished StatRepositoryMock.GetByCampaign invocations
func (mmGetByCampaign *StatRepositoryMock) GetByCampaignAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByCampaign.afterGetByCampaignCounter)
}

// GetByCampaignBeforeCounter returns a count of StatRepositoryMock.GetByCampaign invocations
func (mmGetByCampaign *StatRepositoryMock) GetByCampaignBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByCampaign.beforeGetByCampaignCounter)
}

// Calls returns a list of arguments used in each call to StatRepositoryMock.GetByCampaign.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetByCampaign *mStatRepositoryMockGetByCampaign) Calls() []*StatRepositoryMockGetByCampaignParams {
	mmGetByCampaign.mutex.RLock()

	argCopy := make([]*StatRepositoryMockGetByCampaignParams, len(mmGetByCampaign.callArgs))
	copy(argCopy, mmGetByCampaign.callArgs)

	mmGetByCampaign.mutex.RUnlock()

	return argCopy
}

// MinimockGetByCampaignDone returns true if the count of the GetByCampaign invocations corresponds
// the number of defined expectations
func (m *StatRepositoryMock) MinimockGetByCampaignDone() bool {
	if m.GetByCampaignMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetByCampaignMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetByCampaignMock.invocationsDone()
}

// MinimockGetByCampaignInspect logs each unmet expectation
func (m *StatRepositoryMock) MinimockGetByCampaignInspect() {
	for _, e := range m.GetByCampaignMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StatRepositoryMock.GetByCampaign at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetByCampaignCounter := mm_atomic.LoadUint64(&m.afterGetByCampaignCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetByCampaignMock.defaultExpectation != nil && afterGetByCampaignCounter < 1 {
		if m.GetByCampaignMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StatRepositoryMock.GetByCampaign at\n%s", m.GetByCampaignMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StatRepositoryMock.GetByCampaign at\n%s with params: %#v", m.GetByCampaignMock.defaultExpectation.expectationOrigins.origin, *m.GetByCampaignMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetByCampaign != nil && afterGetByCampaignCounter < 1 {
		m.t.Errorf("Expected call to StatRepositoryMock.GetByCampaign at\n%s", m.funcGetByCampaignOrigin)
	}

	if !m.GetByCampaignMock.invocationsDone() && afterGetByCampaignCounter > 0 {
		m.t.Errorf("Expected %d calls to StatRepositoryMock.GetByCampaign at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetByCampaignMock.expectedInvocations), m.GetByCampaignMock.expectedInvocationsOrigin, afterGetByCampaignCounter)
	}
}

type mStatRepositoryMockGetByCampaignDaily struct {
	optional           bool
	mock               *StatRepositoryMock
	defaultExpectation *StatRepositoryMockGetByCampaignDailyExpectation
	expectations       []*StatRepositoryMockGetByCampaignDailyExpectation

	callArgs []*StatRepositoryMockGetByCampaignDailyParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StatRepositoryMockGetByCampaignDailyExpectation specifies expectation struct of the StatRepository.GetByCampaignDaily
type StatRepositoryMockGetByCampaignDailyExpectation struct {
	mock               *StatRepositoryMock
	params             *StatRepositoryMockGetByCampaignDailyParams
	paramPtrs          *StatRepositoryMockGetByCampaignDailyParamPtrs
	expectationOrigins StatRepositoryMockGetByCampaignDailyExpectationOrigins
	results            *StatRepositoryMockGetByCampaignDailyResults
	returnOrigin       string
	Counter            uint64
}

// StatRepositoryMockGetByCampaignDailyParams contains parameters of the StatRepository.GetByCampaignDaily
type StatRepositoryMockGetByCampaignDailyParams struct {
	ctx        context.Context
	campaignID string
}

// StatRepositoryMockGetByCampaignDailyParamPtrs contains pointers to parameters of the StatRepository.GetByCampaignDaily
type StatRepositoryMockGetByCampaignDailyParamPtrs struct {
	ctx        *context.Context
	campaignID *string
}

// StatRepositoryMockGetByCampaignDailyResults contains results of the StatRepository.GetByCampaignDaily
type StatRepositoryMockGetByCampaignDailyResults struct {
	sp1 *model.Stat
	err error
}

// StatRepositoryMockGetByCampaignDailyOrigins contains origins of expectations of the StatRepository.GetByCampaignDaily
type StatRepositoryMockGetByCampaignDailyExpectationOrigins struct {
	origin           string
	originCtx        string
	originCampaignID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetByCampaignDaily *mStatRepositoryMockGetByCampaignDaily) Optional() *mStatRepositoryMockGetByCampaignDaily {
	mmGetByCampaignDaily.optional = true
	return mmGetByCampaignDaily
}

// Expect sets up expected params for StatRepository.GetByCampaignDaily
func (mmGetByCampaignDaily *mStatRepositoryMockGetByCampaignDaily) Expect(ctx context.Context, campaignID string) *mStatRepositoryMockGetByCampaignDaily {
	if mmGetByCampaignDaily.mock.funcGetByCampaignDaily != nil {
		mmGetByCampaignDaily.mock.t.Fatalf("StatRepositoryMock.GetByCampaignDaily mock is already set by Set")
	}

	if mmGetByCampaignDaily.defaultExpectation == nil {
		mmGetByCampaignDaily.defaultExpectation = &StatRepositoryMockGetByCampaignDailyExpectation{}
	}

	if mmGetByCampaignDaily.defaultExpectation.paramPtrs != nil {
		mmGetByCampaignDaily.mock.t.Fatalf("StatRepositoryMock.GetByCampaignDaily mock is already set by ExpectParams functions")
	}

	mmGetByCampaignDaily.defaultExpectation.params = &StatRepositoryMockGetByCampaignDailyParams{ctx, campaignID}
	mmGetByCampaignDaily.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetByCampaignDaily.expectations {
		if minimock.Equal(e.params, mmGetByCampaignDaily.defaultExpectation.params) {
			mmGetByCampaignDaily.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetByCampaignDaily.defaultExpectation.params)
		}
	}

	return mmGetByCampaignDaily
}

// ExpectCtxParam1 sets up expected param ctx for StatRepository.GetByCampaignDaily
func (mmGetByCampaignDaily *mStatRepositoryMockGetByCampaignDaily) ExpectCtxParam1(ctx context.Context) *mStatRepositoryMockGetByCampaignDaily {
	if mmGetByCampaignDaily.mock.funcGetByCampaignDaily != nil {
		mmGetByCampaignDaily.mock.t.Fatalf("StatRepositoryMock.GetByCampaignDaily mock is already set by Set")
	}

	if mmGetByCampaignDaily.defaultExpectation == nil {
		mmGetByCampaignDaily.defaultExpectation = &StatRepositoryMockGetByCampaignDailyExpectation{}
	}

	if mmGetByCampaignDaily.defaultExpectation.params != nil {
		mmGetByCampaignDaily.mock.t.Fatalf("StatRepositoryMock.GetByCampaignDaily mock is already set by Expect")
	}

	if mmGetByCampaignDaily.defaultExpectation.paramPtrs == nil {
		mmGetByCampaignDaily.defaultExpectation.paramPtrs = &StatRepositoryMockGetByCampaignDailyParamPtrs{}
	}
	mmGetByCampaignDaily.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetByCampaignDaily.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetByCampaignDaily
}

// ExpectCampaignIDParam2 sets up expected param campaignID for StatRepository.GetByCampaignDaily
func (mmGetByCampaignDaily *mStatRepositoryMockGetByCampaignDaily) ExpectCampaignIDParam2(campaignID string) *mStatRepositoryMockGetByCampaignDaily {
	if mmGetByCampaignDaily.mock.funcGetByCampaignDaily != nil {
		mmGetByCampaignDaily.mock.t.Fatalf("StatRepositoryMock.GetByCampaignDaily mock is already set by Set")
	}

	if mmGetByCampaignDaily.defaultExpectation == nil {
		mmGetByCampaignDaily.defaultExpectation = &StatRepositoryMockGetByCampaignDailyExpectation{}
	}

	if mmGetByCampaignDaily.defaultExpectation.params != nil {
		mmGetByCampaignDaily.mock.t.Fatalf("StatRepositoryMock.GetByCampaignDaily mock is already set by Expect")
	}

	if mmGetByCampaignDaily.defaultExpectation.paramPtrs == nil {
		mmGetByCampaignDaily.defaultExpectation.paramPtrs = &StatRepositoryMockGetByCampaignDailyParamPtrs{}
	}
	mmGetByCampaignDaily.defaultExpectation.paramPtrs.campaignID = &campaignID
	mmGetByCampaignDaily.defaultExpectation.expectationOrigins.originCampaignID = minimock.CallerInfo(1)

	return mmGetByCampaignDaily
}

// Inspect accepts an inspector function that has same arguments as the StatRepository.GetByCampaignDaily
func (mmGetByCampaignDaily *mStatRepositoryMockGetByCampaignDaily) Inspect(f func(ctx context.Context, campaignID string)) *mStatRepositoryMockGetByCampaignDaily {
	if mmGetByCampaignDaily.mock.inspectFuncGetByCampaignDaily != nil {
		mmGetByCampaignDaily.mock.t.Fatalf("Inspect function is already set for StatRepositoryMock.GetByCampaignDaily")
	}

	mmGetByCampaignDaily.mock.inspectFuncGetByCampaignDaily = f

	return mmGetByCampaignDaily
}

// Return sets up results that will be returned by StatRepository.GetByCampaignDaily
func (mmGetByCampaignDaily *mStatRepositoryMockGetByCampaignDaily) Return(sp1 *model.Stat, err error) *StatRepositoryMock {
	if mmGetByCampaignDaily.mock.funcGetByCampaignDaily != nil {
		mmGetByCampaignDaily.mock.t.Fatalf("StatRepositoryMock.GetByCampaignDaily mock is already set by Set")
	}

	if mmGetByCampaignDaily.defaultExpectation == nil {
		mmGetByCampaignDaily.defaultExpectation = &StatRepositoryMockGetByCampaignDailyExpectation{mock: mmGetByCampaignDaily.mock}
	}
	mmGetByCampaignDaily.defaultExpectation.results = &StatRepositoryMockGetByCampaignDailyResults{sp1, err}
	mmGetByCampaignDaily.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetByCampaignDaily.mock
}

// Set uses given function f to mock the StatRepository.GetByCampaignDaily method
func (mmGetByCampaignDaily *mStatRepositoryMockGetByCampaignDaily) Set(f func(ctx context.Context, campaignID string) (sp1 *model.Stat, err error)) *StatRepositoryMock {
	if mmGetByCampaignDaily.defaultExpectation != nil {
		mmGetByCampaignDaily.mock.t.Fatalf("Default expectation is already set for the StatRepository.GetByCampaignDaily method")
	}

	if len(mmGetByCampaignDaily.expectations) > 0 {
		mmGetByCampaignDaily.mock.t.Fatalf("Some expectations are already set for the StatRepository.GetByCampaignDaily method")
	}

	mmGetByCampaignDaily.mock.funcGetByCampaignDaily = f
	mmGetByCampaignDaily.mock.funcGetByCampaignDailyOrigin = minimock.CallerInfo(1)
	return mmGetByCampaignDaily.mock
}

// When sets expectation for the StatRepository.GetByCampaignDaily which will trigger the result defined by the following
// Then helper
func (mmGetByCampaignDaily *mStatRepositoryMockGetByCampaignDaily) When(ctx context.Context, campaignID string) *StatRepositoryMockGetByCampaignDailyExpectation {
	if mmGetByCampaignDaily.mock.funcGetByCampaignDaily != nil {
		mmGetByCampaignDaily.mock.t.Fatalf("StatRepositoryMock.GetByCampaignDaily mock is already set by Set")
	}

	expectation := &StatRepositoryMockGetByCampaignDailyExpectation{
		mock:               mmGetByCampaignDaily.mock,
		params:             &StatRepositoryMockGetByCampaignDailyParams{ctx, campaignID},
		expectationOrigins: StatRepositoryMockGetByCampaignDailyExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetByCampaignDaily.expectations = append(mmGetByCampaignDaily.expectations, expectation)
	return expectation
}

// Then sets up StatRepository.GetByCampaignDaily return parameters for the expectation previously defined by the When method
func (e *StatRepositoryMockGetByCampaignDailyExpectation) Then(sp1 *model.Stat, err error) *StatRepositoryMock {
	e.results = &StatRepositoryMockGetByCampaignDailyResults{sp1, err}
	return e.mock
}

// Times sets number of times StatRepository.GetByCampaignDaily should be invoked
func (mmGetByCampaignDaily *mStatRepositoryMockGetByCampaignDaily) Times(n uint64) *mStatRepositoryMockGetByCampaignDaily {
	if n == 0 {
		mmGetByCampaignDaily.mock.t.Fatalf("Times of StatRepositoryMock.GetByCampaignDaily mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetByCampaignDaily.expectedInvocations, n)
	mmGetByCampaignDaily.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetByCampaignDaily
}

func (mmGetByCampaignDaily *mStatRepositoryMockGetByCampaignDaily) invocationsDone() bool {
	if len(mmGetByCampaignDaily.expectations) == 0 && mmGetByCampaignDaily.defaultExpectation == nil && mmGetByCampaignDaily.mock.funcGetByCampaignDaily == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetByCampaignDaily.mock.afterGetByCampaignDailyCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetByCampaignDaily.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetByCampaignDaily implements mm_repository.StatRepository
func (mmGetByCampaignDaily *StatRepositoryMock) GetByCampaignDaily(ctx context.Context, campaignID string) (sp1 *model.Stat, err error) {
	mm_atomic.AddUint64(&mmGetByCampaignDaily.beforeGetByCampaignDailyCounter, 1)
	defer mm_atomic.AddUint64(&mmGetByCampaignDaily.afterGetByCampaignDailyCounter, 1)

	mmGetByCampaignDaily.t.Helper()

	if mmGetByCampaignDaily.inspectFuncGetByCampaignDaily != nil {
		mmGetByCampaignDaily.inspectFuncGetByCampaignDaily(ctx, campaignID)
	}

	mm_params := StatRepositoryMockGetByCampaignDailyParams{ctx, campaignID}

	// Record call args
	mmGetByCampaignDaily.GetByCampaignDailyMock.mutex.Lock()
	mmGetByCampaignDaily.GetByCampaignDailyMock.callArgs = append(mmGetByCampaignDaily.GetByCampaignDailyMock.callArgs, &mm_params)
	mmGetByCampaignDaily.GetByCampaignDailyMock.mutex.Unlock()

	for _, e := range mmGetByCampaignDaily.GetByCampaignDailyMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmGetByCampaignDaily.GetByCampaignDailyMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetByCampaignDaily.GetByCampaignDailyMock.defaultExpectation.Counter, 1)
		mm_want := mmGetByCampaignDaily.GetByCampaignDailyMock.defaultExpectation.params
		mm_want_ptrs := mmGetByCampaignDaily.GetByCampaignDailyMock.defaultExpectation.paramPtrs

		mm_got := StatRepositoryMockGetByCampaignDailyParams{ctx, campaignID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetByCampaignDaily.t.Errorf("StatRepositoryMock.GetByCampaignDaily got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetByCampaignDaily.GetByCampaignDailyMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.campaignID != nil && !minimock.Equal(*mm_want_ptrs.campaignID, mm_got.campaignID) {
				mmGetByCampaignDaily.t.Errorf("StatRepositoryMock.GetByCampaignDaily got unexpected parameter campaignID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetByCampaignDaily.GetByCampaignDailyMock.defaultExpectation.expectationOrigins.originCampaignID, *mm_want_ptrs.campaignID, mm_got.campaignID, minimock.Diff(*mm_want_ptrs.campaignID, mm_got.campaignID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetByCampaignDaily.t.Errorf("StatRepositoryMock.GetByCampaignDaily got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetByCampaignDaily.GetByCampaignDailyMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetByCampaignDaily.GetByCampaignDailyMock.defaultExpectation.results
		if mm_results == nil {
			mmGetByCampaignDaily.t.Fatal("No results are set for the StatRepositoryMock.GetByCampaignDaily")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmGetByCampaignDaily.funcGetByCampaignDaily != nil {
		return mmGetByCampaignDaily.funcGetByCampaignDaily(ctx, campaignID)
	}
	mmGetByCampaignDaily.t.Fatalf("Unexpected call to StatRepositoryMock.GetByCampaignDaily. %v %v", ctx, campaignID)
	return
}

// GetByCampaignDailyAfterCounter returns a count of finished StatRepositoryMock.GetByCampaignDaily invocations
func (mmGetByCampaignDaily *StatRepositoryMock) GetByCampaignDailyAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByCampaignDaily.afterGetByCampaignDailyCounter)
}

// GetByCampaignDailyBeforeCounter returns a count of StatRepositoryMock.GetByCampaignDaily invocations
func (mmGetByCampaignDaily *StatRepositoryMock) GetByCampaignDailyBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByCampaignDaily.beforeGetByCampaignDailyCounter)
}

// Calls returns a list of arguments used in each call to StatRepositoryMock.GetByCampaignDaily.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetByCampaignDaily *mStatRepositoryMockGetByCampaignDaily) Calls() []*StatRepositoryMockGetByCampaignDailyParams {
	mmGetByCampaignDaily.mutex.RLock()

	argCopy := make([]*StatRepositoryMockGetByCampaignDailyParams, len(mmGetByCampaignDaily.callArgs))
	copy(argCopy, mmGetByCampaignDaily.callArgs)

	mmGetByCampaignDaily.mutex.RUnlock()

	return argCopy
}

// MinimockGetByCampaignDailyDone returns true if the count of the GetByCampaignDaily invocations corresponds
// the number of defined expectations
func (m *StatRepositoryMock) MinimockGetByCampaignDailyDone() bool {
	if m.GetByCampaignDailyMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetByCampaignDailyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetByCampaignDailyMock.invocationsDone()
}

// MinimockGetByCampaignDailyInspect logs each unmet expectation
func (m *StatRepositoryMock) MinimockGetByCampaignDailyInspect() {
	for _, e := range m.GetByCampaignDailyMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StatRepositoryMock.GetByCampaignDaily at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetByCampaignDailyCounter := mm_atomic.LoadUint64(&m.afterGetByCampaignDailyCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetByCampaignDailyMock.defaultExpectation != nil && afterGetByCampaignDailyCounter < 1 {
		if m.GetByCampaignDailyMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StatRepositoryMock.GetByCampaignDaily at\n%s", m.GetByCampaignDailyMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StatRepositoryMock.GetByCampaignDaily at\n%s with params: %#v", m.GetByCampaignDailyMock.defaultExpectation.expectationOrigins.origin, *m.GetByCampaignDailyMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetByCampaignDaily != nil && afterGetByCampaignDailyCounter < 1 {
		m.t.Errorf("Expected call to StatRepositoryMock.GetByCampaignDaily at\n%s", m.funcGetByCampaignDailyOrigin)
	}

	if !m.GetByCampaignDailyMock.invocationsDone() && afterGetByCampaignDailyCounter > 0 {
		m.t.Errorf("Expected %d calls to StatRepositoryMock.GetByCampaignDaily at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetByCampaignDailyMock.expectedInvocations), m.GetByCampaignDailyMock.expectedInvocationsOrigin, afterGetByCampaignDailyCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *StatRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetByAdvertiserInspect()

			m.MinimockGetByAdvertiserDailyInspect()

			m.MinimockGetByCampaignInspect()

			m.MinimockGetByCampaignDailyInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *StatRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *StatRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetByAdvertiserDone() &&
		m.MinimockGetByAdvertiserDailyDone() &&
		m.MinimockGetByCampaignDone() &&
		m.MinimockGetByCampaignDailyDone()
}
