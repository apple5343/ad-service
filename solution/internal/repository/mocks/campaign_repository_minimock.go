// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i server/internal/repository.CampaignRepository -o campaign_repository_minimock.go -n CampaignRepositoryMock -p mocks

import (
	"context"
	"server/internal/model"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// CampaignRepositoryMock implements mm_repository.CampaignRepository
type CampaignRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreate          func(ctx context.Context, campaign *model.Campaign) (cp1 *model.Campaign, err error)
	funcCreateOrigin    string
	inspectFuncCreate   func(ctx context.Context, campaign *model.Campaign)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mCampaignRepositoryMockCreate

	funcDelete          func(ctx context.Context, advertiserID string, campaignID string) (err error)
	funcDeleteOrigin    string
	inspectFuncDelete   func(ctx context.Context, advertiserID string, campaignID string)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mCampaignRepositoryMockDelete

	funcGet          func(ctx context.Context, advertiserID string, campaignID string) (cp1 *model.Campaign, err error)
	funcGetOrigin    string
	inspectFuncGet   func(ctx context.Context, advertiserID string, campaignID string)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mCampaignRepositoryMockGet

	funcGetByCampaignID          func(ctx context.Context, campaignID string) (cp1 *model.Campaign, err error)
	funcGetByCampaignIDOrigin    string
	inspectFuncGetByCampaignID   func(ctx context.Context, campaignID string)
	afterGetByCampaignIDCounter  uint64
	beforeGetByCampaignIDCounter uint64
	GetByCampaignIDMock          mCampaignRepositoryMockGetByCampaignID

	funcList          func(ctx context.Context, advertiserID string, page int, size int) (cpa1 []*model.Campaign, err error)
	funcListOrigin    string
	inspectFuncList   func(ctx context.Context, advertiserID string, page int, size int)
	afterListCounter  uint64
	beforeListCounter uint64
	ListMock          mCampaignRepositoryMockList

	funcSaveImageUrl          func(ctx context.Context, imageUrl string, campaignID string) (s1 string, err error)
	funcSaveImageUrlOrigin    string
	inspectFuncSaveImageUrl   func(ctx context.Context, imageUrl string, campaignID string)
	afterSaveImageUrlCounter  uint64
	beforeSaveImageUrlCounter uint64
	SaveImageUrlMock          mCampaignRepositoryMockSaveImageUrl

	funcUpdate          func(ctx context.Context, campaign *model.Campaign) (cp1 *model.Campaign, err error)
	funcUpdateOrigin    string
	inspectFuncUpdate   func(ctx context.Context, campaign *model.Campaign)
	afterUpdateCounter  uint64
	beforeUpdateCounter uint64
	UpdateMock          mCampaignRepositoryMockUpdate
}

// NewCampaignRepositoryMock returns a mock for mm_repository.CampaignRepository
func NewCampaignRepositoryMock(t minimock.Tester) *CampaignRepositoryMock {
	m := &CampaignRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mCampaignRepositoryMockCreate{mock: m}
	m.CreateMock.callArgs = []*CampaignRepositoryMockCreateParams{}

	m.DeleteMock = mCampaignRepositoryMockDelete{mock: m}
	m.DeleteMock.callArgs = []*CampaignRepositoryMockDeleteParams{}

	m.GetMock = mCampaignRepositoryMockGet{mock: m}
	m.GetMock.callArgs = []*CampaignRepositoryMockGetParams{}

	m.GetByCampaignIDMock = mCampaignRepositoryMockGetByCampaignID{mock: m}
	m.GetByCampaignIDMock.callArgs = []*CampaignRepositoryMockGetByCampaignIDParams{}

	m.ListMock = mCampaignRepositoryMockList{mock: m}
	m.ListMock.callArgs = []*CampaignRepositoryMockListParams{}

	m.SaveImageUrlMock = mCampaignRepositoryMockSaveImageUrl{mock: m}
	m.SaveImageUrlMock.callArgs = []*CampaignRepositoryMockSaveImageUrlParams{}

	m.UpdateMock = mCampaignRepositoryMockUpdate{mock: m}
	m.UpdateMock.callArgs = []*CampaignRepositoryMockUpdateParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mCampaignRepositoryMockCreate struct {
	optional           bool
	mock               *CampaignRepositoryMock
	defaultExpectation *CampaignRepositoryMockCreateExpectation
	expectations       []*CampaignRepositoryMockCreateExpectation

	callArgs []*CampaignRepositoryMockCreateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CampaignRepositoryMockCreateExpectation specifies expectation struct of the CampaignRepository.Create
type CampaignRepositoryMockCreateExpectation struct {
	mock               *CampaignRepositoryMock
	params             *CampaignRepositoryMockCreateParams
	paramPtrs          *CampaignRepositoryMockCreateParamPtrs
	expectationOrigins CampaignRepositoryMockCreateExpectationOrigins
	results            *CampaignRepositoryMockCreateResults
	returnOrigin       string
	Counter            uint64
}

// CampaignRepositoryMockCreateParams contains parameters of the CampaignRepository.Create
type CampaignRepositoryMockCreateParams struct {
	ctx      context.Context
	campaign *model.Campaign
}

// CampaignRepositoryMockCreateParamPtrs contains pointers to parameters of the CampaignRepository.Create
type CampaignRepositoryMockCreateParamPtrs struct {
	ctx      *context.Context
	campaign **model.Campaign
}

// CampaignRepositoryMockCreateResults contains results of the CampaignRepository.Create
type CampaignRepositoryMockCreateResults struct {
	cp1 *model.Campaign
	err error
}

// CampaignRepositoryMockCreateOrigins contains origins of expectations of the CampaignRepository.Create
type CampaignRepositoryMockCreateExpectationOrigins struct {
	origin         string
	originCtx      string
	originCampaign string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mCampaignRepositoryMockCreate) Optional() *mCampaignRepositoryMockCreate {
	mmCreate.optional = true
	return mmCreate
}

// Expect sets up expected params for CampaignRepository.Create
func (mmCreate *mCampaignRepositoryMockCreate) Expect(ctx context.Context, campaign *model.Campaign) *mCampaignRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("CampaignRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &CampaignRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.paramPtrs != nil {
		mmCreate.mock.t.Fatalf("CampaignRepositoryMock.Create mock is already set by ExpectParams functions")
	}

	mmCreate.defaultExpectation.params = &CampaignRepositoryMockCreateParams{ctx, campaign}
	mmCreate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// ExpectCtxParam1 sets up expected param ctx for CampaignRepository.Create
func (mmCreate *mCampaignRepositoryMockCreate) ExpectCtxParam1(ctx context.Context) *mCampaignRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("CampaignRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &CampaignRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("CampaignRepositoryMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &CampaignRepositoryMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreate
}

// ExpectCampaignParam2 sets up expected param campaign for CampaignRepository.Create
func (mmCreate *mCampaignRepositoryMockCreate) ExpectCampaignParam2(campaign *model.Campaign) *mCampaignRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("CampaignRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &CampaignRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("CampaignRepositoryMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &CampaignRepositoryMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.campaign = &campaign
	mmCreate.defaultExpectation.expectationOrigins.originCampaign = minimock.CallerInfo(1)

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the CampaignRepository.Create
func (mmCreate *mCampaignRepositoryMockCreate) Inspect(f func(ctx context.Context, campaign *model.Campaign)) *mCampaignRepositoryMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for CampaignRepositoryMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by CampaignRepository.Create
func (mmCreate *mCampaignRepositoryMockCreate) Return(cp1 *model.Campaign, err error) *CampaignRepositoryMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("CampaignRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &CampaignRepositoryMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &CampaignRepositoryMockCreateResults{cp1, err}
	mmCreate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// Set uses given function f to mock the CampaignRepository.Create method
func (mmCreate *mCampaignRepositoryMockCreate) Set(f func(ctx context.Context, campaign *model.Campaign) (cp1 *model.Campaign, err error)) *CampaignRepositoryMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the CampaignRepository.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the CampaignRepository.Create method")
	}

	mmCreate.mock.funcCreate = f
	mmCreate.mock.funcCreateOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// When sets expectation for the CampaignRepository.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mCampaignRepositoryMockCreate) When(ctx context.Context, campaign *model.Campaign) *CampaignRepositoryMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("CampaignRepositoryMock.Create mock is already set by Set")
	}

	expectation := &CampaignRepositoryMockCreateExpectation{
		mock:               mmCreate.mock,
		params:             &CampaignRepositoryMockCreateParams{ctx, campaign},
		expectationOrigins: CampaignRepositoryMockCreateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up CampaignRepository.Create return parameters for the expectation previously defined by the When method
func (e *CampaignRepositoryMockCreateExpectation) Then(cp1 *model.Campaign, err error) *CampaignRepositoryMock {
	e.results = &CampaignRepositoryMockCreateResults{cp1, err}
	return e.mock
}

// Times sets number of times CampaignRepository.Create should be invoked
func (mmCreate *mCampaignRepositoryMockCreate) Times(n uint64) *mCampaignRepositoryMockCreate {
	if n == 0 {
		mmCreate.mock.t.Fatalf("Times of CampaignRepositoryMock.Create mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreate.expectedInvocations, n)
	mmCreate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreate
}

func (mmCreate *mCampaignRepositoryMockCreate) invocationsDone() bool {
	if len(mmCreate.expectations) == 0 && mmCreate.defaultExpectation == nil && mmCreate.mock.funcCreate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreate.mock.afterCreateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Create implements mm_repository.CampaignRepository
func (mmCreate *CampaignRepositoryMock) Create(ctx context.Context, campaign *model.Campaign) (cp1 *model.Campaign, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	mmCreate.t.Helper()

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, campaign)
	}

	mm_params := CampaignRepositoryMockCreateParams{ctx, campaign}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

		mm_got := CampaignRepositoryMockCreateParams{ctx, campaign}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreate.t.Errorf("CampaignRepositoryMock.Create got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.campaign != nil && !minimock.Equal(*mm_want_ptrs.campaign, mm_got.campaign) {
				mmCreate.t.Errorf("CampaignRepositoryMock.Create got unexpected parameter campaign, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originCampaign, *mm_want_ptrs.campaign, mm_got.campaign, minimock.Diff(*mm_want_ptrs.campaign, mm_got.campaign))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("CampaignRepositoryMock.Create got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreate.CreateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the CampaignRepositoryMock.Create")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, campaign)
	}
	mmCreate.t.Fatalf("Unexpected call to CampaignRepositoryMock.Create. %v %v", ctx, campaign)
	return
}

// CreateAfterCounter returns a count of finished CampaignRepositoryMock.Create invocations
func (mmCreate *CampaignRepositoryMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of CampaignRepositoryMock.Create invocations
func (mmCreate *CampaignRepositoryMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to CampaignRepositoryMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mCampaignRepositoryMockCreate) Calls() []*CampaignRepositoryMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*CampaignRepositoryMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *CampaignRepositoryMock) MinimockCreateDone() bool {
	if m.CreateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMock.invocationsDone()
}

// MinimockCreateInspect logs each unmet expectation
func (m *CampaignRepositoryMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CampaignRepositoryMock.Create at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateCounter := mm_atomic.LoadUint64(&m.afterCreateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && afterCreateCounter < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CampaignRepositoryMock.Create at\n%s", m.CreateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CampaignRepositoryMock.Create at\n%s with params: %#v", m.CreateMock.defaultExpectation.expectationOrigins.origin, *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && afterCreateCounter < 1 {
		m.t.Errorf("Expected call to CampaignRepositoryMock.Create at\n%s", m.funcCreateOrigin)
	}

	if !m.CreateMock.invocationsDone() && afterCreateCounter > 0 {
		m.t.Errorf("Expected %d calls to CampaignRepositoryMock.Create at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMock.expectedInvocations), m.CreateMock.expectedInvocationsOrigin, afterCreateCounter)
	}
}

type mCampaignRepositoryMockDelete struct {
	optional           bool
	mock               *CampaignRepositoryMock
	defaultExpectation *CampaignRepositoryMockDeleteExpectation
	expectations       []*CampaignRepositoryMockDeleteExpectation

	callArgs []*CampaignRepositoryMockDeleteParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CampaignRepositoryMockDeleteExpectation specifies expectation struct of the CampaignRepository.Delete
type CampaignRepositoryMockDeleteExpectation struct {
	mock               *CampaignRepositoryMock
	params             *CampaignRepositoryMockDeleteParams
	paramPtrs          *CampaignRepositoryMockDeleteParamPtrs
	expectationOrigins CampaignRepositoryMockDeleteExpectationOrigins
	results            *CampaignRepositoryMockDeleteResults
	returnOrigin       string
	Counter            uint64
}

// CampaignRepositoryMockDeleteParams contains parameters of the CampaignRepository.Delete
type CampaignRepositoryMockDeleteParams struct {
	ctx          context.Context
	advertiserID string
	campaignID   string
}

// CampaignRepositoryMockDeleteParamPtrs contains pointers to parameters of the CampaignRepository.Delete
type CampaignRepositoryMockDeleteParamPtrs struct {
	ctx          *context.Context
	advertiserID *string
	campaignID   *string
}

// CampaignRepositoryMockDeleteResults contains results of the CampaignRepository.Delete
type CampaignRepositoryMockDeleteResults struct {
	err error
}

// CampaignRepositoryMockDeleteOrigins contains origins of expectations of the CampaignRepository.Delete
type CampaignRepositoryMockDeleteExpectationOrigins struct {
	origin             string
	originCtx          string
	originAdvertiserID string
	originCampaignID   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDelete *mCampaignRepositoryMockDelete) Optional() *mCampaignRepositoryMockDelete {
	mmDelete.optional = true
	return mmDelete
}

// Expect sets up expected params for CampaignRepository.Delete
func (mmDelete *mCampaignRepositoryMockDelete) Expect(ctx context.Context, advertiserID string, campaignID string) *mCampaignRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("CampaignRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &CampaignRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.paramPtrs != nil {
		mmDelete.mock.t.Fatalf("CampaignRepositoryMock.Delete mock is already set by ExpectParams functions")
	}

	mmDelete.defaultExpectation.params = &CampaignRepositoryMockDeleteParams{ctx, advertiserID, campaignID}
	mmDelete.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// ExpectCtxParam1 sets up expected param ctx for CampaignRepository.Delete
func (mmDelete *mCampaignRepositoryMockDelete) ExpectCtxParam1(ctx context.Context) *mCampaignRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("CampaignRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &CampaignRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("CampaignRepositoryMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &CampaignRepositoryMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.ctx = &ctx
	mmDelete.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDelete
}

// ExpectAdvertiserIDParam2 sets up expected param advertiserID for CampaignRepository.Delete
func (mmDelete *mCampaignRepositoryMockDelete) ExpectAdvertiserIDParam2(advertiserID string) *mCampaignRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("CampaignRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &CampaignRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("CampaignRepositoryMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &CampaignRepositoryMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.advertiserID = &advertiserID
	mmDelete.defaultExpectation.expectationOrigins.originAdvertiserID = minimock.CallerInfo(1)

	return mmDelete
}

// ExpectCampaignIDParam3 sets up expected param campaignID for CampaignRepository.Delete
func (mmDelete *mCampaignRepositoryMockDelete) ExpectCampaignIDParam3(campaignID string) *mCampaignRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("CampaignRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &CampaignRepositoryMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("CampaignRepositoryMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &CampaignRepositoryMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.campaignID = &campaignID
	mmDelete.defaultExpectation.expectationOrigins.originCampaignID = minimock.CallerInfo(1)

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the CampaignRepository.Delete
func (mmDelete *mCampaignRepositoryMockDelete) Inspect(f func(ctx context.Context, advertiserID string, campaignID string)) *mCampaignRepositoryMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for CampaignRepositoryMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by CampaignRepository.Delete
func (mmDelete *mCampaignRepositoryMockDelete) Return(err error) *CampaignRepositoryMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("CampaignRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &CampaignRepositoryMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &CampaignRepositoryMockDeleteResults{err}
	mmDelete.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// Set uses given function f to mock the CampaignRepository.Delete method
func (mmDelete *mCampaignRepositoryMockDelete) Set(f func(ctx context.Context, advertiserID string, campaignID string) (err error)) *CampaignRepositoryMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the CampaignRepository.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the CampaignRepository.Delete method")
	}

	mmDelete.mock.funcDelete = f
	mmDelete.mock.funcDeleteOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// When sets expectation for the CampaignRepository.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mCampaignRepositoryMockDelete) When(ctx context.Context, advertiserID string, campaignID string) *CampaignRepositoryMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("CampaignRepositoryMock.Delete mock is already set by Set")
	}

	expectation := &CampaignRepositoryMockDeleteExpectation{
		mock:               mmDelete.mock,
		params:             &CampaignRepositoryMockDeleteParams{ctx, advertiserID, campaignID},
		expectationOrigins: CampaignRepositoryMockDeleteExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up CampaignRepository.Delete return parameters for the expectation previously defined by the When method
func (e *CampaignRepositoryMockDeleteExpectation) Then(err error) *CampaignRepositoryMock {
	e.results = &CampaignRepositoryMockDeleteResults{err}
	return e.mock
}

// Times sets number of times CampaignRepository.Delete should be invoked
func (mmDelete *mCampaignRepositoryMockDelete) Times(n uint64) *mCampaignRepositoryMockDelete {
	if n == 0 {
		mmDelete.mock.t.Fatalf("Times of CampaignRepositoryMock.Delete mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDelete.expectedInvocations, n)
	mmDelete.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDelete
}

func (mmDelete *mCampaignRepositoryMockDelete) invocationsDone() bool {
	if len(mmDelete.expectations) == 0 && mmDelete.defaultExpectation == nil && mmDelete.mock.funcDelete == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDelete.mock.afterDeleteCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDelete.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Delete implements mm_repository.CampaignRepository
func (mmDelete *CampaignRepositoryMock) Delete(ctx context.Context, advertiserID string, campaignID string) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	mmDelete.t.Helper()

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, advertiserID, campaignID)
	}

	mm_params := CampaignRepositoryMockDeleteParams{ctx, advertiserID, campaignID}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, &mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_want_ptrs := mmDelete.DeleteMock.defaultExpectation.paramPtrs

		mm_got := CampaignRepositoryMockDeleteParams{ctx, advertiserID, campaignID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDelete.t.Errorf("CampaignRepositoryMock.Delete got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.advertiserID != nil && !minimock.Equal(*mm_want_ptrs.advertiserID, mm_got.advertiserID) {
				mmDelete.t.Errorf("CampaignRepositoryMock.Delete got unexpected parameter advertiserID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originAdvertiserID, *mm_want_ptrs.advertiserID, mm_got.advertiserID, minimock.Diff(*mm_want_ptrs.advertiserID, mm_got.advertiserID))
			}

			if mm_want_ptrs.campaignID != nil && !minimock.Equal(*mm_want_ptrs.campaignID, mm_got.campaignID) {
				mmDelete.t.Errorf("CampaignRepositoryMock.Delete got unexpected parameter campaignID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originCampaignID, *mm_want_ptrs.campaignID, mm_got.campaignID, minimock.Diff(*mm_want_ptrs.campaignID, mm_got.campaignID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("CampaignRepositoryMock.Delete got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDelete.DeleteMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the CampaignRepositoryMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, advertiserID, campaignID)
	}
	mmDelete.t.Fatalf("Unexpected call to CampaignRepositoryMock.Delete. %v %v %v", ctx, advertiserID, campaignID)
	return
}

// DeleteAfterCounter returns a count of finished CampaignRepositoryMock.Delete invocations
func (mmDelete *CampaignRepositoryMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of CampaignRepositoryMock.Delete invocations
func (mmDelete *CampaignRepositoryMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to CampaignRepositoryMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mCampaignRepositoryMockDelete) Calls() []*CampaignRepositoryMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*CampaignRepositoryMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *CampaignRepositoryMock) MinimockDeleteDone() bool {
	if m.DeleteMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteMock.invocationsDone()
}

// MinimockDeleteInspect logs each unmet expectation
func (m *CampaignRepositoryMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CampaignRepositoryMock.Delete at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteCounter := mm_atomic.LoadUint64(&m.afterDeleteCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && afterDeleteCounter < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CampaignRepositoryMock.Delete at\n%s", m.DeleteMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CampaignRepositoryMock.Delete at\n%s with params: %#v", m.DeleteMock.defaultExpectation.expectationOrigins.origin, *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && afterDeleteCounter < 1 {
		m.t.Errorf("Expected call to CampaignRepositoryMock.Delete at\n%s", m.funcDeleteOrigin)
	}

	if !m.DeleteMock.invocationsDone() && afterDeleteCounter > 0 {
		m.t.Errorf("Expected %d calls to CampaignRepositoryMock.Delete at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteMock.expectedInvocations), m.DeleteMock.expectedInvocationsOrigin, afterDeleteCounter)
	}
}

type mCampaignRepositoryMockGet struct {
	optional           bool
	mock               *CampaignRepositoryMock
	defaultExpectation *CampaignRepositoryMockGetExpectation
	expectations       []*CampaignRepositoryMockGetExpectation

	callArgs []*CampaignRepositoryMockGetParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CampaignRepositoryMockGetExpectation specifies expectation struct of the CampaignRepository.Get
type CampaignRepositoryMockGetExpectation struct {
	mock               *CampaignRepositoryMock
	params             *CampaignRepositoryMockGetParams
	paramPtrs          *CampaignRepositoryMockGetParamPtrs
	expectationOrigins CampaignRepositoryMockGetExpectationOrigins
	results            *CampaignRepositoryMockGetResults
	returnOrigin       string
	Counter            uint64
}

// CampaignRepositoryMockGetParams contains parameters of the CampaignRepository.Get
type CampaignRepositoryMockGetParams struct {
	ctx          context.Context
	advertiserID string
	campaignID   string
}

// CampaignRepositoryMockGetParamPtrs contains pointers to parameters of the CampaignRepository.Get
type CampaignRepositoryMockGetParamPtrs struct {
	ctx          *context.Context
	advertiserID *string
	campaignID   *string
}

// CampaignRepositoryMockGetResults contains results of the CampaignRepository.Get
type CampaignRepositoryMockGetResults struct {
	cp1 *model.Campaign
	err error
}

// CampaignRepositoryMockGetOrigins contains origins of expectations of the CampaignRepository.Get
type CampaignRepositoryMockGetExpectationOrigins struct {
	origin             string
	originCtx          string
	originAdvertiserID string
	originCampaignID   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGet *mCampaignRepositoryMockGet) Optional() *mCampaignRepositoryMockGet {
	mmGet.optional = true
	return mmGet
}

// Expect sets up expected params for CampaignRepository.Get
func (mmGet *mCampaignRepositoryMockGet) Expect(ctx context.Context, advertiserID string, campaignID string) *mCampaignRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("CampaignRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &CampaignRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.paramPtrs != nil {
		mmGet.mock.t.Fatalf("CampaignRepositoryMock.Get mock is already set by ExpectParams functions")
	}

	mmGet.defaultExpectation.params = &CampaignRepositoryMockGetParams{ctx, advertiserID, campaignID}
	mmGet.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// ExpectCtxParam1 sets up expected param ctx for CampaignRepository.Get
func (mmGet *mCampaignRepositoryMockGet) ExpectCtxParam1(ctx context.Context) *mCampaignRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("CampaignRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &CampaignRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("CampaignRepositoryMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &CampaignRepositoryMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.ctx = &ctx
	mmGet.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGet
}

// ExpectAdvertiserIDParam2 sets up expected param advertiserID for CampaignRepository.Get
func (mmGet *mCampaignRepositoryMockGet) ExpectAdvertiserIDParam2(advertiserID string) *mCampaignRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("CampaignRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &CampaignRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("CampaignRepositoryMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &CampaignRepositoryMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.advertiserID = &advertiserID
	mmGet.defaultExpectation.expectationOrigins.originAdvertiserID = minimock.CallerInfo(1)

	return mmGet
}

// ExpectCampaignIDParam3 sets up expected param campaignID for CampaignRepository.Get
func (mmGet *mCampaignRepositoryMockGet) ExpectCampaignIDParam3(campaignID string) *mCampaignRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("CampaignRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &CampaignRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("CampaignRepositoryMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &CampaignRepositoryMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.campaignID = &campaignID
	mmGet.defaultExpectation.expectationOrigins.originCampaignID = minimock.CallerInfo(1)

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the CampaignRepository.Get
func (mmGet *mCampaignRepositoryMockGet) Inspect(f func(ctx context.Context, advertiserID string, campaignID string)) *mCampaignRepositoryMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for CampaignRepositoryMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by CampaignRepository.Get
func (mmGet *mCampaignRepositoryMockGet) Return(cp1 *model.Campaign, err error) *CampaignRepositoryMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("CampaignRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &CampaignRepositoryMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &CampaignRepositoryMockGetResults{cp1, err}
	mmGet.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// Set uses given function f to mock the CampaignRepository.Get method
func (mmGet *mCampaignRepositoryMockGet) Set(f func(ctx context.Context, advertiserID string, campaignID string) (cp1 *model.Campaign, err error)) *CampaignRepositoryMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the CampaignRepository.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the CampaignRepository.Get method")
	}

	mmGet.mock.funcGet = f
	mmGet.mock.funcGetOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// When sets expectation for the CampaignRepository.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mCampaignRepositoryMockGet) When(ctx context.Context, advertiserID string, campaignID string) *CampaignRepositoryMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("CampaignRepositoryMock.Get mock is already set by Set")
	}

	expectation := &CampaignRepositoryMockGetExpectation{
		mock:               mmGet.mock,
		params:             &CampaignRepositoryMockGetParams{ctx, advertiserID, campaignID},
		expectationOrigins: CampaignRepositoryMockGetExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up CampaignRepository.Get return parameters for the expectation previously defined by the When method
func (e *CampaignRepositoryMockGetExpectation) Then(cp1 *model.Campaign, err error) *CampaignRepositoryMock {
	e.results = &CampaignRepositoryMockGetResults{cp1, err}
	return e.mock
}

// Times sets number of times CampaignRepository.Get should be invoked
func (mmGet *mCampaignRepositoryMockGet) Times(n uint64) *mCampaignRepositoryMockGet {
	if n == 0 {
		mmGet.mock.t.Fatalf("Times of CampaignRepositoryMock.Get mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGet.expectedInvocations, n)
	mmGet.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGet
}

func (mmGet *mCampaignRepositoryMockGet) invocationsDone() bool {
	if len(mmGet.expectations) == 0 && mmGet.defaultExpectation == nil && mmGet.mock.funcGet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGet.mock.afterGetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Get implements mm_repository.CampaignRepository
func (mmGet *CampaignRepositoryMock) Get(ctx context.Context, advertiserID string, campaignID string) (cp1 *model.Campaign, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	mmGet.t.Helper()

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(ctx, advertiserID, campaignID)
	}

	mm_params := CampaignRepositoryMockGetParams{ctx, advertiserID, campaignID}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, &mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_want_ptrs := mmGet.GetMock.defaultExpectation.paramPtrs

		mm_got := CampaignRepositoryMockGetParams{ctx, advertiserID, campaignID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGet.t.Errorf("CampaignRepositoryMock.Get got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.advertiserID != nil && !minimock.Equal(*mm_want_ptrs.advertiserID, mm_got.advertiserID) {
				mmGet.t.Errorf("CampaignRepositoryMock.Get got unexpected parameter advertiserID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originAdvertiserID, *mm_want_ptrs.advertiserID, mm_got.advertiserID, minimock.Diff(*mm_want_ptrs.advertiserID, mm_got.advertiserID))
			}

			if mm_want_ptrs.campaignID != nil && !minimock.Equal(*mm_want_ptrs.campaignID, mm_got.campaignID) {
				mmGet.t.Errorf("CampaignRepositoryMock.Get got unexpected parameter campaignID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originCampaignID, *mm_want_ptrs.campaignID, mm_got.campaignID, minimock.Diff(*mm_want_ptrs.campaignID, mm_got.campaignID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("CampaignRepositoryMock.Get got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGet.GetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the CampaignRepositoryMock.Get")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(ctx, advertiserID, campaignID)
	}
	mmGet.t.Fatalf("Unexpected call to CampaignRepositoryMock.Get. %v %v %v", ctx, advertiserID, campaignID)
	return
}

// GetAfterCounter returns a count of finished CampaignRepositoryMock.Get invocations
func (mmGet *CampaignRepositoryMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of CampaignRepositoryMock.Get invocations
func (mmGet *CampaignRepositoryMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to CampaignRepositoryMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mCampaignRepositoryMockGet) Calls() []*CampaignRepositoryMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*CampaignRepositoryMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *CampaignRepositoryMock) MinimockGetDone() bool {
	if m.GetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetMock.invocationsDone()
}

// MinimockGetInspect logs each unmet expectation
func (m *CampaignRepositoryMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CampaignRepositoryMock.Get at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCounter := mm_atomic.LoadUint64(&m.afterGetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && afterGetCounter < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CampaignRepositoryMock.Get at\n%s", m.GetMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CampaignRepositoryMock.Get at\n%s with params: %#v", m.GetMock.defaultExpectation.expectationOrigins.origin, *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && afterGetCounter < 1 {
		m.t.Errorf("Expected call to CampaignRepositoryMock.Get at\n%s", m.funcGetOrigin)
	}

	if !m.GetMock.invocationsDone() && afterGetCounter > 0 {
		m.t.Errorf("Expected %d calls to CampaignRepositoryMock.Get at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetMock.expectedInvocations), m.GetMock.expectedInvocationsOrigin, afterGetCounter)
	}
}

type mCampaignRepositoryMockGetByCampaignID struct {
	optional           bool
	mock               *CampaignRepositoryMock
	defaultExpectation *CampaignRepositoryMockGetByCampaignIDExpectation
	expectations       []*CampaignRepositoryMockGetByCampaignIDExpectation

	callArgs []*CampaignRepositoryMockGetByCampaignIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CampaignRepositoryMockGetByCampaignIDExpectation specifies expectation struct of the CampaignRepository.GetByCampaignID
type CampaignRepositoryMockGetByCampaignIDExpectation struct {
	mock               *CampaignRepositoryMock
	params             *CampaignRepositoryMockGetByCampaignIDParams
	paramPtrs          *CampaignRepositoryMockGetByCampaignIDParamPtrs
	expectationOrigins CampaignRepositoryMockGetByCampaignIDExpectationOrigins
	results            *CampaignRepositoryMockGetByCampaignIDResults
	returnOrigin       string
	Counter            uint64
}

// CampaignRepositoryMockGetByCampaignIDParams contains parameters of the CampaignRepository.GetByCampaignID
type CampaignRepositoryMockGetByCampaignIDParams struct {
	ctx        context.Context
	campaignID string
}

// CampaignRepositoryMockGetByCampaignIDParamPtrs contains pointers to parameters of the CampaignRepository.GetByCampaignID
type CampaignRepositoryMockGetByCampaignIDParamPtrs struct {
	ctx        *context.Context
	campaignID *string
}

// CampaignRepositoryMockGetByCampaignIDResults contains results of the CampaignRepository.GetByCampaignID
type CampaignRepositoryMockGetByCampaignIDResults struct {
	cp1 *model.Campaign
	err error
}

// CampaignRepositoryMockGetByCampaignIDOrigins contains origins of expectations of the CampaignRepository.GetByCampaignID
type CampaignRepositoryMockGetByCampaignIDExpectationOrigins struct {
	origin           string
	originCtx        string
	originCampaignID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetByCampaignID *mCampaignRepositoryMockGetByCampaignID) Optional() *mCampaignRepositoryMockGetByCampaignID {
	mmGetByCampaignID.optional = true
	return mmGetByCampaignID
}

// Expect sets up expected params for CampaignRepository.GetByCampaignID
func (mmGetByCampaignID *mCampaignRepositoryMockGetByCampaignID) Expect(ctx context.Context, campaignID string) *mCampaignRepositoryMockGetByCampaignID {
	if mmGetByCampaignID.mock.funcGetByCampaignID != nil {
		mmGetByCampaignID.mock.t.Fatalf("CampaignRepositoryMock.GetByCampaignID mock is already set by Set")
	}

	if mmGetByCampaignID.defaultExpectation == nil {
		mmGetByCampaignID.defaultExpectation = &CampaignRepositoryMockGetByCampaignIDExpectation{}
	}

	if mmGetByCampaignID.defaultExpectation.paramPtrs != nil {
		mmGetByCampaignID.mock.t.Fatalf("CampaignRepositoryMock.GetByCampaignID mock is already set by ExpectParams functions")
	}

	mmGetByCampaignID.defaultExpectation.params = &CampaignRepositoryMockGetByCampaignIDParams{ctx, campaignID}
	mmGetByCampaignID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetByCampaignID.expectations {
		if minimock.Equal(e.params, mmGetByCampaignID.defaultExpectation.params) {
			mmGetByCampaignID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetByCampaignID.defaultExpectation.params)
		}
	}

	return mmGetByCampaignID
}

// ExpectCtxParam1 sets up expected param ctx for CampaignRepository.GetByCampaignID
func (mmGetByCampaignID *mCampaignRepositoryMockGetByCampaignID) ExpectCtxParam1(ctx context.Context) *mCampaignRepositoryMockGetByCampaignID {
	if mmGetByCampaignID.mock.funcGetByCampaignID != nil {
		mmGetByCampaignID.mock.t.Fatalf("CampaignRepositoryMock.GetByCampaignID mock is already set by Set")
	}

	if mmGetByCampaignID.defaultExpectation == nil {
		mmGetByCampaignID.defaultExpectation = &CampaignRepositoryMockGetByCampaignIDExpectation{}
	}

	if mmGetByCampaignID.defaultExpectation.params != nil {
		mmGetByCampaignID.mock.t.Fatalf("CampaignRepositoryMock.GetByCampaignID mock is already set by Expect")
	}

	if mmGetByCampaignID.defaultExpectation.paramPtrs == nil {
		mmGetByCampaignID.defaultExpectation.paramPtrs = &CampaignRepositoryMockGetByCampaignIDParamPtrs{}
	}
	mmGetByCampaignID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetByCampaignID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetByCampaignID
}

// ExpectCampaignIDParam2 sets up expected param campaignID for CampaignRepository.GetByCampaignID
func (mmGetByCampaignID *mCampaignRepositoryMockGetByCampaignID) ExpectCampaignIDParam2(campaignID string) *mCampaignRepositoryMockGetByCampaignID {
	if mmGetByCampaignID.mock.funcGetByCampaignID != nil {
		mmGetByCampaignID.mock.t.Fatalf("CampaignRepositoryMock.GetByCampaignID mock is already set by Set")
	}

	if mmGetByCampaignID.defaultExpectation == nil {
		mmGetByCampaignID.defaultExpectation = &CampaignRepositoryMockGetByCampaignIDExpectation{}
	}

	if mmGetByCampaignID.defaultExpectation.params != nil {
		mmGetByCampaignID.mock.t.Fatalf("CampaignRepositoryMock.GetByCampaignID mock is already set by Expect")
	}

	if mmGetByCampaignID.defaultExpectation.paramPtrs == nil {
		mmGetByCampaignID.defaultExpectation.paramPtrs = &CampaignRepositoryMockGetByCampaignIDParamPtrs{}
	}
	mmGetByCampaignID.defaultExpectation.paramPtrs.campaignID = &campaignID
	mmGetByCampaignID.defaultExpectation.expectationOrigins.originCampaignID = minimock.CallerInfo(1)

	return mmGetByCampaignID
}

// Inspect accepts an inspector function that has same arguments as the CampaignRepository.GetByCampaignID
func (mmGetByCampaignID *mCampaignRepositoryMockGetByCampaignID) Inspect(f func(ctx context.Context, campaignID string)) *mCampaignRepositoryMockGetByCampaignID {
	if mmGetByCampaignID.mock.inspectFuncGetByCampaignID != nil {
		mmGetByCampaignID.mock.t.Fatalf("Inspect function is already set for CampaignRepositoryMock.GetByCampaignID")
	}

	mmGetByCampaignID.mock.inspectFuncGetByCampaignID = f

	return mmGetByCampaignID
}

// Return sets up results that will be returned by CampaignRepository.GetByCampaignID
func (mmGetByCampaignID *mCampaignRepositoryMockGetByCampaignID) Return(cp1 *model.Campaign, err error) *CampaignRepositoryMock {
	if mmGetByCampaignID.mock.funcGetByCampaignID != nil {
		mmGetByCampaignID.mock.t.Fatalf("CampaignRepositoryMock.GetByCampaignID mock is already set by Set")
	}

	if mmGetByCampaignID.defaultExpectation == nil {
		mmGetByCampaignID.defaultExpectation = &CampaignRepositoryMockGetByCampaignIDExpectation{mock: mmGetByCampaignID.mock}
	}
	mmGetByCampaignID.defaultExpectation.results = &CampaignRepositoryMockGetByCampaignIDResults{cp1, err}
	mmGetByCampaignID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetByCampaignID.mock
}

// Set uses given function f to mock the CampaignRepository.GetByCampaignID method
func (mmGetByCampaignID *mCampaignRepositoryMockGetByCampaignID) Set(f func(ctx context.Context, campaignID string) (cp1 *model.Campaign, err error)) *CampaignRepositoryMock {
	if mmGetByCampaignID.defaultExpectation != nil {
		mmGetByCampaignID.mock.t.Fatalf("Default expectation is already set for the CampaignRepository.GetByCampaignID method")
	}

	if len(mmGetByCampaignID.expectations) > 0 {
		mmGetByCampaignID.mock.t.Fatalf("Some expectations are already set for the CampaignRepository.GetByCampaignID method")
	}

	mmGetByCampaignID.mock.funcGetByCampaignID = f
	mmGetByCampaignID.mock.funcGetByCampaignIDOrigin = minimock.CallerInfo(1)
	return mmGetByCampaignID.mock
}

// When sets expectation for the CampaignRepository.GetByCampaignID which will trigger the result defined by the following
// Then helper
func (mmGetByCampaignID *mCampaignRepositoryMockGetByCampaignID) When(ctx context.Context, campaignID string) *CampaignRepositoryMockGetByCampaignIDExpectation {
	if mmGetByCampaignID.mock.funcGetByCampaignID != nil {
		mmGetByCampaignID.mock.t.Fatalf("CampaignRepositoryMock.GetByCampaignID mock is already set by Set")
	}

	expectation := &CampaignRepositoryMockGetByCampaignIDExpectation{
		mock:               mmGetByCampaignID.mock,
		params:             &CampaignRepositoryMockGetByCampaignIDParams{ctx, campaignID},
		expectationOrigins: CampaignRepositoryMockGetByCampaignIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetByCampaignID.expectations = append(mmGetByCampaignID.expectations, expectation)
	return expectation
}

// Then sets up CampaignRepository.GetByCampaignID return parameters for the expectation previously defined by the When method
func (e *CampaignRepositoryMockGetByCampaignIDExpectation) Then(cp1 *model.Campaign, err error) *CampaignRepositoryMock {
	e.results = &CampaignRepositoryMockGetByCampaignIDResults{cp1, err}
	return e.mock
}

// Times sets number of times CampaignRepository.GetByCampaignID should be invoked
func (mmGetByCampaignID *mCampaignRepositoryMockGetByCampaignID) Times(n uint64) *mCampaignRepositoryMockGetByCampaignID {
	if n == 0 {
		mmGetByCampaignID.mock.t.Fatalf("Times of CampaignRepositoryMock.GetByCampaignID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetByCampaignID.expectedInvocations, n)
	mmGetByCampaignID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetByCampaignID
}

func (mmGetByCampaignID *mCampaignRepositoryMockGetByCampaignID) invocationsDone() bool {
	if len(mmGetByCampaignID.expectations) == 0 && mmGetByCampaignID.defaultExpectation == nil && mmGetByCampaignID.mock.funcGetByCampaignID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetByCampaignID.mock.afterGetByCampaignIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetByCampaignID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetByCampaignID implements mm_repository.CampaignRepository
func (mmGetByCampaignID *CampaignRepositoryMock) GetByCampaignID(ctx context.Context, campaignID string) (cp1 *model.Campaign, err error) {
	mm_atomic.AddUint64(&mmGetByCampaignID.beforeGetByCampaignIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetByCampaignID.afterGetByCampaignIDCounter, 1)

	mmGetByCampaignID.t.Helper()

	if mmGetByCampaignID.inspectFuncGetByCampaignID != nil {
		mmGetByCampaignID.inspectFuncGetByCampaignID(ctx, campaignID)
	}

	mm_params := CampaignRepositoryMockGetByCampaignIDParams{ctx, campaignID}

	// Record call args
	mmGetByCampaignID.GetByCampaignIDMock.mutex.Lock()
	mmGetByCampaignID.GetByCampaignIDMock.callArgs = append(mmGetByCampaignID.GetByCampaignIDMock.callArgs, &mm_params)
	mmGetByCampaignID.GetByCampaignIDMock.mutex.Unlock()

	for _, e := range mmGetByCampaignID.GetByCampaignIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmGetByCampaignID.GetByCampaignIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetByCampaignID.GetByCampaignIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetByCampaignID.GetByCampaignIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetByCampaignID.GetByCampaignIDMock.defaultExpectation.paramPtrs

		mm_got := CampaignRepositoryMockGetByCampaignIDParams{ctx, campaignID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetByCampaignID.t.Errorf("CampaignRepositoryMock.GetByCampaignID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetByCampaignID.GetByCampaignIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.campaignID != nil && !minimock.Equal(*mm_want_ptrs.campaignID, mm_got.campaignID) {
				mmGetByCampaignID.t.Errorf("CampaignRepositoryMock.GetByCampaignID got unexpected parameter campaignID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetByCampaignID.GetByCampaignIDMock.defaultExpectation.expectationOrigins.originCampaignID, *mm_want_ptrs.campaignID, mm_got.campaignID, minimock.Diff(*mm_want_ptrs.campaignID, mm_got.campaignID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetByCampaignID.t.Errorf("CampaignRepositoryMock.GetByCampaignID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetByCampaignID.GetByCampaignIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetByCampaignID.GetByCampaignIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetByCampaignID.t.Fatal("No results are set for the CampaignRepositoryMock.GetByCampaignID")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmGetByCampaignID.funcGetByCampaignID != nil {
		return mmGetByCampaignID.funcGetByCampaignID(ctx, campaignID)
	}
	mmGetByCampaignID.t.Fatalf("Unexpected call to CampaignRepositoryMock.GetByCampaignID. %v %v", ctx, campaignID)
	return
}

// GetByCampaignIDAfterCounter returns a count of finished CampaignRepositoryMock.GetByCampaignID invocations
func (mmGetByCampaignID *CampaignRepositoryMock) GetByCampaignIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByCampaignID.afterGetByCampaignIDCounter)
}

// GetByCampaignIDBeforeCounter returns a count of CampaignRepositoryMock.GetByCampaignID invocations
func (mmGetByCampaignID *CampaignRepositoryMock) GetByCampaignIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetByCampaignID.beforeGetByCampaignIDCounter)
}

// Calls returns a list of arguments used in each call to CampaignRepositoryMock.GetByCampaignID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetByCampaignID *mCampaignRepositoryMockGetByCampaignID) Calls() []*CampaignRepositoryMockGetByCampaignIDParams {
	mmGetByCampaignID.mutex.RLock()

	argCopy := make([]*CampaignRepositoryMockGetByCampaignIDParams, len(mmGetByCampaignID.callArgs))
	copy(argCopy, mmGetByCampaignID.callArgs)

	mmGetByCampaignID.mutex.RUnlock()

	return argCopy
}

// MinimockGetByCampaignIDDone returns true if the count of the GetByCampaignID invocations corresponds
// the number of defined expectations
func (m *CampaignRepositoryMock) MinimockGetByCampaignIDDone() bool {
	if m.GetByCampaignIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetByCampaignIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetByCampaignIDMock.invocationsDone()
}

// MinimockGetByCampaignIDInspect logs each unmet expectation
func (m *CampaignRepositoryMock) MinimockGetByCampaignIDInspect() {
	for _, e := range m.GetByCampaignIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CampaignRepositoryMock.GetByCampaignID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetByCampaignIDCounter := mm_atomic.LoadUint64(&m.afterGetByCampaignIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetByCampaignIDMock.defaultExpectation != nil && afterGetByCampaignIDCounter < 1 {
		if m.GetByCampaignIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CampaignRepositoryMock.GetByCampaignID at\n%s", m.GetByCampaignIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CampaignRepositoryMock.GetByCampaignID at\n%s with params: %#v", m.GetByCampaignIDMock.defaultExpectation.expectationOrigins.origin, *m.GetByCampaignIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetByCampaignID != nil && afterGetByCampaignIDCounter < 1 {
		m.t.Errorf("Expected call to CampaignRepositoryMock.GetByCampaignID at\n%s", m.funcGetByCampaignIDOrigin)
	}

	if !m.GetByCampaignIDMock.invocationsDone() && afterGetByCampaignIDCounter > 0 {
		m.t.Errorf("Expected %d calls to CampaignRepositoryMock.GetByCampaignID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetByCampaignIDMock.expectedInvocations), m.GetByCampaignIDMock.expectedInvocationsOrigin, afterGetByCampaignIDCounter)
	}
}

type mCampaignRepositoryMockList struct {
	optional           bool
	mock               *CampaignRepositoryMock
	defaultExpectation *CampaignRepositoryMockListExpectation
	expectations       []*CampaignRepositoryMockListExpectation

	callArgs []*CampaignRepositoryMockListParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CampaignRepositoryMockListExpectation specifies expectation struct of the CampaignRepository.List
type CampaignRepositoryMockListExpectation struct {
	mock               *CampaignRepositoryMock
	params             *CampaignRepositoryMockListParams
	paramPtrs          *CampaignRepositoryMockListParamPtrs
	expectationOrigins CampaignRepositoryMockListExpectationOrigins
	results            *CampaignRepositoryMockListResults
	returnOrigin       string
	Counter            uint64
}

// CampaignRepositoryMockListParams contains parameters of the CampaignRepository.List
type CampaignRepositoryMockListParams struct {
	ctx          context.Context
	advertiserID string
	page         int
	size         int
}

// CampaignRepositoryMockListParamPtrs contains pointers to parameters of the CampaignRepository.List
type CampaignRepositoryMockListParamPtrs struct {
	ctx          *context.Context
	advertiserID *string
	page         *int
	size         *int
}

// CampaignRepositoryMockListResults contains results of the CampaignRepository.List
type CampaignRepositoryMockListResults struct {
	cpa1 []*model.Campaign
	err  error
}

// CampaignRepositoryMockListOrigins contains origins of expectations of the CampaignRepository.List
type CampaignRepositoryMockListExpectationOrigins struct {
	origin             string
	originCtx          string
	originAdvertiserID string
	originPage         string
	originSize         string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmList *mCampaignRepositoryMockList) Optional() *mCampaignRepositoryMockList {
	mmList.optional = true
	return mmList
}

// Expect sets up expected params for CampaignRepository.List
func (mmList *mCampaignRepositoryMockList) Expect(ctx context.Context, advertiserID string, page int, size int) *mCampaignRepositoryMockList {
	if mmList.mock.funcList != nil {
		mmList.mock.t.Fatalf("CampaignRepositoryMock.List mock is already set by Set")
	}

	if mmList.defaultExpectation == nil {
		mmList.defaultExpectation = &CampaignRepositoryMockListExpectation{}
	}

	if mmList.defaultExpectation.paramPtrs != nil {
		mmList.mock.t.Fatalf("CampaignRepositoryMock.List mock is already set by ExpectParams functions")
	}

	mmList.defaultExpectation.params = &CampaignRepositoryMockListParams{ctx, advertiserID, page, size}
	mmList.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmList.expectations {
		if minimock.Equal(e.params, mmList.defaultExpectation.params) {
			mmList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmList.defaultExpectation.params)
		}
	}

	return mmList
}

// ExpectCtxParam1 sets up expected param ctx for CampaignRepository.List
func (mmList *mCampaignRepositoryMockList) ExpectCtxParam1(ctx context.Context) *mCampaignRepositoryMockList {
	if mmList.mock.funcList != nil {
		mmList.mock.t.Fatalf("CampaignRepositoryMock.List mock is already set by Set")
	}

	if mmList.defaultExpectation == nil {
		mmList.defaultExpectation = &CampaignRepositoryMockListExpectation{}
	}

	if mmList.defaultExpectation.params != nil {
		mmList.mock.t.Fatalf("CampaignRepositoryMock.List mock is already set by Expect")
	}

	if mmList.defaultExpectation.paramPtrs == nil {
		mmList.defaultExpectation.paramPtrs = &CampaignRepositoryMockListParamPtrs{}
	}
	mmList.defaultExpectation.paramPtrs.ctx = &ctx
	mmList.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmList
}

// ExpectAdvertiserIDParam2 sets up expected param advertiserID for CampaignRepository.List
func (mmList *mCampaignRepositoryMockList) ExpectAdvertiserIDParam2(advertiserID string) *mCampaignRepositoryMockList {
	if mmList.mock.funcList != nil {
		mmList.mock.t.Fatalf("CampaignRepositoryMock.List mock is already set by Set")
	}

	if mmList.defaultExpectation == nil {
		mmList.defaultExpectation = &CampaignRepositoryMockListExpectation{}
	}

	if mmList.defaultExpectation.params != nil {
		mmList.mock.t.Fatalf("CampaignRepositoryMock.List mock is already set by Expect")
	}

	if mmList.defaultExpectation.paramPtrs == nil {
		mmList.defaultExpectation.paramPtrs = &CampaignRepositoryMockListParamPtrs{}
	}
	mmList.defaultExpectation.paramPtrs.advertiserID = &advertiserID
	mmList.defaultExpectation.expectationOrigins.originAdvertiserID = minimock.CallerInfo(1)

	return mmList
}

// ExpectPageParam3 sets up expected param page for CampaignRepository.List
func (mmList *mCampaignRepositoryMockList) ExpectPageParam3(page int) *mCampaignRepositoryMockList {
	if mmList.mock.funcList != nil {
		mmList.mock.t.Fatalf("CampaignRepositoryMock.List mock is already set by Set")
	}

	if mmList.defaultExpectation == nil {
		mmList.defaultExpectation = &CampaignRepositoryMockListExpectation{}
	}

	if mmList.defaultExpectation.params != nil {
		mmList.mock.t.Fatalf("CampaignRepositoryMock.List mock is already set by Expect")
	}

	if mmList.defaultExpectation.paramPtrs == nil {
		mmList.defaultExpectation.paramPtrs = &CampaignRepositoryMockListParamPtrs{}
	}
	mmList.defaultExpectation.paramPtrs.page = &page
	mmList.defaultExpectation.expectationOrigins.originPage = minimock.CallerInfo(1)

	return mmList
}

// ExpectSizeParam4 sets up expected param size for CampaignRepository.List
func (mmList *mCampaignRepositoryMockList) ExpectSizeParam4(size int) *mCampaignRepositoryMockList {
	if mmList.mock.funcList != nil {
		mmList.mock.t.Fatalf("CampaignRepositoryMock.List mock is already set by Set")
	}

	if mmList.defaultExpectation == nil {
		mmList.defaultExpectation = &CampaignRepositoryMockListExpectation{}
	}

	if mmList.defaultExpectation.params != nil {
		mmList.mock.t.Fatalf("CampaignRepositoryMock.List mock is already set by Expect")
	}

	if mmList.defaultExpectation.paramPtrs == nil {
		mmList.defaultExpectation.paramPtrs = &CampaignRepositoryMockListParamPtrs{}
	}
	mmList.defaultExpectation.paramPtrs.size = &size
	mmList.defaultExpectation.expectationOrigins.originSize = minimock.CallerInfo(1)

	return mmList
}

// Inspect accepts an inspector function that has same arguments as the CampaignRepository.List
func (mmList *mCampaignRepositoryMockList) Inspect(f func(ctx context.Context, advertiserID string, page int, size int)) *mCampaignRepositoryMockList {
	if mmList.mock.inspectFuncList != nil {
		mmList.mock.t.Fatalf("Inspect function is already set for CampaignRepositoryMock.List")
	}

	mmList.mock.inspectFuncList = f

	return mmList
}

// Return sets up results that will be returned by CampaignRepository.List
func (mmList *mCampaignRepositoryMockList) Return(cpa1 []*model.Campaign, err error) *CampaignRepositoryMock {
	if mmList.mock.funcList != nil {
		mmList.mock.t.Fatalf("CampaignRepositoryMock.List mock is already set by Set")
	}

	if mmList.defaultExpectation == nil {
		mmList.defaultExpectation = &CampaignRepositoryMockListExpectation{mock: mmList.mock}
	}
	mmList.defaultExpectation.results = &CampaignRepositoryMockListResults{cpa1, err}
	mmList.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmList.mock
}

// Set uses given function f to mock the CampaignRepository.List method
func (mmList *mCampaignRepositoryMockList) Set(f func(ctx context.Context, advertiserID string, page int, size int) (cpa1 []*model.Campaign, err error)) *CampaignRepositoryMock {
	if mmList.defaultExpectation != nil {
		mmList.mock.t.Fatalf("Default expectation is already set for the CampaignRepository.List method")
	}

	if len(mmList.expectations) > 0 {
		mmList.mock.t.Fatalf("Some expectations are already set for the CampaignRepository.List method")
	}

	mmList.mock.funcList = f
	mmList.mock.funcListOrigin = minimock.CallerInfo(1)
	return mmList.mock
}

// When sets expectation for the CampaignRepository.List which will trigger the result defined by the following
// Then helper
func (mmList *mCampaignRepositoryMockList) When(ctx context.Context, advertiserID string, page int, size int) *CampaignRepositoryMockListExpectation {
	if mmList.mock.funcList != nil {
		mmList.mock.t.Fatalf("CampaignRepositoryMock.List mock is already set by Set")
	}

	expectation := &CampaignRepositoryMockListExpectation{
		mock:               mmList.mock,
		params:             &CampaignRepositoryMockListParams{ctx, advertiserID, page, size},
		expectationOrigins: CampaignRepositoryMockListExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmList.expectations = append(mmList.expectations, expectation)
	return expectation
}

// Then sets up CampaignRepository.List return parameters for the expectation previously defined by the When method
func (e *CampaignRepositoryMockListExpectation) Then(cpa1 []*model.Campaign, err error) *CampaignRepositoryMock {
	e.results = &CampaignRepositoryMockListResults{cpa1, err}
	return e.mock
}

// Times sets number of times CampaignRepository.List should be invoked
func (mmList *mCampaignRepositoryMockList) Times(n uint64) *mCampaignRepositoryMockList {
	if n == 0 {
		mmList.mock.t.Fatalf("Times of CampaignRepositoryMock.List mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmList.expectedInvocations, n)
	mmList.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmList
}

func (mmList *mCampaignRepositoryMockList) invocationsDone() bool {
	if len(mmList.expectations) == 0 && mmList.defaultExpectation == nil && mmList.mock.funcList == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmList.mock.afterListCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmList.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// List implements mm_repository.CampaignRepository
func (mmList *CampaignRepositoryMock) List(ctx context.Context, advertiserID string, page int, size int) (cpa1 []*model.Campaign, err error) {
	mm_atomic.AddUint64(&mmList.beforeListCounter, 1)
	defer mm_atomic.AddUint64(&mmList.afterListCounter, 1)

	mmList.t.Helper()

	if mmList.inspectFuncList != nil {
		mmList.inspectFuncList(ctx, advertiserID, page, size)
	}

	mm_params := CampaignRepositoryMockListParams{ctx, advertiserID, page, size}

	// Record call args
	mmList.ListMock.mutex.Lock()
	mmList.ListMock.callArgs = append(mmList.ListMock.callArgs, &mm_params)
	mmList.ListMock.mutex.Unlock()

	for _, e := range mmList.ListMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cpa1, e.results.err
		}
	}

	if mmList.ListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmList.ListMock.defaultExpectation.Counter, 1)
		mm_want := mmList.ListMock.defaultExpectation.params
		mm_want_ptrs := mmList.ListMock.defaultExpectation.paramPtrs

		mm_got := CampaignRepositoryMockListParams{ctx, advertiserID, page, size}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmList.t.Errorf("CampaignRepositoryMock.List got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmList.ListMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.advertiserID != nil && !minimock.Equal(*mm_want_ptrs.advertiserID, mm_got.advertiserID) {
				mmList.t.Errorf("CampaignRepositoryMock.List got unexpected parameter advertiserID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmList.ListMock.defaultExpectation.expectationOrigins.originAdvertiserID, *mm_want_ptrs.advertiserID, mm_got.advertiserID, minimock.Diff(*mm_want_ptrs.advertiserID, mm_got.advertiserID))
			}

			if mm_want_ptrs.page != nil && !minimock.Equal(*mm_want_ptrs.page, mm_got.page) {
				mmList.t.Errorf("CampaignRepositoryMock.List got unexpected parameter page, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmList.ListMock.defaultExpectation.expectationOrigins.originPage, *mm_want_ptrs.page, mm_got.page, minimock.Diff(*mm_want_ptrs.page, mm_got.page))
			}

			if mm_want_ptrs.size != nil && !minimock.Equal(*mm_want_ptrs.size, mm_got.size) {
				mmList.t.Errorf("CampaignRepositoryMock.List got unexpected parameter size, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmList.ListMock.defaultExpectation.expectationOrigins.originSize, *mm_want_ptrs.size, mm_got.size, minimock.Diff(*mm_want_ptrs.size, mm_got.size))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmList.t.Errorf("CampaignRepositoryMock.List got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmList.ListMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmList.ListMock.defaultExpectation.results
		if mm_results == nil {
			mmList.t.Fatal("No results are set for the CampaignRepositoryMock.List")
		}
		return (*mm_results).cpa1, (*mm_results).err
	}
	if mmList.funcList != nil {
		return mmList.funcList(ctx, advertiserID, page, size)
	}
	mmList.t.Fatalf("Unexpected call to CampaignRepositoryMock.List. %v %v %v %v", ctx, advertiserID, page, size)
	return
}

// ListAfterCounter returns a count of finished CampaignRepositoryMock.List invocations
func (mmList *CampaignRepositoryMock) ListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmList.afterListCounter)
}

// ListBeforeCounter returns a count of CampaignRepositoryMock.List invocations
func (mmList *CampaignRepositoryMock) ListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmList.beforeListCounter)
}

// Calls returns a list of arguments used in each call to CampaignRepositoryMock.List.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmList *mCampaignRepositoryMockList) Calls() []*CampaignRepositoryMockListParams {
	mmList.mutex.RLock()

	argCopy := make([]*CampaignRepositoryMockListParams, len(mmList.callArgs))
	copy(argCopy, mmList.callArgs)

	mmList.mutex.RUnlock()

	return argCopy
}

// MinimockListDone returns true if the count of the List invocations corresponds
// the number of defined expectations
func (m *CampaignRepositoryMock) MinimockListDone() bool {
	if m.ListMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListMock.invocationsDone()
}

// MinimockListInspect logs each unmet expectation
func (m *CampaignRepositoryMock) MinimockListInspect() {
	for _, e := range m.ListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CampaignRepositoryMock.List at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListCounter := mm_atomic.LoadUint64(&m.afterListCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListMock.defaultExpectation != nil && afterListCounter < 1 {
		if m.ListMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CampaignRepositoryMock.List at\n%s", m.ListMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CampaignRepositoryMock.List at\n%s with params: %#v", m.ListMock.defaultExpectation.expectationOrigins.origin, *m.ListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcList != nil && afterListCounter < 1 {
		m.t.Errorf("Expected call to CampaignRepositoryMock.List at\n%s", m.funcListOrigin)
	}

	if !m.ListMock.invocationsDone() && afterListCounter > 0 {
		m.t.Errorf("Expected %d calls to CampaignRepositoryMock.List at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListMock.expectedInvocations), m.ListMock.expectedInvocationsOrigin, afterListCounter)
	}
}

type mCampaignRepositoryMockSaveImageUrl struct {
	optional           bool
	mock               *CampaignRepositoryMock
	defaultExpectation *CampaignRepositoryMockSaveImageUrlExpectation
	expectations       []*CampaignRepositoryMockSaveImageUrlExpectation

	callArgs []*CampaignRepositoryMockSaveImageUrlParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CampaignRepositoryMockSaveImageUrlExpectation specifies expectation struct of the CampaignRepository.SaveImageUrl
type CampaignRepositoryMockSaveImageUrlExpectation struct {
	mock               *CampaignRepositoryMock
	params             *CampaignRepositoryMockSaveImageUrlParams
	paramPtrs          *CampaignRepositoryMockSaveImageUrlParamPtrs
	expectationOrigins CampaignRepositoryMockSaveImageUrlExpectationOrigins
	results            *CampaignRepositoryMockSaveImageUrlResults
	returnOrigin       string
	Counter            uint64
}

// CampaignRepositoryMockSaveImageUrlParams contains parameters of the CampaignRepository.SaveImageUrl
type CampaignRepositoryMockSaveImageUrlParams struct {
	ctx        context.Context
	imageUrl   string
	campaignID string
}

// CampaignRepositoryMockSaveImageUrlParamPtrs contains pointers to parameters of the CampaignRepository.SaveImageUrl
type CampaignRepositoryMockSaveImageUrlParamPtrs struct {
	ctx        *context.Context
	imageUrl   *string
	campaignID *string
}

// CampaignRepositoryMockSaveImageUrlResults contains results of the CampaignRepository.SaveImageUrl
type CampaignRepositoryMockSaveImageUrlResults struct {
	s1  string
	err error
}

// CampaignRepositoryMockSaveImageUrlOrigins contains origins of expectations of the CampaignRepository.SaveImageUrl
type CampaignRepositoryMockSaveImageUrlExpectationOrigins struct {
	origin           string
	originCtx        string
	originImageUrl   string
	originCampaignID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSaveImageUrl *mCampaignRepositoryMockSaveImageUrl) Optional() *mCampaignRepositoryMockSaveImageUrl {
	mmSaveImageUrl.optional = true
	return mmSaveImageUrl
}

// Expect sets up expected params for CampaignRepository.SaveImageUrl
func (mmSaveImageUrl *mCampaignRepositoryMockSaveImageUrl) Expect(ctx context.Context, imageUrl string, campaignID string) *mCampaignRepositoryMockSaveImageUrl {
	if mmSaveImageUrl.mock.funcSaveImageUrl != nil {
		mmSaveImageUrl.mock.t.Fatalf("CampaignRepositoryMock.SaveImageUrl mock is already set by Set")
	}

	if mmSaveImageUrl.defaultExpectation == nil {
		mmSaveImageUrl.defaultExpectation = &CampaignRepositoryMockSaveImageUrlExpectation{}
	}

	if mmSaveImageUrl.defaultExpectation.paramPtrs != nil {
		mmSaveImageUrl.mock.t.Fatalf("CampaignRepositoryMock.SaveImageUrl mock is already set by ExpectParams functions")
	}

	mmSaveImageUrl.defaultExpectation.params = &CampaignRepositoryMockSaveImageUrlParams{ctx, imageUrl, campaignID}
	mmSaveImageUrl.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSaveImageUrl.expectations {
		if minimock.Equal(e.params, mmSaveImageUrl.defaultExpectation.params) {
			mmSaveImageUrl.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSaveImageUrl.defaultExpectation.params)
		}
	}

	return mmSaveImageUrl
}

// ExpectCtxParam1 sets up expected param ctx for CampaignRepository.SaveImageUrl
func (mmSaveImageUrl *mCampaignRepositoryMockSaveImageUrl) ExpectCtxParam1(ctx context.Context) *mCampaignRepositoryMockSaveImageUrl {
	if mmSaveImageUrl.mock.funcSaveImageUrl != nil {
		mmSaveImageUrl.mock.t.Fatalf("CampaignRepositoryMock.SaveImageUrl mock is already set by Set")
	}

	if mmSaveImageUrl.defaultExpectation == nil {
		mmSaveImageUrl.defaultExpectation = &CampaignRepositoryMockSaveImageUrlExpectation{}
	}

	if mmSaveImageUrl.defaultExpectation.params != nil {
		mmSaveImageUrl.mock.t.Fatalf("CampaignRepositoryMock.SaveImageUrl mock is already set by Expect")
	}

	if mmSaveImageUrl.defaultExpectation.paramPtrs == nil {
		mmSaveImageUrl.defaultExpectation.paramPtrs = &CampaignRepositoryMockSaveImageUrlParamPtrs{}
	}
	mmSaveImageUrl.defaultExpectation.paramPtrs.ctx = &ctx
	mmSaveImageUrl.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSaveImageUrl
}

// ExpectImageUrlParam2 sets up expected param imageUrl for CampaignRepository.SaveImageUrl
func (mmSaveImageUrl *mCampaignRepositoryMockSaveImageUrl) ExpectImageUrlParam2(imageUrl string) *mCampaignRepositoryMockSaveImageUrl {
	if mmSaveImageUrl.mock.funcSaveImageUrl != nil {
		mmSaveImageUrl.mock.t.Fatalf("CampaignRepositoryMock.SaveImageUrl mock is already set by Set")
	}

	if mmSaveImageUrl.defaultExpectation == nil {
		mmSaveImageUrl.defaultExpectation = &CampaignRepositoryMockSaveImageUrlExpectation{}
	}

	if mmSaveImageUrl.defaultExpectation.params != nil {
		mmSaveImageUrl.mock.t.Fatalf("CampaignRepositoryMock.SaveImageUrl mock is already set by Expect")
	}

	if mmSaveImageUrl.defaultExpectation.paramPtrs == nil {
		mmSaveImageUrl.defaultExpectation.paramPtrs = &CampaignRepositoryMockSaveImageUrlParamPtrs{}
	}
	mmSaveImageUrl.defaultExpectation.paramPtrs.imageUrl = &imageUrl
	mmSaveImageUrl.defaultExpectation.expectationOrigins.originImageUrl = minimock.CallerInfo(1)

	return mmSaveImageUrl
}

// ExpectCampaignIDParam3 sets up expected param campaignID for CampaignRepository.SaveImageUrl
func (mmSaveImageUrl *mCampaignRepositoryMockSaveImageUrl) ExpectCampaignIDParam3(campaignID string) *mCampaignRepositoryMockSaveImageUrl {
	if mmSaveImageUrl.mock.funcSaveImageUrl != nil {
		mmSaveImageUrl.mock.t.Fatalf("CampaignRepositoryMock.SaveImageUrl mock is already set by Set")
	}

	if mmSaveImageUrl.defaultExpectation == nil {
		mmSaveImageUrl.defaultExpectation = &CampaignRepositoryMockSaveImageUrlExpectation{}
	}

	if mmSaveImageUrl.defaultExpectation.params != nil {
		mmSaveImageUrl.mock.t.Fatalf("CampaignRepositoryMock.SaveImageUrl mock is already set by Expect")
	}

	if mmSaveImageUrl.defaultExpectation.paramPtrs == nil {
		mmSaveImageUrl.defaultExpectation.paramPtrs = &CampaignRepositoryMockSaveImageUrlParamPtrs{}
	}
	mmSaveImageUrl.defaultExpectation.paramPtrs.campaignID = &campaignID
	mmSaveImageUrl.defaultExpectation.expectationOrigins.originCampaignID = minimock.CallerInfo(1)

	return mmSaveImageUrl
}

// Inspect accepts an inspector function that has same arguments as the CampaignRepository.SaveImageUrl
func (mmSaveImageUrl *mCampaignRepositoryMockSaveImageUrl) Inspect(f func(ctx context.Context, imageUrl string, campaignID string)) *mCampaignRepositoryMockSaveImageUrl {
	if mmSaveImageUrl.mock.inspectFuncSaveImageUrl != nil {
		mmSaveImageUrl.mock.t.Fatalf("Inspect function is already set for CampaignRepositoryMock.SaveImageUrl")
	}

	mmSaveImageUrl.mock.inspectFuncSaveImageUrl = f

	return mmSaveImageUrl
}

// Return sets up results that will be returned by CampaignRepository.SaveImageUrl
func (mmSaveImageUrl *mCampaignRepositoryMockSaveImageUrl) Return(s1 string, err error) *CampaignRepositoryMock {
	if mmSaveImageUrl.mock.funcSaveImageUrl != nil {
		mmSaveImageUrl.mock.t.Fatalf("CampaignRepositoryMock.SaveImageUrl mock is already set by Set")
	}

	if mmSaveImageUrl.defaultExpectation == nil {
		mmSaveImageUrl.defaultExpectation = &CampaignRepositoryMockSaveImageUrlExpectation{mock: mmSaveImageUrl.mock}
	}
	mmSaveImageUrl.defaultExpectation.results = &CampaignRepositoryMockSaveImageUrlResults{s1, err}
	mmSaveImageUrl.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSaveImageUrl.mock
}

// Set uses given function f to mock the CampaignRepository.SaveImageUrl method
func (mmSaveImageUrl *mCampaignRepositoryMockSaveImageUrl) Set(f func(ctx context.Context, imageUrl string, campaignID string) (s1 string, err error)) *CampaignRepositoryMock {
	if mmSaveImageUrl.defaultExpectation != nil {
		mmSaveImageUrl.mock.t.Fatalf("Default expectation is already set for the CampaignRepository.SaveImageUrl method")
	}

	if len(mmSaveImageUrl.expectations) > 0 {
		mmSaveImageUrl.mock.t.Fatalf("Some expectations are already set for the CampaignRepository.SaveImageUrl method")
	}

	mmSaveImageUrl.mock.funcSaveImageUrl = f
	mmSaveImageUrl.mock.funcSaveImageUrlOrigin = minimock.CallerInfo(1)
	return mmSaveImageUrl.mock
}

// When sets expectation for the CampaignRepository.SaveImageUrl which will trigger the result defined by the following
// Then helper
func (mmSaveImageUrl *mCampaignRepositoryMockSaveImageUrl) When(ctx context.Context, imageUrl string, campaignID string) *CampaignRepositoryMockSaveImageUrlExpectation {
	if mmSaveImageUrl.mock.funcSaveImageUrl != nil {
		mmSaveImageUrl.mock.t.Fatalf("CampaignRepositoryMock.SaveImageUrl mock is already set by Set")
	}

	expectation := &CampaignRepositoryMockSaveImageUrlExpectation{
		mock:               mmSaveImageUrl.mock,
		params:             &CampaignRepositoryMockSaveImageUrlParams{ctx, imageUrl, campaignID},
		expectationOrigins: CampaignRepositoryMockSaveImageUrlExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSaveImageUrl.expectations = append(mmSaveImageUrl.expectations, expectation)
	return expectation
}

// Then sets up CampaignRepository.SaveImageUrl return parameters for the expectation previously defined by the When method
func (e *CampaignRepositoryMockSaveImageUrlExpectation) Then(s1 string, err error) *CampaignRepositoryMock {
	e.results = &CampaignRepositoryMockSaveImageUrlResults{s1, err}
	return e.mock
}

// Times sets number of times CampaignRepository.SaveImageUrl should be invoked
func (mmSaveImageUrl *mCampaignRepositoryMockSaveImageUrl) Times(n uint64) *mCampaignRepositoryMockSaveImageUrl {
	if n == 0 {
		mmSaveImageUrl.mock.t.Fatalf("Times of CampaignRepositoryMock.SaveImageUrl mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSaveImageUrl.expectedInvocations, n)
	mmSaveImageUrl.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSaveImageUrl
}

func (mmSaveImageUrl *mCampaignRepositoryMockSaveImageUrl) invocationsDone() bool {
	if len(mmSaveImageUrl.expectations) == 0 && mmSaveImageUrl.defaultExpectation == nil && mmSaveImageUrl.mock.funcSaveImageUrl == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSaveImageUrl.mock.afterSaveImageUrlCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSaveImageUrl.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SaveImageUrl implements mm_repository.CampaignRepository
func (mmSaveImageUrl *CampaignRepositoryMock) SaveImageUrl(ctx context.Context, imageUrl string, campaignID string) (s1 string, err error) {
	mm_atomic.AddUint64(&mmSaveImageUrl.beforeSaveImageUrlCounter, 1)
	defer mm_atomic.AddUint64(&mmSaveImageUrl.afterSaveImageUrlCounter, 1)

	mmSaveImageUrl.t.Helper()

	if mmSaveImageUrl.inspectFuncSaveImageUrl != nil {
		mmSaveImageUrl.inspectFuncSaveImageUrl(ctx, imageUrl, campaignID)
	}

	mm_params := CampaignRepositoryMockSaveImageUrlParams{ctx, imageUrl, campaignID}

	// Record call args
	mmSaveImageUrl.SaveImageUrlMock.mutex.Lock()
	mmSaveImageUrl.SaveImageUrlMock.callArgs = append(mmSaveImageUrl.SaveImageUrlMock.callArgs, &mm_params)
	mmSaveImageUrl.SaveImageUrlMock.mutex.Unlock()

	for _, e := range mmSaveImageUrl.SaveImageUrlMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmSaveImageUrl.SaveImageUrlMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSaveImageUrl.SaveImageUrlMock.defaultExpectation.Counter, 1)
		mm_want := mmSaveImageUrl.SaveImageUrlMock.defaultExpectation.params
		mm_want_ptrs := mmSaveImageUrl.SaveImageUrlMock.defaultExpectation.paramPtrs

		mm_got := CampaignRepositoryMockSaveImageUrlParams{ctx, imageUrl, campaignID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSaveImageUrl.t.Errorf("CampaignRepositoryMock.SaveImageUrl got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveImageUrl.SaveImageUrlMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.imageUrl != nil && !minimock.Equal(*mm_want_ptrs.imageUrl, mm_got.imageUrl) {
				mmSaveImageUrl.t.Errorf("CampaignRepositoryMock.SaveImageUrl got unexpected parameter imageUrl, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveImageUrl.SaveImageUrlMock.defaultExpectation.expectationOrigins.originImageUrl, *mm_want_ptrs.imageUrl, mm_got.imageUrl, minimock.Diff(*mm_want_ptrs.imageUrl, mm_got.imageUrl))
			}

			if mm_want_ptrs.campaignID != nil && !minimock.Equal(*mm_want_ptrs.campaignID, mm_got.campaignID) {
				mmSaveImageUrl.t.Errorf("CampaignRepositoryMock.SaveImageUrl got unexpected parameter campaignID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveImageUrl.SaveImageUrlMock.defaultExpectation.expectationOrigins.originCampaignID, *mm_want_ptrs.campaignID, mm_got.campaignID, minimock.Diff(*mm_want_ptrs.campaignID, mm_got.campaignID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSaveImageUrl.t.Errorf("CampaignRepositoryMock.SaveImageUrl got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSaveImageUrl.SaveImageUrlMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSaveImageUrl.SaveImageUrlMock.defaultExpectation.results
		if mm_results == nil {
			mmSaveImageUrl.t.Fatal("No results are set for the CampaignRepositoryMock.SaveImageUrl")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmSaveImageUrl.funcSaveImageUrl != nil {
		return mmSaveImageUrl.funcSaveImageUrl(ctx, imageUrl, campaignID)
	}
	mmSaveImageUrl.t.Fatalf("Unexpected call to CampaignRepositoryMock.SaveImageUrl. %v %v %v", ctx, imageUrl, campaignID)
	return
}

// SaveImageUrlAfterCounter returns a count of finished CampaignRepositoryMock.SaveImageUrl invocations
func (mmSaveImageUrl *CampaignRepositoryMock) SaveImageUrlAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveImageUrl.afterSaveImageUrlCounter)
}

// SaveImageUrlBeforeCounter returns a count of CampaignRepositoryMock.SaveImageUrl invocations
func (mmSaveImageUrl *CampaignRepositoryMock) SaveImageUrlBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveImageUrl.beforeSaveImageUrlCounter)
}

// Calls returns a list of arguments used in each call to CampaignRepositoryMock.SaveImageUrl.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSaveImageUrl *mCampaignRepositoryMockSaveImageUrl) Calls() []*CampaignRepositoryMockSaveImageUrlParams {
	mmSaveImageUrl.mutex.RLock()

	argCopy := make([]*CampaignRepositoryMockSaveImageUrlParams, len(mmSaveImageUrl.callArgs))
	copy(argCopy, mmSaveImageUrl.callArgs)

	mmSaveImageUrl.mutex.RUnlock()

	return argCopy
}

// MinimockSaveImageUrlDone returns true if the count of the SaveImageUrl invocations corresponds
// the number of defined expectations
func (m *CampaignRepositoryMock) MinimockSaveImageUrlDone() bool {
	if m.SaveImageUrlMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SaveImageUrlMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SaveImageUrlMock.invocationsDone()
}

// MinimockSaveImageUrlInspect logs each unmet expectation
func (m *CampaignRepositoryMock) MinimockSaveImageUrlInspect() {
	for _, e := range m.SaveImageUrlMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CampaignRepositoryMock.SaveImageUrl at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSaveImageUrlCounter := mm_atomic.LoadUint64(&m.afterSaveImageUrlCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SaveImageUrlMock.defaultExpectation != nil && afterSaveImageUrlCounter < 1 {
		if m.SaveImageUrlMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CampaignRepositoryMock.SaveImageUrl at\n%s", m.SaveImageUrlMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CampaignRepositoryMock.SaveImageUrl at\n%s with params: %#v", m.SaveImageUrlMock.defaultExpectation.expectationOrigins.origin, *m.SaveImageUrlMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSaveImageUrl != nil && afterSaveImageUrlCounter < 1 {
		m.t.Errorf("Expected call to CampaignRepositoryMock.SaveImageUrl at\n%s", m.funcSaveImageUrlOrigin)
	}

	if !m.SaveImageUrlMock.invocationsDone() && afterSaveImageUrlCounter > 0 {
		m.t.Errorf("Expected %d calls to CampaignRepositoryMock.SaveImageUrl at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SaveImageUrlMock.expectedInvocations), m.SaveImageUrlMock.expectedInvocationsOrigin, afterSaveImageUrlCounter)
	}
}

type mCampaignRepositoryMockUpdate struct {
	optional           bool
	mock               *CampaignRepositoryMock
	defaultExpectation *CampaignRepositoryMockUpdateExpectation
	expectations       []*CampaignRepositoryMockUpdateExpectation

	callArgs []*CampaignRepositoryMockUpdateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CampaignRepositoryMockUpdateExpectation specifies expectation struct of the CampaignRepository.Update
type CampaignRepositoryMockUpdateExpectation struct {
	mock               *CampaignRepositoryMock
	params             *CampaignRepositoryMockUpdateParams
	paramPtrs          *CampaignRepositoryMockUpdateParamPtrs
	expectationOrigins CampaignRepositoryMockUpdateExpectationOrigins
	results            *CampaignRepositoryMockUpdateResults
	returnOrigin       string
	Counter            uint64
}

// CampaignRepositoryMockUpdateParams contains parameters of the CampaignRepository.Update
type CampaignRepositoryMockUpdateParams struct {
	ctx      context.Context
	campaign *model.Campaign
}

// CampaignRepositoryMockUpdateParamPtrs contains pointers to parameters of the CampaignRepository.Update
type CampaignRepositoryMockUpdateParamPtrs struct {
	ctx      *context.Context
	campaign **model.Campaign
}

// CampaignRepositoryMockUpdateResults contains results of the CampaignRepository.Update
type CampaignRepositoryMockUpdateResults struct {
	cp1 *model.Campaign
	err error
}

// CampaignRepositoryMockUpdateOrigins contains origins of expectations of the CampaignRepository.Update
type CampaignRepositoryMockUpdateExpectationOrigins struct {
	origin         string
	originCtx      string
	originCampaign string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdate *mCampaignRepositoryMockUpdate) Optional() *mCampaignRepositoryMockUpdate {
	mmUpdate.optional = true
	return mmUpdate
}

// Expect sets up expected params for CampaignRepository.Update
func (mmUpdate *mCampaignRepositoryMockUpdate) Expect(ctx context.Context, campaign *model.Campaign) *mCampaignRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("CampaignRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &CampaignRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.paramPtrs != nil {
		mmUpdate.mock.t.Fatalf("CampaignRepositoryMock.Update mock is already set by ExpectParams functions")
	}

	mmUpdate.defaultExpectation.params = &CampaignRepositoryMockUpdateParams{ctx, campaign}
	mmUpdate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdate.expectations {
		if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) {
			mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
		}
	}

	return mmUpdate
}

// ExpectCtxParam1 sets up expected param ctx for CampaignRepository.Update
func (mmUpdate *mCampaignRepositoryMockUpdate) ExpectCtxParam1(ctx context.Context) *mCampaignRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("CampaignRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &CampaignRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("CampaignRepositoryMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &CampaignRepositoryMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdate
}

// ExpectCampaignParam2 sets up expected param campaign for CampaignRepository.Update
func (mmUpdate *mCampaignRepositoryMockUpdate) ExpectCampaignParam2(campaign *model.Campaign) *mCampaignRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("CampaignRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &CampaignRepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("CampaignRepositoryMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &CampaignRepositoryMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.campaign = &campaign
	mmUpdate.defaultExpectation.expectationOrigins.originCampaign = minimock.CallerInfo(1)

	return mmUpdate
}

// Inspect accepts an inspector function that has same arguments as the CampaignRepository.Update
func (mmUpdate *mCampaignRepositoryMockUpdate) Inspect(f func(ctx context.Context, campaign *model.Campaign)) *mCampaignRepositoryMockUpdate {
	if mmUpdate.mock.inspectFuncUpdate != nil {
		mmUpdate.mock.t.Fatalf("Inspect function is already set for CampaignRepositoryMock.Update")
	}

	mmUpdate.mock.inspectFuncUpdate = f

	return mmUpdate
}

// Return sets up results that will be returned by CampaignRepository.Update
func (mmUpdate *mCampaignRepositoryMockUpdate) Return(cp1 *model.Campaign, err error) *CampaignRepositoryMock {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("CampaignRepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &CampaignRepositoryMockUpdateExpectation{mock: mmUpdate.mock}
	}
	mmUpdate.defaultExpectation.results = &CampaignRepositoryMockUpdateResults{cp1, err}
	mmUpdate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdate.mock
}

// Set uses given function f to mock the CampaignRepository.Update method
func (mmUpdate *mCampaignRepositoryMockUpdate) Set(f func(ctx context.Context, campaign *model.Campaign) (cp1 *model.Campaign, err error)) *CampaignRepositoryMock {
	if mmUpdate.defaultExpectation != nil {
		mmUpdate.mock.t.Fatalf("Default expectation is already set for the CampaignRepository.Update method")
	}

	if len(mmUpdate.expectations) > 0 {
		mmUpdate.mock.t.Fatalf("Some expectations are already set for the CampaignRepository.Update method")
	}

	mmUpdate.mock.funcUpdate = f
	mmUpdate.mock.funcUpdateOrigin = minimock.CallerInfo(1)
	return mmUpdate.mock
}

// When sets expectation for the CampaignRepository.Update which will trigger the result defined by the following
// Then helper
func (mmUpdate *mCampaignRepositoryMockUpdate) When(ctx context.Context, campaign *model.Campaign) *CampaignRepositoryMockUpdateExpectation {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("CampaignRepositoryMock.Update mock is already set by Set")
	}

	expectation := &CampaignRepositoryMockUpdateExpectation{
		mock:               mmUpdate.mock,
		params:             &CampaignRepositoryMockUpdateParams{ctx, campaign},
		expectationOrigins: CampaignRepositoryMockUpdateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdate.expectations = append(mmUpdate.expectations, expectation)
	return expectation
}

// Then sets up CampaignRepository.Update return parameters for the expectation previously defined by the When method
func (e *CampaignRepositoryMockUpdateExpectation) Then(cp1 *model.Campaign, err error) *CampaignRepositoryMock {
	e.results = &CampaignRepositoryMockUpdateResults{cp1, err}
	return e.mock
}

// Times sets number of times CampaignRepository.Update should be invoked
func (mmUpdate *mCampaignRepositoryMockUpdate) Times(n uint64) *mCampaignRepositoryMockUpdate {
	if n == 0 {
		mmUpdate.mock.t.Fatalf("Times of CampaignRepositoryMock.Update mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdate.expectedInvocations, n)
	mmUpdate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdate
}

func (mmUpdate *mCampaignRepositoryMockUpdate) invocationsDone() bool {
	if len(mmUpdate.expectations) == 0 && mmUpdate.defaultExpectation == nil && mmUpdate.mock.funcUpdate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdate.mock.afterUpdateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Update implements mm_repository.CampaignRepository
func (mmUpdate *CampaignRepositoryMock) Update(ctx context.Context, campaign *model.Campaign) (cp1 *model.Campaign, err error) {
	mm_atomic.AddUint64(&mmUpdate.beforeUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdate.afterUpdateCounter, 1)

	mmUpdate.t.Helper()

	if mmUpdate.inspectFuncUpdate != nil {
		mmUpdate.inspectFuncUpdate(ctx, campaign)
	}

	mm_params := CampaignRepositoryMockUpdateParams{ctx, campaign}

	// Record call args
	mmUpdate.UpdateMock.mutex.Lock()
	mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, &mm_params)
	mmUpdate.UpdateMock.mutex.Unlock()

	for _, e := range mmUpdate.UpdateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmUpdate.UpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdate.UpdateMock.defaultExpectation.params
		mm_want_ptrs := mmUpdate.UpdateMock.defaultExpectation.paramPtrs

		mm_got := CampaignRepositoryMockUpdateParams{ctx, campaign}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdate.t.Errorf("CampaignRepositoryMock.Update got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.campaign != nil && !minimock.Equal(*mm_want_ptrs.campaign, mm_got.campaign) {
				mmUpdate.t.Errorf("CampaignRepositoryMock.Update got unexpected parameter campaign, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originCampaign, *mm_want_ptrs.campaign, mm_got.campaign, minimock.Diff(*mm_want_ptrs.campaign, mm_got.campaign))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdate.t.Errorf("CampaignRepositoryMock.Update got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdate.UpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdate.t.Fatal("No results are set for the CampaignRepositoryMock.Update")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmUpdate.funcUpdate != nil {
		return mmUpdate.funcUpdate(ctx, campaign)
	}
	mmUpdate.t.Fatalf("Unexpected call to CampaignRepositoryMock.Update. %v %v", ctx, campaign)
	return
}

// UpdateAfterCounter returns a count of finished CampaignRepositoryMock.Update invocations
func (mmUpdate *CampaignRepositoryMock) UpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.afterUpdateCounter)
}

// UpdateBeforeCounter returns a count of CampaignRepositoryMock.Update invocations
func (mmUpdate *CampaignRepositoryMock) UpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.beforeUpdateCounter)
}

// Calls returns a list of arguments used in each call to CampaignRepositoryMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mCampaignRepositoryMockUpdate) Calls() []*CampaignRepositoryMockUpdateParams {
	mmUpdate.mutex.RLock()

	argCopy := make([]*CampaignRepositoryMockUpdateParams, len(mmUpdate.callArgs))
	copy(argCopy, mmUpdate.callArgs)

	mmUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *CampaignRepositoryMock) MinimockUpdateDone() bool {
	if m.UpdateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateMock.invocationsDone()
}

// MinimockUpdateInspect logs each unmet expectation
func (m *CampaignRepositoryMock) MinimockUpdateInspect() {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CampaignRepositoryMock.Update at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateCounter := mm_atomic.LoadUint64(&m.afterUpdateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && afterUpdateCounter < 1 {
		if m.UpdateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CampaignRepositoryMock.Update at\n%s", m.UpdateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CampaignRepositoryMock.Update at\n%s with params: %#v", m.UpdateMock.defaultExpectation.expectationOrigins.origin, *m.UpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && afterUpdateCounter < 1 {
		m.t.Errorf("Expected call to CampaignRepositoryMock.Update at\n%s", m.funcUpdateOrigin)
	}

	if !m.UpdateMock.invocationsDone() && afterUpdateCounter > 0 {
		m.t.Errorf("Expected %d calls to CampaignRepositoryMock.Update at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateMock.expectedInvocations), m.UpdateMock.expectedInvocationsOrigin, afterUpdateCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CampaignRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateInspect()

			m.MinimockDeleteInspect()

			m.MinimockGetInspect()

			m.MinimockGetByCampaignIDInspect()

			m.MinimockListInspect()

			m.MinimockSaveImageUrlInspect()

			m.MinimockUpdateInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CampaignRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CampaignRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockGetDone() &&
		m.MinimockGetByCampaignIDDone() &&
		m.MinimockListDone() &&
		m.MinimockSaveImageUrlDone() &&
		m.MinimockUpdateDone()
}
