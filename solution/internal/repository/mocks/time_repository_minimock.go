// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i server/internal/repository.TimeRepository -o time_repository_minimock.go -n TimeRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// TimeRepositoryMock implements mm_repository.TimeRepository
type TimeRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGet          func(ctx context.Context) (i1 int, err error)
	funcGetOrigin    string
	inspectFuncGet   func(ctx context.Context)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mTimeRepositoryMockGet

	funcSet          func(ctx context.Context, day int) (err error)
	funcSetOrigin    string
	inspectFuncSet   func(ctx context.Context, day int)
	afterSetCounter  uint64
	beforeSetCounter uint64
	SetMock          mTimeRepositoryMockSet

	funcUpdateCampaignsState          func(ctx context.Context) (err error)
	funcUpdateCampaignsStateOrigin    string
	inspectFuncUpdateCampaignsState   func(ctx context.Context)
	afterUpdateCampaignsStateCounter  uint64
	beforeUpdateCampaignsStateCounter uint64
	UpdateCampaignsStateMock          mTimeRepositoryMockUpdateCampaignsState
}

// NewTimeRepositoryMock returns a mock for mm_repository.TimeRepository
func NewTimeRepositoryMock(t minimock.Tester) *TimeRepositoryMock {
	m := &TimeRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetMock = mTimeRepositoryMockGet{mock: m}
	m.GetMock.callArgs = []*TimeRepositoryMockGetParams{}

	m.SetMock = mTimeRepositoryMockSet{mock: m}
	m.SetMock.callArgs = []*TimeRepositoryMockSetParams{}

	m.UpdateCampaignsStateMock = mTimeRepositoryMockUpdateCampaignsState{mock: m}
	m.UpdateCampaignsStateMock.callArgs = []*TimeRepositoryMockUpdateCampaignsStateParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mTimeRepositoryMockGet struct {
	optional           bool
	mock               *TimeRepositoryMock
	defaultExpectation *TimeRepositoryMockGetExpectation
	expectations       []*TimeRepositoryMockGetExpectation

	callArgs []*TimeRepositoryMockGetParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TimeRepositoryMockGetExpectation specifies expectation struct of the TimeRepository.Get
type TimeRepositoryMockGetExpectation struct {
	mock               *TimeRepositoryMock
	params             *TimeRepositoryMockGetParams
	paramPtrs          *TimeRepositoryMockGetParamPtrs
	expectationOrigins TimeRepositoryMockGetExpectationOrigins
	results            *TimeRepositoryMockGetResults
	returnOrigin       string
	Counter            uint64
}

// TimeRepositoryMockGetParams contains parameters of the TimeRepository.Get
type TimeRepositoryMockGetParams struct {
	ctx context.Context
}

// TimeRepositoryMockGetParamPtrs contains pointers to parameters of the TimeRepository.Get
type TimeRepositoryMockGetParamPtrs struct {
	ctx *context.Context
}

// TimeRepositoryMockGetResults contains results of the TimeRepository.Get
type TimeRepositoryMockGetResults struct {
	i1  int
	err error
}

// TimeRepositoryMockGetOrigins contains origins of expectations of the TimeRepository.Get
type TimeRepositoryMockGetExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGet *mTimeRepositoryMockGet) Optional() *mTimeRepositoryMockGet {
	mmGet.optional = true
	return mmGet
}

// Expect sets up expected params for TimeRepository.Get
func (mmGet *mTimeRepositoryMockGet) Expect(ctx context.Context) *mTimeRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("TimeRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &TimeRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.paramPtrs != nil {
		mmGet.mock.t.Fatalf("TimeRepositoryMock.Get mock is already set by ExpectParams functions")
	}

	mmGet.defaultExpectation.params = &TimeRepositoryMockGetParams{ctx}
	mmGet.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// ExpectCtxParam1 sets up expected param ctx for TimeRepository.Get
func (mmGet *mTimeRepositoryMockGet) ExpectCtxParam1(ctx context.Context) *mTimeRepositoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("TimeRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &TimeRepositoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("TimeRepositoryMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &TimeRepositoryMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.ctx = &ctx
	mmGet.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the TimeRepository.Get
func (mmGet *mTimeRepositoryMockGet) Inspect(f func(ctx context.Context)) *mTimeRepositoryMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for TimeRepositoryMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by TimeRepository.Get
func (mmGet *mTimeRepositoryMockGet) Return(i1 int, err error) *TimeRepositoryMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("TimeRepositoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &TimeRepositoryMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &TimeRepositoryMockGetResults{i1, err}
	mmGet.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// Set uses given function f to mock the TimeRepository.Get method
func (mmGet *mTimeRepositoryMockGet) Set(f func(ctx context.Context) (i1 int, err error)) *TimeRepositoryMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the TimeRepository.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the TimeRepository.Get method")
	}

	mmGet.mock.funcGet = f
	mmGet.mock.funcGetOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// When sets expectation for the TimeRepository.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mTimeRepositoryMockGet) When(ctx context.Context) *TimeRepositoryMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("TimeRepositoryMock.Get mock is already set by Set")
	}

	expectation := &TimeRepositoryMockGetExpectation{
		mock:               mmGet.mock,
		params:             &TimeRepositoryMockGetParams{ctx},
		expectationOrigins: TimeRepositoryMockGetExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up TimeRepository.Get return parameters for the expectation previously defined by the When method
func (e *TimeRepositoryMockGetExpectation) Then(i1 int, err error) *TimeRepositoryMock {
	e.results = &TimeRepositoryMockGetResults{i1, err}
	return e.mock
}

// Times sets number of times TimeRepository.Get should be invoked
func (mmGet *mTimeRepositoryMockGet) Times(n uint64) *mTimeRepositoryMockGet {
	if n == 0 {
		mmGet.mock.t.Fatalf("Times of TimeRepositoryMock.Get mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGet.expectedInvocations, n)
	mmGet.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGet
}

func (mmGet *mTimeRepositoryMockGet) invocationsDone() bool {
	if len(mmGet.expectations) == 0 && mmGet.defaultExpectation == nil && mmGet.mock.funcGet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGet.mock.afterGetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Get implements mm_repository.TimeRepository
func (mmGet *TimeRepositoryMock) Get(ctx context.Context) (i1 int, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	mmGet.t.Helper()

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(ctx)
	}

	mm_params := TimeRepositoryMockGetParams{ctx}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, &mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_want_ptrs := mmGet.GetMock.defaultExpectation.paramPtrs

		mm_got := TimeRepositoryMockGetParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGet.t.Errorf("TimeRepositoryMock.Get got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("TimeRepositoryMock.Get got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGet.GetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the TimeRepositoryMock.Get")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(ctx)
	}
	mmGet.t.Fatalf("Unexpected call to TimeRepositoryMock.Get. %v", ctx)
	return
}

// GetAfterCounter returns a count of finished TimeRepositoryMock.Get invocations
func (mmGet *TimeRepositoryMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of TimeRepositoryMock.Get invocations
func (mmGet *TimeRepositoryMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to TimeRepositoryMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mTimeRepositoryMockGet) Calls() []*TimeRepositoryMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*TimeRepositoryMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *TimeRepositoryMock) MinimockGetDone() bool {
	if m.GetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetMock.invocationsDone()
}

// MinimockGetInspect logs each unmet expectation
func (m *TimeRepositoryMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TimeRepositoryMock.Get at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCounter := mm_atomic.LoadUint64(&m.afterGetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && afterGetCounter < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TimeRepositoryMock.Get at\n%s", m.GetMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TimeRepositoryMock.Get at\n%s with params: %#v", m.GetMock.defaultExpectation.expectationOrigins.origin, *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && afterGetCounter < 1 {
		m.t.Errorf("Expected call to TimeRepositoryMock.Get at\n%s", m.funcGetOrigin)
	}

	if !m.GetMock.invocationsDone() && afterGetCounter > 0 {
		m.t.Errorf("Expected %d calls to TimeRepositoryMock.Get at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetMock.expectedInvocations), m.GetMock.expectedInvocationsOrigin, afterGetCounter)
	}
}

type mTimeRepositoryMockSet struct {
	optional           bool
	mock               *TimeRepositoryMock
	defaultExpectation *TimeRepositoryMockSetExpectation
	expectations       []*TimeRepositoryMockSetExpectation

	callArgs []*TimeRepositoryMockSetParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TimeRepositoryMockSetExpectation specifies expectation struct of the TimeRepository.Set
type TimeRepositoryMockSetExpectation struct {
	mock               *TimeRepositoryMock
	params             *TimeRepositoryMockSetParams
	paramPtrs          *TimeRepositoryMockSetParamPtrs
	expectationOrigins TimeRepositoryMockSetExpectationOrigins
	results            *TimeRepositoryMockSetResults
	returnOrigin       string
	Counter            uint64
}

// TimeRepositoryMockSetParams contains parameters of the TimeRepository.Set
type TimeRepositoryMockSetParams struct {
	ctx context.Context
	day int
}

// TimeRepositoryMockSetParamPtrs contains pointers to parameters of the TimeRepository.Set
type TimeRepositoryMockSetParamPtrs struct {
	ctx *context.Context
	day *int
}

// TimeRepositoryMockSetResults contains results of the TimeRepository.Set
type TimeRepositoryMockSetResults struct {
	err error
}

// TimeRepositoryMockSetOrigins contains origins of expectations of the TimeRepository.Set
type TimeRepositoryMockSetExpectationOrigins struct {
	origin    string
	originCtx string
	originDay string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSet *mTimeRepositoryMockSet) Optional() *mTimeRepositoryMockSet {
	mmSet.optional = true
	return mmSet
}

// Expect sets up expected params for TimeRepository.Set
func (mmSet *mTimeRepositoryMockSet) Expect(ctx context.Context, day int) *mTimeRepositoryMockSet {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("TimeRepositoryMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &TimeRepositoryMockSetExpectation{}
	}

	if mmSet.defaultExpectation.paramPtrs != nil {
		mmSet.mock.t.Fatalf("TimeRepositoryMock.Set mock is already set by ExpectParams functions")
	}

	mmSet.defaultExpectation.params = &TimeRepositoryMockSetParams{ctx, day}
	mmSet.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSet.expectations {
		if minimock.Equal(e.params, mmSet.defaultExpectation.params) {
			mmSet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSet.defaultExpectation.params)
		}
	}

	return mmSet
}

// ExpectCtxParam1 sets up expected param ctx for TimeRepository.Set
func (mmSet *mTimeRepositoryMockSet) ExpectCtxParam1(ctx context.Context) *mTimeRepositoryMockSet {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("TimeRepositoryMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &TimeRepositoryMockSetExpectation{}
	}

	if mmSet.defaultExpectation.params != nil {
		mmSet.mock.t.Fatalf("TimeRepositoryMock.Set mock is already set by Expect")
	}

	if mmSet.defaultExpectation.paramPtrs == nil {
		mmSet.defaultExpectation.paramPtrs = &TimeRepositoryMockSetParamPtrs{}
	}
	mmSet.defaultExpectation.paramPtrs.ctx = &ctx
	mmSet.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSet
}

// ExpectDayParam2 sets up expected param day for TimeRepository.Set
func (mmSet *mTimeRepositoryMockSet) ExpectDayParam2(day int) *mTimeRepositoryMockSet {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("TimeRepositoryMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &TimeRepositoryMockSetExpectation{}
	}

	if mmSet.defaultExpectation.params != nil {
		mmSet.mock.t.Fatalf("TimeRepositoryMock.Set mock is already set by Expect")
	}

	if mmSet.defaultExpectation.paramPtrs == nil {
		mmSet.defaultExpectation.paramPtrs = &TimeRepositoryMockSetParamPtrs{}
	}
	mmSet.defaultExpectation.paramPtrs.day = &day
	mmSet.defaultExpectation.expectationOrigins.originDay = minimock.CallerInfo(1)

	return mmSet
}

// Inspect accepts an inspector function that has same arguments as the TimeRepository.Set
func (mmSet *mTimeRepositoryMockSet) Inspect(f func(ctx context.Context, day int)) *mTimeRepositoryMockSet {
	if mmSet.mock.inspectFuncSet != nil {
		mmSet.mock.t.Fatalf("Inspect function is already set for TimeRepositoryMock.Set")
	}

	mmSet.mock.inspectFuncSet = f

	return mmSet
}

// Return sets up results that will be returned by TimeRepository.Set
func (mmSet *mTimeRepositoryMockSet) Return(err error) *TimeRepositoryMock {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("TimeRepositoryMock.Set mock is already set by Set")
	}

	if mmSet.defaultExpectation == nil {
		mmSet.defaultExpectation = &TimeRepositoryMockSetExpectation{mock: mmSet.mock}
	}
	mmSet.defaultExpectation.results = &TimeRepositoryMockSetResults{err}
	mmSet.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSet.mock
}

// Set uses given function f to mock the TimeRepository.Set method
func (mmSet *mTimeRepositoryMockSet) Set(f func(ctx context.Context, day int) (err error)) *TimeRepositoryMock {
	if mmSet.defaultExpectation != nil {
		mmSet.mock.t.Fatalf("Default expectation is already set for the TimeRepository.Set method")
	}

	if len(mmSet.expectations) > 0 {
		mmSet.mock.t.Fatalf("Some expectations are already set for the TimeRepository.Set method")
	}

	mmSet.mock.funcSet = f
	mmSet.mock.funcSetOrigin = minimock.CallerInfo(1)
	return mmSet.mock
}

// When sets expectation for the TimeRepository.Set which will trigger the result defined by the following
// Then helper
func (mmSet *mTimeRepositoryMockSet) When(ctx context.Context, day int) *TimeRepositoryMockSetExpectation {
	if mmSet.mock.funcSet != nil {
		mmSet.mock.t.Fatalf("TimeRepositoryMock.Set mock is already set by Set")
	}

	expectation := &TimeRepositoryMockSetExpectation{
		mock:               mmSet.mock,
		params:             &TimeRepositoryMockSetParams{ctx, day},
		expectationOrigins: TimeRepositoryMockSetExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSet.expectations = append(mmSet.expectations, expectation)
	return expectation
}

// Then sets up TimeRepository.Set return parameters for the expectation previously defined by the When method
func (e *TimeRepositoryMockSetExpectation) Then(err error) *TimeRepositoryMock {
	e.results = &TimeRepositoryMockSetResults{err}
	return e.mock
}

// Times sets number of times TimeRepository.Set should be invoked
func (mmSet *mTimeRepositoryMockSet) Times(n uint64) *mTimeRepositoryMockSet {
	if n == 0 {
		mmSet.mock.t.Fatalf("Times of TimeRepositoryMock.Set mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSet.expectedInvocations, n)
	mmSet.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSet
}

func (mmSet *mTimeRepositoryMockSet) invocationsDone() bool {
	if len(mmSet.expectations) == 0 && mmSet.defaultExpectation == nil && mmSet.mock.funcSet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSet.mock.afterSetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Set implements mm_repository.TimeRepository
func (mmSet *TimeRepositoryMock) Set(ctx context.Context, day int) (err error) {
	mm_atomic.AddUint64(&mmSet.beforeSetCounter, 1)
	defer mm_atomic.AddUint64(&mmSet.afterSetCounter, 1)

	mmSet.t.Helper()

	if mmSet.inspectFuncSet != nil {
		mmSet.inspectFuncSet(ctx, day)
	}

	mm_params := TimeRepositoryMockSetParams{ctx, day}

	// Record call args
	mmSet.SetMock.mutex.Lock()
	mmSet.SetMock.callArgs = append(mmSet.SetMock.callArgs, &mm_params)
	mmSet.SetMock.mutex.Unlock()

	for _, e := range mmSet.SetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSet.SetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSet.SetMock.defaultExpectation.Counter, 1)
		mm_want := mmSet.SetMock.defaultExpectation.params
		mm_want_ptrs := mmSet.SetMock.defaultExpectation.paramPtrs

		mm_got := TimeRepositoryMockSetParams{ctx, day}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSet.t.Errorf("TimeRepositoryMock.Set got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSet.SetMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.day != nil && !minimock.Equal(*mm_want_ptrs.day, mm_got.day) {
				mmSet.t.Errorf("TimeRepositoryMock.Set got unexpected parameter day, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSet.SetMock.defaultExpectation.expectationOrigins.originDay, *mm_want_ptrs.day, mm_got.day, minimock.Diff(*mm_want_ptrs.day, mm_got.day))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSet.t.Errorf("TimeRepositoryMock.Set got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSet.SetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSet.SetMock.defaultExpectation.results
		if mm_results == nil {
			mmSet.t.Fatal("No results are set for the TimeRepositoryMock.Set")
		}
		return (*mm_results).err
	}
	if mmSet.funcSet != nil {
		return mmSet.funcSet(ctx, day)
	}
	mmSet.t.Fatalf("Unexpected call to TimeRepositoryMock.Set. %v %v", ctx, day)
	return
}

// SetAfterCounter returns a count of finished TimeRepositoryMock.Set invocations
func (mmSet *TimeRepositoryMock) SetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSet.afterSetCounter)
}

// SetBeforeCounter returns a count of TimeRepositoryMock.Set invocations
func (mmSet *TimeRepositoryMock) SetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSet.beforeSetCounter)
}

// Calls returns a list of arguments used in each call to TimeRepositoryMock.Set.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSet *mTimeRepositoryMockSet) Calls() []*TimeRepositoryMockSetParams {
	mmSet.mutex.RLock()

	argCopy := make([]*TimeRepositoryMockSetParams, len(mmSet.callArgs))
	copy(argCopy, mmSet.callArgs)

	mmSet.mutex.RUnlock()

	return argCopy
}

// MinimockSetDone returns true if the count of the Set invocations corresponds
// the number of defined expectations
func (m *TimeRepositoryMock) MinimockSetDone() bool {
	if m.SetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetMock.invocationsDone()
}

// MinimockSetInspect logs each unmet expectation
func (m *TimeRepositoryMock) MinimockSetInspect() {
	for _, e := range m.SetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TimeRepositoryMock.Set at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetCounter := mm_atomic.LoadUint64(&m.afterSetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetMock.defaultExpectation != nil && afterSetCounter < 1 {
		if m.SetMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TimeRepositoryMock.Set at\n%s", m.SetMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TimeRepositoryMock.Set at\n%s with params: %#v", m.SetMock.defaultExpectation.expectationOrigins.origin, *m.SetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSet != nil && afterSetCounter < 1 {
		m.t.Errorf("Expected call to TimeRepositoryMock.Set at\n%s", m.funcSetOrigin)
	}

	if !m.SetMock.invocationsDone() && afterSetCounter > 0 {
		m.t.Errorf("Expected %d calls to TimeRepositoryMock.Set at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetMock.expectedInvocations), m.SetMock.expectedInvocationsOrigin, afterSetCounter)
	}
}

type mTimeRepositoryMockUpdateCampaignsState struct {
	optional           bool
	mock               *TimeRepositoryMock
	defaultExpectation *TimeRepositoryMockUpdateCampaignsStateExpectation
	expectations       []*TimeRepositoryMockUpdateCampaignsStateExpectation

	callArgs []*TimeRepositoryMockUpdateCampaignsStateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// TimeRepositoryMockUpdateCampaignsStateExpectation specifies expectation struct of the TimeRepository.UpdateCampaignsState
type TimeRepositoryMockUpdateCampaignsStateExpectation struct {
	mock               *TimeRepositoryMock
	params             *TimeRepositoryMockUpdateCampaignsStateParams
	paramPtrs          *TimeRepositoryMockUpdateCampaignsStateParamPtrs
	expectationOrigins TimeRepositoryMockUpdateCampaignsStateExpectationOrigins
	results            *TimeRepositoryMockUpdateCampaignsStateResults
	returnOrigin       string
	Counter            uint64
}

// TimeRepositoryMockUpdateCampaignsStateParams contains parameters of the TimeRepository.UpdateCampaignsState
type TimeRepositoryMockUpdateCampaignsStateParams struct {
	ctx context.Context
}

// TimeRepositoryMockUpdateCampaignsStateParamPtrs contains pointers to parameters of the TimeRepository.UpdateCampaignsState
type TimeRepositoryMockUpdateCampaignsStateParamPtrs struct {
	ctx *context.Context
}

// TimeRepositoryMockUpdateCampaignsStateResults contains results of the TimeRepository.UpdateCampaignsState
type TimeRepositoryMockUpdateCampaignsStateResults struct {
	err error
}

// TimeRepositoryMockUpdateCampaignsStateOrigins contains origins of expectations of the TimeRepository.UpdateCampaignsState
type TimeRepositoryMockUpdateCampaignsStateExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateCampaignsState *mTimeRepositoryMockUpdateCampaignsState) Optional() *mTimeRepositoryMockUpdateCampaignsState {
	mmUpdateCampaignsState.optional = true
	return mmUpdateCampaignsState
}

// Expect sets up expected params for TimeRepository.UpdateCampaignsState
func (mmUpdateCampaignsState *mTimeRepositoryMockUpdateCampaignsState) Expect(ctx context.Context) *mTimeRepositoryMockUpdateCampaignsState {
	if mmUpdateCampaignsState.mock.funcUpdateCampaignsState != nil {
		mmUpdateCampaignsState.mock.t.Fatalf("TimeRepositoryMock.UpdateCampaignsState mock is already set by Set")
	}

	if mmUpdateCampaignsState.defaultExpectation == nil {
		mmUpdateCampaignsState.defaultExpectation = &TimeRepositoryMockUpdateCampaignsStateExpectation{}
	}

	if mmUpdateCampaignsState.defaultExpectation.paramPtrs != nil {
		mmUpdateCampaignsState.mock.t.Fatalf("TimeRepositoryMock.UpdateCampaignsState mock is already set by ExpectParams functions")
	}

	mmUpdateCampaignsState.defaultExpectation.params = &TimeRepositoryMockUpdateCampaignsStateParams{ctx}
	mmUpdateCampaignsState.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateCampaignsState.expectations {
		if minimock.Equal(e.params, mmUpdateCampaignsState.defaultExpectation.params) {
			mmUpdateCampaignsState.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateCampaignsState.defaultExpectation.params)
		}
	}

	return mmUpdateCampaignsState
}

// ExpectCtxParam1 sets up expected param ctx for TimeRepository.UpdateCampaignsState
func (mmUpdateCampaignsState *mTimeRepositoryMockUpdateCampaignsState) ExpectCtxParam1(ctx context.Context) *mTimeRepositoryMockUpdateCampaignsState {
	if mmUpdateCampaignsState.mock.funcUpdateCampaignsState != nil {
		mmUpdateCampaignsState.mock.t.Fatalf("TimeRepositoryMock.UpdateCampaignsState mock is already set by Set")
	}

	if mmUpdateCampaignsState.defaultExpectation == nil {
		mmUpdateCampaignsState.defaultExpectation = &TimeRepositoryMockUpdateCampaignsStateExpectation{}
	}

	if mmUpdateCampaignsState.defaultExpectation.params != nil {
		mmUpdateCampaignsState.mock.t.Fatalf("TimeRepositoryMock.UpdateCampaignsState mock is already set by Expect")
	}

	if mmUpdateCampaignsState.defaultExpectation.paramPtrs == nil {
		mmUpdateCampaignsState.defaultExpectation.paramPtrs = &TimeRepositoryMockUpdateCampaignsStateParamPtrs{}
	}
	mmUpdateCampaignsState.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateCampaignsState.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateCampaignsState
}

// Inspect accepts an inspector function that has same arguments as the TimeRepository.UpdateCampaignsState
func (mmUpdateCampaignsState *mTimeRepositoryMockUpdateCampaignsState) Inspect(f func(ctx context.Context)) *mTimeRepositoryMockUpdateCampaignsState {
	if mmUpdateCampaignsState.mock.inspectFuncUpdateCampaignsState != nil {
		mmUpdateCampaignsState.mock.t.Fatalf("Inspect function is already set for TimeRepositoryMock.UpdateCampaignsState")
	}

	mmUpdateCampaignsState.mock.inspectFuncUpdateCampaignsState = f

	return mmUpdateCampaignsState
}

// Return sets up results that will be returned by TimeRepository.UpdateCampaignsState
func (mmUpdateCampaignsState *mTimeRepositoryMockUpdateCampaignsState) Return(err error) *TimeRepositoryMock {
	if mmUpdateCampaignsState.mock.funcUpdateCampaignsState != nil {
		mmUpdateCampaignsState.mock.t.Fatalf("TimeRepositoryMock.UpdateCampaignsState mock is already set by Set")
	}

	if mmUpdateCampaignsState.defaultExpectation == nil {
		mmUpdateCampaignsState.defaultExpectation = &TimeRepositoryMockUpdateCampaignsStateExpectation{mock: mmUpdateCampaignsState.mock}
	}
	mmUpdateCampaignsState.defaultExpectation.results = &TimeRepositoryMockUpdateCampaignsStateResults{err}
	mmUpdateCampaignsState.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateCampaignsState.mock
}

// Set uses given function f to mock the TimeRepository.UpdateCampaignsState method
func (mmUpdateCampaignsState *mTimeRepositoryMockUpdateCampaignsState) Set(f func(ctx context.Context) (err error)) *TimeRepositoryMock {
	if mmUpdateCampaignsState.defaultExpectation != nil {
		mmUpdateCampaignsState.mock.t.Fatalf("Default expectation is already set for the TimeRepository.UpdateCampaignsState method")
	}

	if len(mmUpdateCampaignsState.expectations) > 0 {
		mmUpdateCampaignsState.mock.t.Fatalf("Some expectations are already set for the TimeRepository.UpdateCampaignsState method")
	}

	mmUpdateCampaignsState.mock.funcUpdateCampaignsState = f
	mmUpdateCampaignsState.mock.funcUpdateCampaignsStateOrigin = minimock.CallerInfo(1)
	return mmUpdateCampaignsState.mock
}

// When sets expectation for the TimeRepository.UpdateCampaignsState which will trigger the result defined by the following
// Then helper
func (mmUpdateCampaignsState *mTimeRepositoryMockUpdateCampaignsState) When(ctx context.Context) *TimeRepositoryMockUpdateCampaignsStateExpectation {
	if mmUpdateCampaignsState.mock.funcUpdateCampaignsState != nil {
		mmUpdateCampaignsState.mock.t.Fatalf("TimeRepositoryMock.UpdateCampaignsState mock is already set by Set")
	}

	expectation := &TimeRepositoryMockUpdateCampaignsStateExpectation{
		mock:               mmUpdateCampaignsState.mock,
		params:             &TimeRepositoryMockUpdateCampaignsStateParams{ctx},
		expectationOrigins: TimeRepositoryMockUpdateCampaignsStateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateCampaignsState.expectations = append(mmUpdateCampaignsState.expectations, expectation)
	return expectation
}

// Then sets up TimeRepository.UpdateCampaignsState return parameters for the expectation previously defined by the When method
func (e *TimeRepositoryMockUpdateCampaignsStateExpectation) Then(err error) *TimeRepositoryMock {
	e.results = &TimeRepositoryMockUpdateCampaignsStateResults{err}
	return e.mock
}

// Times sets number of times TimeRepository.UpdateCampaignsState should be invoked
func (mmUpdateCampaignsState *mTimeRepositoryMockUpdateCampaignsState) Times(n uint64) *mTimeRepositoryMockUpdateCampaignsState {
	if n == 0 {
		mmUpdateCampaignsState.mock.t.Fatalf("Times of TimeRepositoryMock.UpdateCampaignsState mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateCampaignsState.expectedInvocations, n)
	mmUpdateCampaignsState.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateCampaignsState
}

func (mmUpdateCampaignsState *mTimeRepositoryMockUpdateCampaignsState) invocationsDone() bool {
	if len(mmUpdateCampaignsState.expectations) == 0 && mmUpdateCampaignsState.defaultExpectation == nil && mmUpdateCampaignsState.mock.funcUpdateCampaignsState == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateCampaignsState.mock.afterUpdateCampaignsStateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateCampaignsState.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateCampaignsState implements mm_repository.TimeRepository
func (mmUpdateCampaignsState *TimeRepositoryMock) UpdateCampaignsState(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmUpdateCampaignsState.beforeUpdateCampaignsStateCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateCampaignsState.afterUpdateCampaignsStateCounter, 1)

	mmUpdateCampaignsState.t.Helper()

	if mmUpdateCampaignsState.inspectFuncUpdateCampaignsState != nil {
		mmUpdateCampaignsState.inspectFuncUpdateCampaignsState(ctx)
	}

	mm_params := TimeRepositoryMockUpdateCampaignsStateParams{ctx}

	// Record call args
	mmUpdateCampaignsState.UpdateCampaignsStateMock.mutex.Lock()
	mmUpdateCampaignsState.UpdateCampaignsStateMock.callArgs = append(mmUpdateCampaignsState.UpdateCampaignsStateMock.callArgs, &mm_params)
	mmUpdateCampaignsState.UpdateCampaignsStateMock.mutex.Unlock()

	for _, e := range mmUpdateCampaignsState.UpdateCampaignsStateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateCampaignsState.UpdateCampaignsStateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateCampaignsState.UpdateCampaignsStateMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateCampaignsState.UpdateCampaignsStateMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateCampaignsState.UpdateCampaignsStateMock.defaultExpectation.paramPtrs

		mm_got := TimeRepositoryMockUpdateCampaignsStateParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateCampaignsState.t.Errorf("TimeRepositoryMock.UpdateCampaignsState got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateCampaignsState.UpdateCampaignsStateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateCampaignsState.t.Errorf("TimeRepositoryMock.UpdateCampaignsState got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateCampaignsState.UpdateCampaignsStateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateCampaignsState.UpdateCampaignsStateMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateCampaignsState.t.Fatal("No results are set for the TimeRepositoryMock.UpdateCampaignsState")
		}
		return (*mm_results).err
	}
	if mmUpdateCampaignsState.funcUpdateCampaignsState != nil {
		return mmUpdateCampaignsState.funcUpdateCampaignsState(ctx)
	}
	mmUpdateCampaignsState.t.Fatalf("Unexpected call to TimeRepositoryMock.UpdateCampaignsState. %v", ctx)
	return
}

// UpdateCampaignsStateAfterCounter returns a count of finished TimeRepositoryMock.UpdateCampaignsState invocations
func (mmUpdateCampaignsState *TimeRepositoryMock) UpdateCampaignsStateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateCampaignsState.afterUpdateCampaignsStateCounter)
}

// UpdateCampaignsStateBeforeCounter returns a count of TimeRepositoryMock.UpdateCampaignsState invocations
func (mmUpdateCampaignsState *TimeRepositoryMock) UpdateCampaignsStateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateCampaignsState.beforeUpdateCampaignsStateCounter)
}

// Calls returns a list of arguments used in each call to TimeRepositoryMock.UpdateCampaignsState.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateCampaignsState *mTimeRepositoryMockUpdateCampaignsState) Calls() []*TimeRepositoryMockUpdateCampaignsStateParams {
	mmUpdateCampaignsState.mutex.RLock()

	argCopy := make([]*TimeRepositoryMockUpdateCampaignsStateParams, len(mmUpdateCampaignsState.callArgs))
	copy(argCopy, mmUpdateCampaignsState.callArgs)

	mmUpdateCampaignsState.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateCampaignsStateDone returns true if the count of the UpdateCampaignsState invocations corresponds
// the number of defined expectations
func (m *TimeRepositoryMock) MinimockUpdateCampaignsStateDone() bool {
	if m.UpdateCampaignsStateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateCampaignsStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateCampaignsStateMock.invocationsDone()
}

// MinimockUpdateCampaignsStateInspect logs each unmet expectation
func (m *TimeRepositoryMock) MinimockUpdateCampaignsStateInspect() {
	for _, e := range m.UpdateCampaignsStateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to TimeRepositoryMock.UpdateCampaignsState at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateCampaignsStateCounter := mm_atomic.LoadUint64(&m.afterUpdateCampaignsStateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateCampaignsStateMock.defaultExpectation != nil && afterUpdateCampaignsStateCounter < 1 {
		if m.UpdateCampaignsStateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to TimeRepositoryMock.UpdateCampaignsState at\n%s", m.UpdateCampaignsStateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to TimeRepositoryMock.UpdateCampaignsState at\n%s with params: %#v", m.UpdateCampaignsStateMock.defaultExpectation.expectationOrigins.origin, *m.UpdateCampaignsStateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateCampaignsState != nil && afterUpdateCampaignsStateCounter < 1 {
		m.t.Errorf("Expected call to TimeRepositoryMock.UpdateCampaignsState at\n%s", m.funcUpdateCampaignsStateOrigin)
	}

	if !m.UpdateCampaignsStateMock.invocationsDone() && afterUpdateCampaignsStateCounter > 0 {
		m.t.Errorf("Expected %d calls to TimeRepositoryMock.UpdateCampaignsState at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateCampaignsStateMock.expectedInvocations), m.UpdateCampaignsStateMock.expectedInvocationsOrigin, afterUpdateCampaignsStateCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *TimeRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetInspect()

			m.MinimockSetInspect()

			m.MinimockUpdateCampaignsStateInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *TimeRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *TimeRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetDone() &&
		m.MinimockSetDone() &&
		m.MinimockUpdateCampaignsStateDone()
}
