// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i server/internal/repository.AdsRepsitory -o ads_repsitory_minimock.go -n AdsRepsitoryMock -p mocks

import (
	"context"
	"server/internal/model"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// AdsRepsitoryMock implements mm_repository.AdsRepsitory
type AdsRepsitoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcClick          func(ctx context.Context, campaignID string, clientID string) (err error)
	funcClickOrigin    string
	inspectFuncClick   func(ctx context.Context, campaignID string, clientID string)
	afterClickCounter  uint64
	beforeClickCounter uint64
	ClickMock          mAdsRepsitoryMockClick

	funcGet          func(ctx context.Context, clientID string) (s1 string, i1 int, f1 float64, err error)
	funcGetOrigin    string
	inspectFuncGet   func(ctx context.Context, clientID string)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mAdsRepsitoryMockGet

	funcImpression          func(ctx context.Context, campaignID string, clientID string, cost float64) (cp1 *model.Campaign, err error)
	funcImpressionOrigin    string
	inspectFuncImpression   func(ctx context.Context, campaignID string, clientID string, cost float64)
	afterImpressionCounter  uint64
	beforeImpressionCounter uint64
	ImpressionMock          mAdsRepsitoryMockImpression

	funcIsShownToClient          func(ctx context.Context, campaignID string, clientID string) (b1 bool, err error)
	funcIsShownToClientOrigin    string
	inspectFuncIsShownToClient   func(ctx context.Context, campaignID string, clientID string)
	afterIsShownToClientCounter  uint64
	beforeIsShownToClientCounter uint64
	IsShownToClientMock          mAdsRepsitoryMockIsShownToClient
}

// NewAdsRepsitoryMock returns a mock for mm_repository.AdsRepsitory
func NewAdsRepsitoryMock(t minimock.Tester) *AdsRepsitoryMock {
	m := &AdsRepsitoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ClickMock = mAdsRepsitoryMockClick{mock: m}
	m.ClickMock.callArgs = []*AdsRepsitoryMockClickParams{}

	m.GetMock = mAdsRepsitoryMockGet{mock: m}
	m.GetMock.callArgs = []*AdsRepsitoryMockGetParams{}

	m.ImpressionMock = mAdsRepsitoryMockImpression{mock: m}
	m.ImpressionMock.callArgs = []*AdsRepsitoryMockImpressionParams{}

	m.IsShownToClientMock = mAdsRepsitoryMockIsShownToClient{mock: m}
	m.IsShownToClientMock.callArgs = []*AdsRepsitoryMockIsShownToClientParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mAdsRepsitoryMockClick struct {
	optional           bool
	mock               *AdsRepsitoryMock
	defaultExpectation *AdsRepsitoryMockClickExpectation
	expectations       []*AdsRepsitoryMockClickExpectation

	callArgs []*AdsRepsitoryMockClickParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AdsRepsitoryMockClickExpectation specifies expectation struct of the AdsRepsitory.Click
type AdsRepsitoryMockClickExpectation struct {
	mock               *AdsRepsitoryMock
	params             *AdsRepsitoryMockClickParams
	paramPtrs          *AdsRepsitoryMockClickParamPtrs
	expectationOrigins AdsRepsitoryMockClickExpectationOrigins
	results            *AdsRepsitoryMockClickResults
	returnOrigin       string
	Counter            uint64
}

// AdsRepsitoryMockClickParams contains parameters of the AdsRepsitory.Click
type AdsRepsitoryMockClickParams struct {
	ctx        context.Context
	campaignID string
	clientID   string
}

// AdsRepsitoryMockClickParamPtrs contains pointers to parameters of the AdsRepsitory.Click
type AdsRepsitoryMockClickParamPtrs struct {
	ctx        *context.Context
	campaignID *string
	clientID   *string
}

// AdsRepsitoryMockClickResults contains results of the AdsRepsitory.Click
type AdsRepsitoryMockClickResults struct {
	err error
}

// AdsRepsitoryMockClickOrigins contains origins of expectations of the AdsRepsitory.Click
type AdsRepsitoryMockClickExpectationOrigins struct {
	origin           string
	originCtx        string
	originCampaignID string
	originClientID   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmClick *mAdsRepsitoryMockClick) Optional() *mAdsRepsitoryMockClick {
	mmClick.optional = true
	return mmClick
}

// Expect sets up expected params for AdsRepsitory.Click
func (mmClick *mAdsRepsitoryMockClick) Expect(ctx context.Context, campaignID string, clientID string) *mAdsRepsitoryMockClick {
	if mmClick.mock.funcClick != nil {
		mmClick.mock.t.Fatalf("AdsRepsitoryMock.Click mock is already set by Set")
	}

	if mmClick.defaultExpectation == nil {
		mmClick.defaultExpectation = &AdsRepsitoryMockClickExpectation{}
	}

	if mmClick.defaultExpectation.paramPtrs != nil {
		mmClick.mock.t.Fatalf("AdsRepsitoryMock.Click mock is already set by ExpectParams functions")
	}

	mmClick.defaultExpectation.params = &AdsRepsitoryMockClickParams{ctx, campaignID, clientID}
	mmClick.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmClick.expectations {
		if minimock.Equal(e.params, mmClick.defaultExpectation.params) {
			mmClick.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmClick.defaultExpectation.params)
		}
	}

	return mmClick
}

// ExpectCtxParam1 sets up expected param ctx for AdsRepsitory.Click
func (mmClick *mAdsRepsitoryMockClick) ExpectCtxParam1(ctx context.Context) *mAdsRepsitoryMockClick {
	if mmClick.mock.funcClick != nil {
		mmClick.mock.t.Fatalf("AdsRepsitoryMock.Click mock is already set by Set")
	}

	if mmClick.defaultExpectation == nil {
		mmClick.defaultExpectation = &AdsRepsitoryMockClickExpectation{}
	}

	if mmClick.defaultExpectation.params != nil {
		mmClick.mock.t.Fatalf("AdsRepsitoryMock.Click mock is already set by Expect")
	}

	if mmClick.defaultExpectation.paramPtrs == nil {
		mmClick.defaultExpectation.paramPtrs = &AdsRepsitoryMockClickParamPtrs{}
	}
	mmClick.defaultExpectation.paramPtrs.ctx = &ctx
	mmClick.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmClick
}

// ExpectCampaignIDParam2 sets up expected param campaignID for AdsRepsitory.Click
func (mmClick *mAdsRepsitoryMockClick) ExpectCampaignIDParam2(campaignID string) *mAdsRepsitoryMockClick {
	if mmClick.mock.funcClick != nil {
		mmClick.mock.t.Fatalf("AdsRepsitoryMock.Click mock is already set by Set")
	}

	if mmClick.defaultExpectation == nil {
		mmClick.defaultExpectation = &AdsRepsitoryMockClickExpectation{}
	}

	if mmClick.defaultExpectation.params != nil {
		mmClick.mock.t.Fatalf("AdsRepsitoryMock.Click mock is already set by Expect")
	}

	if mmClick.defaultExpectation.paramPtrs == nil {
		mmClick.defaultExpectation.paramPtrs = &AdsRepsitoryMockClickParamPtrs{}
	}
	mmClick.defaultExpectation.paramPtrs.campaignID = &campaignID
	mmClick.defaultExpectation.expectationOrigins.originCampaignID = minimock.CallerInfo(1)

	return mmClick
}

// ExpectClientIDParam3 sets up expected param clientID for AdsRepsitory.Click
func (mmClick *mAdsRepsitoryMockClick) ExpectClientIDParam3(clientID string) *mAdsRepsitoryMockClick {
	if mmClick.mock.funcClick != nil {
		mmClick.mock.t.Fatalf("AdsRepsitoryMock.Click mock is already set by Set")
	}

	if mmClick.defaultExpectation == nil {
		mmClick.defaultExpectation = &AdsRepsitoryMockClickExpectation{}
	}

	if mmClick.defaultExpectation.params != nil {
		mmClick.mock.t.Fatalf("AdsRepsitoryMock.Click mock is already set by Expect")
	}

	if mmClick.defaultExpectation.paramPtrs == nil {
		mmClick.defaultExpectation.paramPtrs = &AdsRepsitoryMockClickParamPtrs{}
	}
	mmClick.defaultExpectation.paramPtrs.clientID = &clientID
	mmClick.defaultExpectation.expectationOrigins.originClientID = minimock.CallerInfo(1)

	return mmClick
}

// Inspect accepts an inspector function that has same arguments as the AdsRepsitory.Click
func (mmClick *mAdsRepsitoryMockClick) Inspect(f func(ctx context.Context, campaignID string, clientID string)) *mAdsRepsitoryMockClick {
	if mmClick.mock.inspectFuncClick != nil {
		mmClick.mock.t.Fatalf("Inspect function is already set for AdsRepsitoryMock.Click")
	}

	mmClick.mock.inspectFuncClick = f

	return mmClick
}

// Return sets up results that will be returned by AdsRepsitory.Click
func (mmClick *mAdsRepsitoryMockClick) Return(err error) *AdsRepsitoryMock {
	if mmClick.mock.funcClick != nil {
		mmClick.mock.t.Fatalf("AdsRepsitoryMock.Click mock is already set by Set")
	}

	if mmClick.defaultExpectation == nil {
		mmClick.defaultExpectation = &AdsRepsitoryMockClickExpectation{mock: mmClick.mock}
	}
	mmClick.defaultExpectation.results = &AdsRepsitoryMockClickResults{err}
	mmClick.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmClick.mock
}

// Set uses given function f to mock the AdsRepsitory.Click method
func (mmClick *mAdsRepsitoryMockClick) Set(f func(ctx context.Context, campaignID string, clientID string) (err error)) *AdsRepsitoryMock {
	if mmClick.defaultExpectation != nil {
		mmClick.mock.t.Fatalf("Default expectation is already set for the AdsRepsitory.Click method")
	}

	if len(mmClick.expectations) > 0 {
		mmClick.mock.t.Fatalf("Some expectations are already set for the AdsRepsitory.Click method")
	}

	mmClick.mock.funcClick = f
	mmClick.mock.funcClickOrigin = minimock.CallerInfo(1)
	return mmClick.mock
}

// When sets expectation for the AdsRepsitory.Click which will trigger the result defined by the following
// Then helper
func (mmClick *mAdsRepsitoryMockClick) When(ctx context.Context, campaignID string, clientID string) *AdsRepsitoryMockClickExpectation {
	if mmClick.mock.funcClick != nil {
		mmClick.mock.t.Fatalf("AdsRepsitoryMock.Click mock is already set by Set")
	}

	expectation := &AdsRepsitoryMockClickExpectation{
		mock:               mmClick.mock,
		params:             &AdsRepsitoryMockClickParams{ctx, campaignID, clientID},
		expectationOrigins: AdsRepsitoryMockClickExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmClick.expectations = append(mmClick.expectations, expectation)
	return expectation
}

// Then sets up AdsRepsitory.Click return parameters for the expectation previously defined by the When method
func (e *AdsRepsitoryMockClickExpectation) Then(err error) *AdsRepsitoryMock {
	e.results = &AdsRepsitoryMockClickResults{err}
	return e.mock
}

// Times sets number of times AdsRepsitory.Click should be invoked
func (mmClick *mAdsRepsitoryMockClick) Times(n uint64) *mAdsRepsitoryMockClick {
	if n == 0 {
		mmClick.mock.t.Fatalf("Times of AdsRepsitoryMock.Click mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmClick.expectedInvocations, n)
	mmClick.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmClick
}

func (mmClick *mAdsRepsitoryMockClick) invocationsDone() bool {
	if len(mmClick.expectations) == 0 && mmClick.defaultExpectation == nil && mmClick.mock.funcClick == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmClick.mock.afterClickCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmClick.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Click implements mm_repository.AdsRepsitory
func (mmClick *AdsRepsitoryMock) Click(ctx context.Context, campaignID string, clientID string) (err error) {
	mm_atomic.AddUint64(&mmClick.beforeClickCounter, 1)
	defer mm_atomic.AddUint64(&mmClick.afterClickCounter, 1)

	mmClick.t.Helper()

	if mmClick.inspectFuncClick != nil {
		mmClick.inspectFuncClick(ctx, campaignID, clientID)
	}

	mm_params := AdsRepsitoryMockClickParams{ctx, campaignID, clientID}

	// Record call args
	mmClick.ClickMock.mutex.Lock()
	mmClick.ClickMock.callArgs = append(mmClick.ClickMock.callArgs, &mm_params)
	mmClick.ClickMock.mutex.Unlock()

	for _, e := range mmClick.ClickMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmClick.ClickMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClick.ClickMock.defaultExpectation.Counter, 1)
		mm_want := mmClick.ClickMock.defaultExpectation.params
		mm_want_ptrs := mmClick.ClickMock.defaultExpectation.paramPtrs

		mm_got := AdsRepsitoryMockClickParams{ctx, campaignID, clientID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmClick.t.Errorf("AdsRepsitoryMock.Click got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmClick.ClickMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.campaignID != nil && !minimock.Equal(*mm_want_ptrs.campaignID, mm_got.campaignID) {
				mmClick.t.Errorf("AdsRepsitoryMock.Click got unexpected parameter campaignID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmClick.ClickMock.defaultExpectation.expectationOrigins.originCampaignID, *mm_want_ptrs.campaignID, mm_got.campaignID, minimock.Diff(*mm_want_ptrs.campaignID, mm_got.campaignID))
			}

			if mm_want_ptrs.clientID != nil && !minimock.Equal(*mm_want_ptrs.clientID, mm_got.clientID) {
				mmClick.t.Errorf("AdsRepsitoryMock.Click got unexpected parameter clientID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmClick.ClickMock.defaultExpectation.expectationOrigins.originClientID, *mm_want_ptrs.clientID, mm_got.clientID, minimock.Diff(*mm_want_ptrs.clientID, mm_got.clientID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmClick.t.Errorf("AdsRepsitoryMock.Click got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmClick.ClickMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmClick.ClickMock.defaultExpectation.results
		if mm_results == nil {
			mmClick.t.Fatal("No results are set for the AdsRepsitoryMock.Click")
		}
		return (*mm_results).err
	}
	if mmClick.funcClick != nil {
		return mmClick.funcClick(ctx, campaignID, clientID)
	}
	mmClick.t.Fatalf("Unexpected call to AdsRepsitoryMock.Click. %v %v %v", ctx, campaignID, clientID)
	return
}

// ClickAfterCounter returns a count of finished AdsRepsitoryMock.Click invocations
func (mmClick *AdsRepsitoryMock) ClickAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClick.afterClickCounter)
}

// ClickBeforeCounter returns a count of AdsRepsitoryMock.Click invocations
func (mmClick *AdsRepsitoryMock) ClickBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClick.beforeClickCounter)
}

// Calls returns a list of arguments used in each call to AdsRepsitoryMock.Click.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmClick *mAdsRepsitoryMockClick) Calls() []*AdsRepsitoryMockClickParams {
	mmClick.mutex.RLock()

	argCopy := make([]*AdsRepsitoryMockClickParams, len(mmClick.callArgs))
	copy(argCopy, mmClick.callArgs)

	mmClick.mutex.RUnlock()

	return argCopy
}

// MinimockClickDone returns true if the count of the Click invocations corresponds
// the number of defined expectations
func (m *AdsRepsitoryMock) MinimockClickDone() bool {
	if m.ClickMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ClickMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ClickMock.invocationsDone()
}

// MinimockClickInspect logs each unmet expectation
func (m *AdsRepsitoryMock) MinimockClickInspect() {
	for _, e := range m.ClickMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AdsRepsitoryMock.Click at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterClickCounter := mm_atomic.LoadUint64(&m.afterClickCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ClickMock.defaultExpectation != nil && afterClickCounter < 1 {
		if m.ClickMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AdsRepsitoryMock.Click at\n%s", m.ClickMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AdsRepsitoryMock.Click at\n%s with params: %#v", m.ClickMock.defaultExpectation.expectationOrigins.origin, *m.ClickMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClick != nil && afterClickCounter < 1 {
		m.t.Errorf("Expected call to AdsRepsitoryMock.Click at\n%s", m.funcClickOrigin)
	}

	if !m.ClickMock.invocationsDone() && afterClickCounter > 0 {
		m.t.Errorf("Expected %d calls to AdsRepsitoryMock.Click at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ClickMock.expectedInvocations), m.ClickMock.expectedInvocationsOrigin, afterClickCounter)
	}
}

type mAdsRepsitoryMockGet struct {
	optional           bool
	mock               *AdsRepsitoryMock
	defaultExpectation *AdsRepsitoryMockGetExpectation
	expectations       []*AdsRepsitoryMockGetExpectation

	callArgs []*AdsRepsitoryMockGetParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AdsRepsitoryMockGetExpectation specifies expectation struct of the AdsRepsitory.Get
type AdsRepsitoryMockGetExpectation struct {
	mock               *AdsRepsitoryMock
	params             *AdsRepsitoryMockGetParams
	paramPtrs          *AdsRepsitoryMockGetParamPtrs
	expectationOrigins AdsRepsitoryMockGetExpectationOrigins
	results            *AdsRepsitoryMockGetResults
	returnOrigin       string
	Counter            uint64
}

// AdsRepsitoryMockGetParams contains parameters of the AdsRepsitory.Get
type AdsRepsitoryMockGetParams struct {
	ctx      context.Context
	clientID string
}

// AdsRepsitoryMockGetParamPtrs contains pointers to parameters of the AdsRepsitory.Get
type AdsRepsitoryMockGetParamPtrs struct {
	ctx      *context.Context
	clientID *string
}

// AdsRepsitoryMockGetResults contains results of the AdsRepsitory.Get
type AdsRepsitoryMockGetResults struct {
	s1  string
	i1  int
	f1  float64
	err error
}

// AdsRepsitoryMockGetOrigins contains origins of expectations of the AdsRepsitory.Get
type AdsRepsitoryMockGetExpectationOrigins struct {
	origin         string
	originCtx      string
	originClientID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGet *mAdsRepsitoryMockGet) Optional() *mAdsRepsitoryMockGet {
	mmGet.optional = true
	return mmGet
}

// Expect sets up expected params for AdsRepsitory.Get
func (mmGet *mAdsRepsitoryMockGet) Expect(ctx context.Context, clientID string) *mAdsRepsitoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("AdsRepsitoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &AdsRepsitoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.paramPtrs != nil {
		mmGet.mock.t.Fatalf("AdsRepsitoryMock.Get mock is already set by ExpectParams functions")
	}

	mmGet.defaultExpectation.params = &AdsRepsitoryMockGetParams{ctx, clientID}
	mmGet.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// ExpectCtxParam1 sets up expected param ctx for AdsRepsitory.Get
func (mmGet *mAdsRepsitoryMockGet) ExpectCtxParam1(ctx context.Context) *mAdsRepsitoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("AdsRepsitoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &AdsRepsitoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("AdsRepsitoryMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &AdsRepsitoryMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.ctx = &ctx
	mmGet.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGet
}

// ExpectClientIDParam2 sets up expected param clientID for AdsRepsitory.Get
func (mmGet *mAdsRepsitoryMockGet) ExpectClientIDParam2(clientID string) *mAdsRepsitoryMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("AdsRepsitoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &AdsRepsitoryMockGetExpectation{}
	}

	if mmGet.defaultExpectation.params != nil {
		mmGet.mock.t.Fatalf("AdsRepsitoryMock.Get mock is already set by Expect")
	}

	if mmGet.defaultExpectation.paramPtrs == nil {
		mmGet.defaultExpectation.paramPtrs = &AdsRepsitoryMockGetParamPtrs{}
	}
	mmGet.defaultExpectation.paramPtrs.clientID = &clientID
	mmGet.defaultExpectation.expectationOrigins.originClientID = minimock.CallerInfo(1)

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the AdsRepsitory.Get
func (mmGet *mAdsRepsitoryMockGet) Inspect(f func(ctx context.Context, clientID string)) *mAdsRepsitoryMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for AdsRepsitoryMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by AdsRepsitory.Get
func (mmGet *mAdsRepsitoryMockGet) Return(s1 string, i1 int, f1 float64, err error) *AdsRepsitoryMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("AdsRepsitoryMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &AdsRepsitoryMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &AdsRepsitoryMockGetResults{s1, i1, f1, err}
	mmGet.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// Set uses given function f to mock the AdsRepsitory.Get method
func (mmGet *mAdsRepsitoryMockGet) Set(f func(ctx context.Context, clientID string) (s1 string, i1 int, f1 float64, err error)) *AdsRepsitoryMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the AdsRepsitory.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the AdsRepsitory.Get method")
	}

	mmGet.mock.funcGet = f
	mmGet.mock.funcGetOrigin = minimock.CallerInfo(1)
	return mmGet.mock
}

// When sets expectation for the AdsRepsitory.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mAdsRepsitoryMockGet) When(ctx context.Context, clientID string) *AdsRepsitoryMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("AdsRepsitoryMock.Get mock is already set by Set")
	}

	expectation := &AdsRepsitoryMockGetExpectation{
		mock:               mmGet.mock,
		params:             &AdsRepsitoryMockGetParams{ctx, clientID},
		expectationOrigins: AdsRepsitoryMockGetExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up AdsRepsitory.Get return parameters for the expectation previously defined by the When method
func (e *AdsRepsitoryMockGetExpectation) Then(s1 string, i1 int, f1 float64, err error) *AdsRepsitoryMock {
	e.results = &AdsRepsitoryMockGetResults{s1, i1, f1, err}
	return e.mock
}

// Times sets number of times AdsRepsitory.Get should be invoked
func (mmGet *mAdsRepsitoryMockGet) Times(n uint64) *mAdsRepsitoryMockGet {
	if n == 0 {
		mmGet.mock.t.Fatalf("Times of AdsRepsitoryMock.Get mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGet.expectedInvocations, n)
	mmGet.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGet
}

func (mmGet *mAdsRepsitoryMockGet) invocationsDone() bool {
	if len(mmGet.expectations) == 0 && mmGet.defaultExpectation == nil && mmGet.mock.funcGet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGet.mock.afterGetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Get implements mm_repository.AdsRepsitory
func (mmGet *AdsRepsitoryMock) Get(ctx context.Context, clientID string) (s1 string, i1 int, f1 float64, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	mmGet.t.Helper()

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(ctx, clientID)
	}

	mm_params := AdsRepsitoryMockGetParams{ctx, clientID}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, &mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.i1, e.results.f1, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_want_ptrs := mmGet.GetMock.defaultExpectation.paramPtrs

		mm_got := AdsRepsitoryMockGetParams{ctx, clientID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGet.t.Errorf("AdsRepsitoryMock.Get got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.clientID != nil && !minimock.Equal(*mm_want_ptrs.clientID, mm_got.clientID) {
				mmGet.t.Errorf("AdsRepsitoryMock.Get got unexpected parameter clientID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGet.GetMock.defaultExpectation.expectationOrigins.originClientID, *mm_want_ptrs.clientID, mm_got.clientID, minimock.Diff(*mm_want_ptrs.clientID, mm_got.clientID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("AdsRepsitoryMock.Get got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGet.GetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the AdsRepsitoryMock.Get")
		}
		return (*mm_results).s1, (*mm_results).i1, (*mm_results).f1, (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(ctx, clientID)
	}
	mmGet.t.Fatalf("Unexpected call to AdsRepsitoryMock.Get. %v %v", ctx, clientID)
	return
}

// GetAfterCounter returns a count of finished AdsRepsitoryMock.Get invocations
func (mmGet *AdsRepsitoryMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of AdsRepsitoryMock.Get invocations
func (mmGet *AdsRepsitoryMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to AdsRepsitoryMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mAdsRepsitoryMockGet) Calls() []*AdsRepsitoryMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*AdsRepsitoryMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *AdsRepsitoryMock) MinimockGetDone() bool {
	if m.GetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetMock.invocationsDone()
}

// MinimockGetInspect logs each unmet expectation
func (m *AdsRepsitoryMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AdsRepsitoryMock.Get at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCounter := mm_atomic.LoadUint64(&m.afterGetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && afterGetCounter < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AdsRepsitoryMock.Get at\n%s", m.GetMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AdsRepsitoryMock.Get at\n%s with params: %#v", m.GetMock.defaultExpectation.expectationOrigins.origin, *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && afterGetCounter < 1 {
		m.t.Errorf("Expected call to AdsRepsitoryMock.Get at\n%s", m.funcGetOrigin)
	}

	if !m.GetMock.invocationsDone() && afterGetCounter > 0 {
		m.t.Errorf("Expected %d calls to AdsRepsitoryMock.Get at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetMock.expectedInvocations), m.GetMock.expectedInvocationsOrigin, afterGetCounter)
	}
}

type mAdsRepsitoryMockImpression struct {
	optional           bool
	mock               *AdsRepsitoryMock
	defaultExpectation *AdsRepsitoryMockImpressionExpectation
	expectations       []*AdsRepsitoryMockImpressionExpectation

	callArgs []*AdsRepsitoryMockImpressionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AdsRepsitoryMockImpressionExpectation specifies expectation struct of the AdsRepsitory.Impression
type AdsRepsitoryMockImpressionExpectation struct {
	mock               *AdsRepsitoryMock
	params             *AdsRepsitoryMockImpressionParams
	paramPtrs          *AdsRepsitoryMockImpressionParamPtrs
	expectationOrigins AdsRepsitoryMockImpressionExpectationOrigins
	results            *AdsRepsitoryMockImpressionResults
	returnOrigin       string
	Counter            uint64
}

// AdsRepsitoryMockImpressionParams contains parameters of the AdsRepsitory.Impression
type AdsRepsitoryMockImpressionParams struct {
	ctx        context.Context
	campaignID string
	clientID   string
	cost       float64
}

// AdsRepsitoryMockImpressionParamPtrs contains pointers to parameters of the AdsRepsitory.Impression
type AdsRepsitoryMockImpressionParamPtrs struct {
	ctx        *context.Context
	campaignID *string
	clientID   *string
	cost       *float64
}

// AdsRepsitoryMockImpressionResults contains results of the AdsRepsitory.Impression
type AdsRepsitoryMockImpressionResults struct {
	cp1 *model.Campaign
	err error
}

// AdsRepsitoryMockImpressionOrigins contains origins of expectations of the AdsRepsitory.Impression
type AdsRepsitoryMockImpressionExpectationOrigins struct {
	origin           string
	originCtx        string
	originCampaignID string
	originClientID   string
	originCost       string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmImpression *mAdsRepsitoryMockImpression) Optional() *mAdsRepsitoryMockImpression {
	mmImpression.optional = true
	return mmImpression
}

// Expect sets up expected params for AdsRepsitory.Impression
func (mmImpression *mAdsRepsitoryMockImpression) Expect(ctx context.Context, campaignID string, clientID string, cost float64) *mAdsRepsitoryMockImpression {
	if mmImpression.mock.funcImpression != nil {
		mmImpression.mock.t.Fatalf("AdsRepsitoryMock.Impression mock is already set by Set")
	}

	if mmImpression.defaultExpectation == nil {
		mmImpression.defaultExpectation = &AdsRepsitoryMockImpressionExpectation{}
	}

	if mmImpression.defaultExpectation.paramPtrs != nil {
		mmImpression.mock.t.Fatalf("AdsRepsitoryMock.Impression mock is already set by ExpectParams functions")
	}

	mmImpression.defaultExpectation.params = &AdsRepsitoryMockImpressionParams{ctx, campaignID, clientID, cost}
	mmImpression.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmImpression.expectations {
		if minimock.Equal(e.params, mmImpression.defaultExpectation.params) {
			mmImpression.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmImpression.defaultExpectation.params)
		}
	}

	return mmImpression
}

// ExpectCtxParam1 sets up expected param ctx for AdsRepsitory.Impression
func (mmImpression *mAdsRepsitoryMockImpression) ExpectCtxParam1(ctx context.Context) *mAdsRepsitoryMockImpression {
	if mmImpression.mock.funcImpression != nil {
		mmImpression.mock.t.Fatalf("AdsRepsitoryMock.Impression mock is already set by Set")
	}

	if mmImpression.defaultExpectation == nil {
		mmImpression.defaultExpectation = &AdsRepsitoryMockImpressionExpectation{}
	}

	if mmImpression.defaultExpectation.params != nil {
		mmImpression.mock.t.Fatalf("AdsRepsitoryMock.Impression mock is already set by Expect")
	}

	if mmImpression.defaultExpectation.paramPtrs == nil {
		mmImpression.defaultExpectation.paramPtrs = &AdsRepsitoryMockImpressionParamPtrs{}
	}
	mmImpression.defaultExpectation.paramPtrs.ctx = &ctx
	mmImpression.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmImpression
}

// ExpectCampaignIDParam2 sets up expected param campaignID for AdsRepsitory.Impression
func (mmImpression *mAdsRepsitoryMockImpression) ExpectCampaignIDParam2(campaignID string) *mAdsRepsitoryMockImpression {
	if mmImpression.mock.funcImpression != nil {
		mmImpression.mock.t.Fatalf("AdsRepsitoryMock.Impression mock is already set by Set")
	}

	if mmImpression.defaultExpectation == nil {
		mmImpression.defaultExpectation = &AdsRepsitoryMockImpressionExpectation{}
	}

	if mmImpression.defaultExpectation.params != nil {
		mmImpression.mock.t.Fatalf("AdsRepsitoryMock.Impression mock is already set by Expect")
	}

	if mmImpression.defaultExpectation.paramPtrs == nil {
		mmImpression.defaultExpectation.paramPtrs = &AdsRepsitoryMockImpressionParamPtrs{}
	}
	mmImpression.defaultExpectation.paramPtrs.campaignID = &campaignID
	mmImpression.defaultExpectation.expectationOrigins.originCampaignID = minimock.CallerInfo(1)

	return mmImpression
}

// ExpectClientIDParam3 sets up expected param clientID for AdsRepsitory.Impression
func (mmImpression *mAdsRepsitoryMockImpression) ExpectClientIDParam3(clientID string) *mAdsRepsitoryMockImpression {
	if mmImpression.mock.funcImpression != nil {
		mmImpression.mock.t.Fatalf("AdsRepsitoryMock.Impression mock is already set by Set")
	}

	if mmImpression.defaultExpectation == nil {
		mmImpression.defaultExpectation = &AdsRepsitoryMockImpressionExpectation{}
	}

	if mmImpression.defaultExpectation.params != nil {
		mmImpression.mock.t.Fatalf("AdsRepsitoryMock.Impression mock is already set by Expect")
	}

	if mmImpression.defaultExpectation.paramPtrs == nil {
		mmImpression.defaultExpectation.paramPtrs = &AdsRepsitoryMockImpressionParamPtrs{}
	}
	mmImpression.defaultExpectation.paramPtrs.clientID = &clientID
	mmImpression.defaultExpectation.expectationOrigins.originClientID = minimock.CallerInfo(1)

	return mmImpression
}

// ExpectCostParam4 sets up expected param cost for AdsRepsitory.Impression
func (mmImpression *mAdsRepsitoryMockImpression) ExpectCostParam4(cost float64) *mAdsRepsitoryMockImpression {
	if mmImpression.mock.funcImpression != nil {
		mmImpression.mock.t.Fatalf("AdsRepsitoryMock.Impression mock is already set by Set")
	}

	if mmImpression.defaultExpectation == nil {
		mmImpression.defaultExpectation = &AdsRepsitoryMockImpressionExpectation{}
	}

	if mmImpression.defaultExpectation.params != nil {
		mmImpression.mock.t.Fatalf("AdsRepsitoryMock.Impression mock is already set by Expect")
	}

	if mmImpression.defaultExpectation.paramPtrs == nil {
		mmImpression.defaultExpectation.paramPtrs = &AdsRepsitoryMockImpressionParamPtrs{}
	}
	mmImpression.defaultExpectation.paramPtrs.cost = &cost
	mmImpression.defaultExpectation.expectationOrigins.originCost = minimock.CallerInfo(1)

	return mmImpression
}

// Inspect accepts an inspector function that has same arguments as the AdsRepsitory.Impression
func (mmImpression *mAdsRepsitoryMockImpression) Inspect(f func(ctx context.Context, campaignID string, clientID string, cost float64)) *mAdsRepsitoryMockImpression {
	if mmImpression.mock.inspectFuncImpression != nil {
		mmImpression.mock.t.Fatalf("Inspect function is already set for AdsRepsitoryMock.Impression")
	}

	mmImpression.mock.inspectFuncImpression = f

	return mmImpression
}

// Return sets up results that will be returned by AdsRepsitory.Impression
func (mmImpression *mAdsRepsitoryMockImpression) Return(cp1 *model.Campaign, err error) *AdsRepsitoryMock {
	if mmImpression.mock.funcImpression != nil {
		mmImpression.mock.t.Fatalf("AdsRepsitoryMock.Impression mock is already set by Set")
	}

	if mmImpression.defaultExpectation == nil {
		mmImpression.defaultExpectation = &AdsRepsitoryMockImpressionExpectation{mock: mmImpression.mock}
	}
	mmImpression.defaultExpectation.results = &AdsRepsitoryMockImpressionResults{cp1, err}
	mmImpression.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmImpression.mock
}

// Set uses given function f to mock the AdsRepsitory.Impression method
func (mmImpression *mAdsRepsitoryMockImpression) Set(f func(ctx context.Context, campaignID string, clientID string, cost float64) (cp1 *model.Campaign, err error)) *AdsRepsitoryMock {
	if mmImpression.defaultExpectation != nil {
		mmImpression.mock.t.Fatalf("Default expectation is already set for the AdsRepsitory.Impression method")
	}

	if len(mmImpression.expectations) > 0 {
		mmImpression.mock.t.Fatalf("Some expectations are already set for the AdsRepsitory.Impression method")
	}

	mmImpression.mock.funcImpression = f
	mmImpression.mock.funcImpressionOrigin = minimock.CallerInfo(1)
	return mmImpression.mock
}

// When sets expectation for the AdsRepsitory.Impression which will trigger the result defined by the following
// Then helper
func (mmImpression *mAdsRepsitoryMockImpression) When(ctx context.Context, campaignID string, clientID string, cost float64) *AdsRepsitoryMockImpressionExpectation {
	if mmImpression.mock.funcImpression != nil {
		mmImpression.mock.t.Fatalf("AdsRepsitoryMock.Impression mock is already set by Set")
	}

	expectation := &AdsRepsitoryMockImpressionExpectation{
		mock:               mmImpression.mock,
		params:             &AdsRepsitoryMockImpressionParams{ctx, campaignID, clientID, cost},
		expectationOrigins: AdsRepsitoryMockImpressionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmImpression.expectations = append(mmImpression.expectations, expectation)
	return expectation
}

// Then sets up AdsRepsitory.Impression return parameters for the expectation previously defined by the When method
func (e *AdsRepsitoryMockImpressionExpectation) Then(cp1 *model.Campaign, err error) *AdsRepsitoryMock {
	e.results = &AdsRepsitoryMockImpressionResults{cp1, err}
	return e.mock
}

// Times sets number of times AdsRepsitory.Impression should be invoked
func (mmImpression *mAdsRepsitoryMockImpression) Times(n uint64) *mAdsRepsitoryMockImpression {
	if n == 0 {
		mmImpression.mock.t.Fatalf("Times of AdsRepsitoryMock.Impression mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmImpression.expectedInvocations, n)
	mmImpression.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmImpression
}

func (mmImpression *mAdsRepsitoryMockImpression) invocationsDone() bool {
	if len(mmImpression.expectations) == 0 && mmImpression.defaultExpectation == nil && mmImpression.mock.funcImpression == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmImpression.mock.afterImpressionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmImpression.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Impression implements mm_repository.AdsRepsitory
func (mmImpression *AdsRepsitoryMock) Impression(ctx context.Context, campaignID string, clientID string, cost float64) (cp1 *model.Campaign, err error) {
	mm_atomic.AddUint64(&mmImpression.beforeImpressionCounter, 1)
	defer mm_atomic.AddUint64(&mmImpression.afterImpressionCounter, 1)

	mmImpression.t.Helper()

	if mmImpression.inspectFuncImpression != nil {
		mmImpression.inspectFuncImpression(ctx, campaignID, clientID, cost)
	}

	mm_params := AdsRepsitoryMockImpressionParams{ctx, campaignID, clientID, cost}

	// Record call args
	mmImpression.ImpressionMock.mutex.Lock()
	mmImpression.ImpressionMock.callArgs = append(mmImpression.ImpressionMock.callArgs, &mm_params)
	mmImpression.ImpressionMock.mutex.Unlock()

	for _, e := range mmImpression.ImpressionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmImpression.ImpressionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmImpression.ImpressionMock.defaultExpectation.Counter, 1)
		mm_want := mmImpression.ImpressionMock.defaultExpectation.params
		mm_want_ptrs := mmImpression.ImpressionMock.defaultExpectation.paramPtrs

		mm_got := AdsRepsitoryMockImpressionParams{ctx, campaignID, clientID, cost}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmImpression.t.Errorf("AdsRepsitoryMock.Impression got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmImpression.ImpressionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.campaignID != nil && !minimock.Equal(*mm_want_ptrs.campaignID, mm_got.campaignID) {
				mmImpression.t.Errorf("AdsRepsitoryMock.Impression got unexpected parameter campaignID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmImpression.ImpressionMock.defaultExpectation.expectationOrigins.originCampaignID, *mm_want_ptrs.campaignID, mm_got.campaignID, minimock.Diff(*mm_want_ptrs.campaignID, mm_got.campaignID))
			}

			if mm_want_ptrs.clientID != nil && !minimock.Equal(*mm_want_ptrs.clientID, mm_got.clientID) {
				mmImpression.t.Errorf("AdsRepsitoryMock.Impression got unexpected parameter clientID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmImpression.ImpressionMock.defaultExpectation.expectationOrigins.originClientID, *mm_want_ptrs.clientID, mm_got.clientID, minimock.Diff(*mm_want_ptrs.clientID, mm_got.clientID))
			}

			if mm_want_ptrs.cost != nil && !minimock.Equal(*mm_want_ptrs.cost, mm_got.cost) {
				mmImpression.t.Errorf("AdsRepsitoryMock.Impression got unexpected parameter cost, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmImpression.ImpressionMock.defaultExpectation.expectationOrigins.originCost, *mm_want_ptrs.cost, mm_got.cost, minimock.Diff(*mm_want_ptrs.cost, mm_got.cost))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmImpression.t.Errorf("AdsRepsitoryMock.Impression got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmImpression.ImpressionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmImpression.ImpressionMock.defaultExpectation.results
		if mm_results == nil {
			mmImpression.t.Fatal("No results are set for the AdsRepsitoryMock.Impression")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmImpression.funcImpression != nil {
		return mmImpression.funcImpression(ctx, campaignID, clientID, cost)
	}
	mmImpression.t.Fatalf("Unexpected call to AdsRepsitoryMock.Impression. %v %v %v %v", ctx, campaignID, clientID, cost)
	return
}

// ImpressionAfterCounter returns a count of finished AdsRepsitoryMock.Impression invocations
func (mmImpression *AdsRepsitoryMock) ImpressionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmImpression.afterImpressionCounter)
}

// ImpressionBeforeCounter returns a count of AdsRepsitoryMock.Impression invocations
func (mmImpression *AdsRepsitoryMock) ImpressionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmImpression.beforeImpressionCounter)
}

// Calls returns a list of arguments used in each call to AdsRepsitoryMock.Impression.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmImpression *mAdsRepsitoryMockImpression) Calls() []*AdsRepsitoryMockImpressionParams {
	mmImpression.mutex.RLock()

	argCopy := make([]*AdsRepsitoryMockImpressionParams, len(mmImpression.callArgs))
	copy(argCopy, mmImpression.callArgs)

	mmImpression.mutex.RUnlock()

	return argCopy
}

// MinimockImpressionDone returns true if the count of the Impression invocations corresponds
// the number of defined expectations
func (m *AdsRepsitoryMock) MinimockImpressionDone() bool {
	if m.ImpressionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ImpressionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ImpressionMock.invocationsDone()
}

// MinimockImpressionInspect logs each unmet expectation
func (m *AdsRepsitoryMock) MinimockImpressionInspect() {
	for _, e := range m.ImpressionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AdsRepsitoryMock.Impression at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterImpressionCounter := mm_atomic.LoadUint64(&m.afterImpressionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ImpressionMock.defaultExpectation != nil && afterImpressionCounter < 1 {
		if m.ImpressionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AdsRepsitoryMock.Impression at\n%s", m.ImpressionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AdsRepsitoryMock.Impression at\n%s with params: %#v", m.ImpressionMock.defaultExpectation.expectationOrigins.origin, *m.ImpressionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcImpression != nil && afterImpressionCounter < 1 {
		m.t.Errorf("Expected call to AdsRepsitoryMock.Impression at\n%s", m.funcImpressionOrigin)
	}

	if !m.ImpressionMock.invocationsDone() && afterImpressionCounter > 0 {
		m.t.Errorf("Expected %d calls to AdsRepsitoryMock.Impression at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ImpressionMock.expectedInvocations), m.ImpressionMock.expectedInvocationsOrigin, afterImpressionCounter)
	}
}

type mAdsRepsitoryMockIsShownToClient struct {
	optional           bool
	mock               *AdsRepsitoryMock
	defaultExpectation *AdsRepsitoryMockIsShownToClientExpectation
	expectations       []*AdsRepsitoryMockIsShownToClientExpectation

	callArgs []*AdsRepsitoryMockIsShownToClientParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AdsRepsitoryMockIsShownToClientExpectation specifies expectation struct of the AdsRepsitory.IsShownToClient
type AdsRepsitoryMockIsShownToClientExpectation struct {
	mock               *AdsRepsitoryMock
	params             *AdsRepsitoryMockIsShownToClientParams
	paramPtrs          *AdsRepsitoryMockIsShownToClientParamPtrs
	expectationOrigins AdsRepsitoryMockIsShownToClientExpectationOrigins
	results            *AdsRepsitoryMockIsShownToClientResults
	returnOrigin       string
	Counter            uint64
}

// AdsRepsitoryMockIsShownToClientParams contains parameters of the AdsRepsitory.IsShownToClient
type AdsRepsitoryMockIsShownToClientParams struct {
	ctx        context.Context
	campaignID string
	clientID   string
}

// AdsRepsitoryMockIsShownToClientParamPtrs contains pointers to parameters of the AdsRepsitory.IsShownToClient
type AdsRepsitoryMockIsShownToClientParamPtrs struct {
	ctx        *context.Context
	campaignID *string
	clientID   *string
}

// AdsRepsitoryMockIsShownToClientResults contains results of the AdsRepsitory.IsShownToClient
type AdsRepsitoryMockIsShownToClientResults struct {
	b1  bool
	err error
}

// AdsRepsitoryMockIsShownToClientOrigins contains origins of expectations of the AdsRepsitory.IsShownToClient
type AdsRepsitoryMockIsShownToClientExpectationOrigins struct {
	origin           string
	originCtx        string
	originCampaignID string
	originClientID   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmIsShownToClient *mAdsRepsitoryMockIsShownToClient) Optional() *mAdsRepsitoryMockIsShownToClient {
	mmIsShownToClient.optional = true
	return mmIsShownToClient
}

// Expect sets up expected params for AdsRepsitory.IsShownToClient
func (mmIsShownToClient *mAdsRepsitoryMockIsShownToClient) Expect(ctx context.Context, campaignID string, clientID string) *mAdsRepsitoryMockIsShownToClient {
	if mmIsShownToClient.mock.funcIsShownToClient != nil {
		mmIsShownToClient.mock.t.Fatalf("AdsRepsitoryMock.IsShownToClient mock is already set by Set")
	}

	if mmIsShownToClient.defaultExpectation == nil {
		mmIsShownToClient.defaultExpectation = &AdsRepsitoryMockIsShownToClientExpectation{}
	}

	if mmIsShownToClient.defaultExpectation.paramPtrs != nil {
		mmIsShownToClient.mock.t.Fatalf("AdsRepsitoryMock.IsShownToClient mock is already set by ExpectParams functions")
	}

	mmIsShownToClient.defaultExpectation.params = &AdsRepsitoryMockIsShownToClientParams{ctx, campaignID, clientID}
	mmIsShownToClient.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmIsShownToClient.expectations {
		if minimock.Equal(e.params, mmIsShownToClient.defaultExpectation.params) {
			mmIsShownToClient.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIsShownToClient.defaultExpectation.params)
		}
	}

	return mmIsShownToClient
}

// ExpectCtxParam1 sets up expected param ctx for AdsRepsitory.IsShownToClient
func (mmIsShownToClient *mAdsRepsitoryMockIsShownToClient) ExpectCtxParam1(ctx context.Context) *mAdsRepsitoryMockIsShownToClient {
	if mmIsShownToClient.mock.funcIsShownToClient != nil {
		mmIsShownToClient.mock.t.Fatalf("AdsRepsitoryMock.IsShownToClient mock is already set by Set")
	}

	if mmIsShownToClient.defaultExpectation == nil {
		mmIsShownToClient.defaultExpectation = &AdsRepsitoryMockIsShownToClientExpectation{}
	}

	if mmIsShownToClient.defaultExpectation.params != nil {
		mmIsShownToClient.mock.t.Fatalf("AdsRepsitoryMock.IsShownToClient mock is already set by Expect")
	}

	if mmIsShownToClient.defaultExpectation.paramPtrs == nil {
		mmIsShownToClient.defaultExpectation.paramPtrs = &AdsRepsitoryMockIsShownToClientParamPtrs{}
	}
	mmIsShownToClient.defaultExpectation.paramPtrs.ctx = &ctx
	mmIsShownToClient.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmIsShownToClient
}

// ExpectCampaignIDParam2 sets up expected param campaignID for AdsRepsitory.IsShownToClient
func (mmIsShownToClient *mAdsRepsitoryMockIsShownToClient) ExpectCampaignIDParam2(campaignID string) *mAdsRepsitoryMockIsShownToClient {
	if mmIsShownToClient.mock.funcIsShownToClient != nil {
		mmIsShownToClient.mock.t.Fatalf("AdsRepsitoryMock.IsShownToClient mock is already set by Set")
	}

	if mmIsShownToClient.defaultExpectation == nil {
		mmIsShownToClient.defaultExpectation = &AdsRepsitoryMockIsShownToClientExpectation{}
	}

	if mmIsShownToClient.defaultExpectation.params != nil {
		mmIsShownToClient.mock.t.Fatalf("AdsRepsitoryMock.IsShownToClient mock is already set by Expect")
	}

	if mmIsShownToClient.defaultExpectation.paramPtrs == nil {
		mmIsShownToClient.defaultExpectation.paramPtrs = &AdsRepsitoryMockIsShownToClientParamPtrs{}
	}
	mmIsShownToClient.defaultExpectation.paramPtrs.campaignID = &campaignID
	mmIsShownToClient.defaultExpectation.expectationOrigins.originCampaignID = minimock.CallerInfo(1)

	return mmIsShownToClient
}

// ExpectClientIDParam3 sets up expected param clientID for AdsRepsitory.IsShownToClient
func (mmIsShownToClient *mAdsRepsitoryMockIsShownToClient) ExpectClientIDParam3(clientID string) *mAdsRepsitoryMockIsShownToClient {
	if mmIsShownToClient.mock.funcIsShownToClient != nil {
		mmIsShownToClient.mock.t.Fatalf("AdsRepsitoryMock.IsShownToClient mock is already set by Set")
	}

	if mmIsShownToClient.defaultExpectation == nil {
		mmIsShownToClient.defaultExpectation = &AdsRepsitoryMockIsShownToClientExpectation{}
	}

	if mmIsShownToClient.defaultExpectation.params != nil {
		mmIsShownToClient.mock.t.Fatalf("AdsRepsitoryMock.IsShownToClient mock is already set by Expect")
	}

	if mmIsShownToClient.defaultExpectation.paramPtrs == nil {
		mmIsShownToClient.defaultExpectation.paramPtrs = &AdsRepsitoryMockIsShownToClientParamPtrs{}
	}
	mmIsShownToClient.defaultExpectation.paramPtrs.clientID = &clientID
	mmIsShownToClient.defaultExpectation.expectationOrigins.originClientID = minimock.CallerInfo(1)

	return mmIsShownToClient
}

// Inspect accepts an inspector function that has same arguments as the AdsRepsitory.IsShownToClient
func (mmIsShownToClient *mAdsRepsitoryMockIsShownToClient) Inspect(f func(ctx context.Context, campaignID string, clientID string)) *mAdsRepsitoryMockIsShownToClient {
	if mmIsShownToClient.mock.inspectFuncIsShownToClient != nil {
		mmIsShownToClient.mock.t.Fatalf("Inspect function is already set for AdsRepsitoryMock.IsShownToClient")
	}

	mmIsShownToClient.mock.inspectFuncIsShownToClient = f

	return mmIsShownToClient
}

// Return sets up results that will be returned by AdsRepsitory.IsShownToClient
func (mmIsShownToClient *mAdsRepsitoryMockIsShownToClient) Return(b1 bool, err error) *AdsRepsitoryMock {
	if mmIsShownToClient.mock.funcIsShownToClient != nil {
		mmIsShownToClient.mock.t.Fatalf("AdsRepsitoryMock.IsShownToClient mock is already set by Set")
	}

	if mmIsShownToClient.defaultExpectation == nil {
		mmIsShownToClient.defaultExpectation = &AdsRepsitoryMockIsShownToClientExpectation{mock: mmIsShownToClient.mock}
	}
	mmIsShownToClient.defaultExpectation.results = &AdsRepsitoryMockIsShownToClientResults{b1, err}
	mmIsShownToClient.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmIsShownToClient.mock
}

// Set uses given function f to mock the AdsRepsitory.IsShownToClient method
func (mmIsShownToClient *mAdsRepsitoryMockIsShownToClient) Set(f func(ctx context.Context, campaignID string, clientID string) (b1 bool, err error)) *AdsRepsitoryMock {
	if mmIsShownToClient.defaultExpectation != nil {
		mmIsShownToClient.mock.t.Fatalf("Default expectation is already set for the AdsRepsitory.IsShownToClient method")
	}

	if len(mmIsShownToClient.expectations) > 0 {
		mmIsShownToClient.mock.t.Fatalf("Some expectations are already set for the AdsRepsitory.IsShownToClient method")
	}

	mmIsShownToClient.mock.funcIsShownToClient = f
	mmIsShownToClient.mock.funcIsShownToClientOrigin = minimock.CallerInfo(1)
	return mmIsShownToClient.mock
}

// When sets expectation for the AdsRepsitory.IsShownToClient which will trigger the result defined by the following
// Then helper
func (mmIsShownToClient *mAdsRepsitoryMockIsShownToClient) When(ctx context.Context, campaignID string, clientID string) *AdsRepsitoryMockIsShownToClientExpectation {
	if mmIsShownToClient.mock.funcIsShownToClient != nil {
		mmIsShownToClient.mock.t.Fatalf("AdsRepsitoryMock.IsShownToClient mock is already set by Set")
	}

	expectation := &AdsRepsitoryMockIsShownToClientExpectation{
		mock:               mmIsShownToClient.mock,
		params:             &AdsRepsitoryMockIsShownToClientParams{ctx, campaignID, clientID},
		expectationOrigins: AdsRepsitoryMockIsShownToClientExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmIsShownToClient.expectations = append(mmIsShownToClient.expectations, expectation)
	return expectation
}

// Then sets up AdsRepsitory.IsShownToClient return parameters for the expectation previously defined by the When method
func (e *AdsRepsitoryMockIsShownToClientExpectation) Then(b1 bool, err error) *AdsRepsitoryMock {
	e.results = &AdsRepsitoryMockIsShownToClientResults{b1, err}
	return e.mock
}

// Times sets number of times AdsRepsitory.IsShownToClient should be invoked
func (mmIsShownToClient *mAdsRepsitoryMockIsShownToClient) Times(n uint64) *mAdsRepsitoryMockIsShownToClient {
	if n == 0 {
		mmIsShownToClient.mock.t.Fatalf("Times of AdsRepsitoryMock.IsShownToClient mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmIsShownToClient.expectedInvocations, n)
	mmIsShownToClient.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmIsShownToClient
}

func (mmIsShownToClient *mAdsRepsitoryMockIsShownToClient) invocationsDone() bool {
	if len(mmIsShownToClient.expectations) == 0 && mmIsShownToClient.defaultExpectation == nil && mmIsShownToClient.mock.funcIsShownToClient == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmIsShownToClient.mock.afterIsShownToClientCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmIsShownToClient.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// IsShownToClient implements mm_repository.AdsRepsitory
func (mmIsShownToClient *AdsRepsitoryMock) IsShownToClient(ctx context.Context, campaignID string, clientID string) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmIsShownToClient.beforeIsShownToClientCounter, 1)
	defer mm_atomic.AddUint64(&mmIsShownToClient.afterIsShownToClientCounter, 1)

	mmIsShownToClient.t.Helper()

	if mmIsShownToClient.inspectFuncIsShownToClient != nil {
		mmIsShownToClient.inspectFuncIsShownToClient(ctx, campaignID, clientID)
	}

	mm_params := AdsRepsitoryMockIsShownToClientParams{ctx, campaignID, clientID}

	// Record call args
	mmIsShownToClient.IsShownToClientMock.mutex.Lock()
	mmIsShownToClient.IsShownToClientMock.callArgs = append(mmIsShownToClient.IsShownToClientMock.callArgs, &mm_params)
	mmIsShownToClient.IsShownToClientMock.mutex.Unlock()

	for _, e := range mmIsShownToClient.IsShownToClientMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmIsShownToClient.IsShownToClientMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsShownToClient.IsShownToClientMock.defaultExpectation.Counter, 1)
		mm_want := mmIsShownToClient.IsShownToClientMock.defaultExpectation.params
		mm_want_ptrs := mmIsShownToClient.IsShownToClientMock.defaultExpectation.paramPtrs

		mm_got := AdsRepsitoryMockIsShownToClientParams{ctx, campaignID, clientID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmIsShownToClient.t.Errorf("AdsRepsitoryMock.IsShownToClient got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmIsShownToClient.IsShownToClientMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.campaignID != nil && !minimock.Equal(*mm_want_ptrs.campaignID, mm_got.campaignID) {
				mmIsShownToClient.t.Errorf("AdsRepsitoryMock.IsShownToClient got unexpected parameter campaignID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmIsShownToClient.IsShownToClientMock.defaultExpectation.expectationOrigins.originCampaignID, *mm_want_ptrs.campaignID, mm_got.campaignID, minimock.Diff(*mm_want_ptrs.campaignID, mm_got.campaignID))
			}

			if mm_want_ptrs.clientID != nil && !minimock.Equal(*mm_want_ptrs.clientID, mm_got.clientID) {
				mmIsShownToClient.t.Errorf("AdsRepsitoryMock.IsShownToClient got unexpected parameter clientID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmIsShownToClient.IsShownToClientMock.defaultExpectation.expectationOrigins.originClientID, *mm_want_ptrs.clientID, mm_got.clientID, minimock.Diff(*mm_want_ptrs.clientID, mm_got.clientID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmIsShownToClient.t.Errorf("AdsRepsitoryMock.IsShownToClient got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmIsShownToClient.IsShownToClientMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmIsShownToClient.IsShownToClientMock.defaultExpectation.results
		if mm_results == nil {
			mmIsShownToClient.t.Fatal("No results are set for the AdsRepsitoryMock.IsShownToClient")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmIsShownToClient.funcIsShownToClient != nil {
		return mmIsShownToClient.funcIsShownToClient(ctx, campaignID, clientID)
	}
	mmIsShownToClient.t.Fatalf("Unexpected call to AdsRepsitoryMock.IsShownToClient. %v %v %v", ctx, campaignID, clientID)
	return
}

// IsShownToClientAfterCounter returns a count of finished AdsRepsitoryMock.IsShownToClient invocations
func (mmIsShownToClient *AdsRepsitoryMock) IsShownToClientAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsShownToClient.afterIsShownToClientCounter)
}

// IsShownToClientBeforeCounter returns a count of AdsRepsitoryMock.IsShownToClient invocations
func (mmIsShownToClient *AdsRepsitoryMock) IsShownToClientBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsShownToClient.beforeIsShownToClientCounter)
}

// Calls returns a list of arguments used in each call to AdsRepsitoryMock.IsShownToClient.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIsShownToClient *mAdsRepsitoryMockIsShownToClient) Calls() []*AdsRepsitoryMockIsShownToClientParams {
	mmIsShownToClient.mutex.RLock()

	argCopy := make([]*AdsRepsitoryMockIsShownToClientParams, len(mmIsShownToClient.callArgs))
	copy(argCopy, mmIsShownToClient.callArgs)

	mmIsShownToClient.mutex.RUnlock()

	return argCopy
}

// MinimockIsShownToClientDone returns true if the count of the IsShownToClient invocations corresponds
// the number of defined expectations
func (m *AdsRepsitoryMock) MinimockIsShownToClientDone() bool {
	if m.IsShownToClientMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.IsShownToClientMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.IsShownToClientMock.invocationsDone()
}

// MinimockIsShownToClientInspect logs each unmet expectation
func (m *AdsRepsitoryMock) MinimockIsShownToClientInspect() {
	for _, e := range m.IsShownToClientMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AdsRepsitoryMock.IsShownToClient at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterIsShownToClientCounter := mm_atomic.LoadUint64(&m.afterIsShownToClientCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.IsShownToClientMock.defaultExpectation != nil && afterIsShownToClientCounter < 1 {
		if m.IsShownToClientMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AdsRepsitoryMock.IsShownToClient at\n%s", m.IsShownToClientMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AdsRepsitoryMock.IsShownToClient at\n%s with params: %#v", m.IsShownToClientMock.defaultExpectation.expectationOrigins.origin, *m.IsShownToClientMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsShownToClient != nil && afterIsShownToClientCounter < 1 {
		m.t.Errorf("Expected call to AdsRepsitoryMock.IsShownToClient at\n%s", m.funcIsShownToClientOrigin)
	}

	if !m.IsShownToClientMock.invocationsDone() && afterIsShownToClientCounter > 0 {
		m.t.Errorf("Expected %d calls to AdsRepsitoryMock.IsShownToClient at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.IsShownToClientMock.expectedInvocations), m.IsShownToClientMock.expectedInvocationsOrigin, afterIsShownToClientCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *AdsRepsitoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockClickInspect()

			m.MinimockGetInspect()

			m.MinimockImpressionInspect()

			m.MinimockIsShownToClientInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *AdsRepsitoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *AdsRepsitoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockClickDone() &&
		m.MinimockGetDone() &&
		m.MinimockImpressionDone() &&
		m.MinimockIsShownToClientDone()
}
